Project Path: organizer

Source Tree:

```txt
organizer
├── Cargo.lock
├── Cargo.toml
├── README.md
├── org.md
├── organize-cli
│   ├── Cargo.toml
│   └── src
│       ├── cmd
│       │   ├── edit.rs
│       │   ├── logs.rs
│       │   ├── mod.rs
│       │   ├── run.rs
│       │   └── undo.rs
│       └── main.rs
├── organize-sdk
│   ├── Cargo.toml
│   ├── migrations
│   │   └── 20250623125855_initial_schema.sql
│   └── src
│       ├── context
│       │   ├── mod.rs
│       │   ├── scope.rs
│       │   ├── services
│       │   │   ├── fs
│       │   │   │   ├── backup.rs
│       │   │   │   ├── locker.rs
│       │   │   │   ├── manager.rs
│       │   │   │   └── mod.rs
│       │   │   ├── history
│       │   │   │   ├── known_files.rs
│       │   │   │   ├── mod.rs
│       │   │   │   ├── sessions.rs
│       │   │   │   └── transactions.rs
│       │   │   └── mod.rs
│       │   └── settings.rs
│       ├── engine
│       │   ├── batch.rs
│       │   ├── mod.rs
│       │   ├── pipeline.rs
│       │   ├── rule.rs
│       │   └── stage.rs
│       ├── error.rs
│       ├── errors.rs
│       ├── lib.rs
│       ├── location
│       │   ├── mod.rs
│       │   └── options.rs
│       ├── plugins
│       │   ├── action.rs
│       │   ├── filter.rs
│       │   ├── mod.rs
│       │   ├── partitioner.rs
│       │   ├── selector.rs
│       │   ├── sorter.rs
│       │   └── storage.rs
│       ├── resource.rs
│       ├── stdx
│       │   ├── mod.rs
│       │   └── path.rs
│       ├── templates
│       │   ├── accessor.rs
│       │   ├── compiler.rs
│       │   ├── engine.rs
│       │   ├── filter.rs
│       │   ├── grammar.pest
│       │   ├── mod.rs
│       │   ├── parser.rs
│       │   ├── registry.rs
│       │   ├── schema.rs
│       │   ├── template.rs
│       │   ├── value.rs
│       │   └── variable.rs
│       └── utils
│           └── mod.rs
├── organize-std
│   ├── Cargo.toml
│   └── src
│       ├── actions
│       │   ├── copy.rs
│       │   ├── echo.rs
│       │   └── mod.rs
│       ├── filters
│       │   ├── empty.rs
│       │   └── mod.rs
│       ├── lib.rs
│       ├── partitioners
│       │   ├── extension.rs
│       │   ├── mod.rs
│       │   └── ratio.rs
│       ├── selectors
│       │   ├── first.rs
│       │   └── mod.rs
│       ├── sorters
│       │   ├── mod.rs
│       │   └── random.rs
│       ├── storage
│       │   ├── local.rs
│       │   ├── mod.rs
│       │   └── sftp.rs
│       └── variables
│           ├── args.rs
│           ├── env.rs
│           ├── file.rs
│           └── mod.rs
├── prompt.md
├── rules
│   ├── copy_test.rule.toml
│   ├── on_batches_test.rule.toml
│   └── test.rule.toml
├── rustfmt.toml
└── test_data
    ├── empty_file.txt
    └── on_batches
        ├── archive.zip
        ├── image.jpg
        └── picture.png

```

`organizer/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aead"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
dependencies = [
 "crypto-common",
 "generic-array",
]

[[package]]
name = "aes"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "aes-gcm"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "831010a0f742e1209b3bcea8fab6a8e149051ba6099432c8cb2cc117dec3ead1"
dependencies = [
 "aead",
 "aes",
 "cipher",
 "ctr",
 "ghash",
 "subtle",
]

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "const-random",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "argon2"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c3610892ee6e0cbce8ae2700349fcf8f98adb0dbfbee85aec3c9179d29cc072"
dependencies = [
 "base64ct",
 "blake2",
 "cpufeatures",
 "password-hash",
]

[[package]]
name = "async-lock"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-trait"
version = "0.1.88"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atoi"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
dependencies = [
 "num-traits",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "aws-lc-rs"
version = "1.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fcc8f365936c834db5514fc45aee5b1202d677e6b40e48468aaaa8183ca8c7"
dependencies = [
 "aws-lc-sys",
 "untrusted",
 "zeroize",
]

[[package]]
name = "aws-lc-sys"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61b1d86e7705efe1be1b569bab41d4fa1e14e220b60a160f78de2db687add079"
dependencies = [
 "bindgen",
 "cc",
 "cmake",
 "dunce",
 "fs_extra",
]

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base16ct"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c7f02d4ea65f2c1853089ffd8d2787bdbc63de2f0d29dedbcf8ccdfa0ccd4cf"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"

[[package]]
name = "bcrypt-pbkdf"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6aeac2e1fe888769f34f05ac343bbef98b14d1ffb292ab69d4608b3abc86f2a2"
dependencies = [
 "blowfish",
 "pbkdf2",
 "sha2",
]

[[package]]
name = "bindgen"
version = "0.69.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
dependencies = [
 "bitflags 2.9.1",
 "cexpr",
 "clang-sys",
 "itertools",
 "lazy_static",
 "lazycell",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn",
 "which",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
dependencies = [
 "serde",
]

[[package]]
name = "blake2"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe"
dependencies = [
 "digest",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-padding"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8894febbff9f758034a5b8e12d87918f56dfc64a8e1fe757d65e29041538d93"
dependencies = [
 "generic-array",
]

[[package]]
name = "blowfish"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e412e2cd0f2b2d93e02543ceae7917b3c70331573df19ee046bcbc35e45e87d7"
dependencies = [
 "byteorder",
 "cipher",
]

[[package]]
name = "bumpalo"
version = "3.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cbc"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26b52a9543ae338f279b96b0b9fed9c8093744685043739079ce85cd58f289a6"
dependencies = [
 "cipher",
]

[[package]]
name = "cc"
version = "1.2.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d487aa071b5f64da6f19a3e848e3578944b726ee5a4854b82172f02aa876bfdc"
dependencies = [
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chacha20"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3613f74bd2eac03dad61bd53dbe620703d4371614fe0bc3b9f04dd36fe4e818"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common",
 "inout",
]

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c7947ae4cc3d851207c1adb5b5e260ff0cca11446b1d6d1423788e442257ce"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "cmake"
version = "0.1.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7caa3f9de89ddbe2c607f4101924c5abec803763ae9534e4f4d7d8f84aa81f0"
dependencies = [
 "cc",
]

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "colored"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fde0e0ec90c9dfb3b4b1a0891a7dcd0e2bffde2f7efed5fe7c9bb00e5bfb915e"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console"
version = "0.15.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
dependencies = [
 "encode_unicode",
 "libc",
 "once_cell",
 "unicode-width",
 "windows-sys 0.59.0",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom 0.2.16",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-bigint"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dc92fb57ca44df6db8059111ab3af99a63d5d0f8375d9972e319a379c6bab76"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "subtle",
 "zeroize",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "ctr"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0369ee1ad671834580515889b80f2ea915f23b8be8d0daa4bbaf2ac5c7590835"
dependencies = [
 "cipher",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dashmap"
version = "6.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core",
]

[[package]]
name = "data-encoding"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a2330da5de22e8a3cb63252ce2abb30116bf5265e89c0e01bc17015ce30a476"

[[package]]
name = "deadpool"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ed5957ff93768adf7a65ab167a17835c3d2c3c50d084fe305174c112f468e2f"
dependencies = [
 "deadpool-runtime",
 "num_cpus",
 "tokio",
]

[[package]]
name = "deadpool-runtime"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "092966b41edc516079bdf31ec78a2e0588d1d0c08f78b91d8307215928642b2b"

[[package]]
name = "delegate"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9b6483c2bbed26f97861cf57651d4f2b731964a28cd2257f934a4b452480d21"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
]

[[package]]
name = "dialoguer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59c6f2989294b9a498d3ad5491a79c6deb604617378e1cdc4bfc1c1361fe2f87"
dependencies = [
 "console",
 "shell-words",
 "tempfile",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dotenvy"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"

[[package]]
name = "dunce"
version = "1.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"

[[package]]
name = "dyn-clone"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c7a8fb8a9fbf66c1f703fe16184d10ca0ee9d23be5b4436400408ba54a95005"

[[package]]
name = "dyn-eq"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c2d035d21af5cde1a6f5c7b444a5bf963520a9f142e5d06931178433d7d5388"

[[package]]
name = "ecdsa"
version = "0.16.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee27f32b5c5292967d2d4a9d7f1e0b0aed2c15daded5a60300e4abb9d8020bca"
dependencies = [
 "der",
 "digest",
 "elliptic-curve",
 "rfc6979",
 "signature",
 "spki",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3daa8e81a3963a60642bcc1f90a670680bd4a77535faa384e9d1c79d620871"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "rand_core 0.6.4",
 "serde",
 "sha2",
 "subtle",
 "zeroize",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
dependencies = [
 "serde",
]

[[package]]
name = "elliptic-curve"
version = "0.13.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6043086bf7973472e0c7dff2142ea0b680d30e18d9cc40f267efbf222bd47"
dependencies = [
 "base16ct",
 "crypto-bigint",
 "digest",
 "ff",
 "generic-array",
 "group",
 "hkdf",
 "pem-rfc7468",
 "pkcs8",
 "rand_core 0.6.4",
 "sec1",
 "subtle",
 "zeroize",
]

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "enum_dispatch"
version = "0.3.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa18ce2bc66555b3218614519ac839ddb759a7d6720732f979ef8d13be147ecd"
dependencies = [
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e004d887f51fcb9fef17317a2f3525c887d8aa3f4f50fed920816a688284a5b7"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "etcetera"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "136d1b5283a1ab77bd9257427ffd09d8667ced0570b6f938942bc7568ed5b943"
dependencies = [
 "cfg-if",
 "home",
 "windows-sys 0.48.0",
]

[[package]]
name = "event-listener"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "ff"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0b50bfb653653f9ca9095b427bed08ab8d75a137839d9ad64eb11810d5b6393"
dependencies = [
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "filetime"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
dependencies = [
 "cfg-if",
 "libc",
 "libredox",
 "windows-sys 0.59.0",
]

[[package]]
name = "flate2"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a3d7db9596fecd151c5f638c0ee5d5bd487b6e0ea232e5dc96d5250f6f94b1d"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "flume"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da0e4dd2a88388a1f4ccc7c9ce104604dab68d9f408dc34cd45823d5a9069095"
dependencies = [
 "futures-core",
 "futures-sink",
 "spin",
]

[[package]]
name = "flurry"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf5efcf77a4da27927d3ab0509dec5b0954bb3bc59da5a1de9e52642ebd4cdf9"
dependencies = [
 "ahash",
 "num_cpus",
 "parking_lot",
 "seize",
]

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs_extra"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"

[[package]]
name = "fsevent-sys"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2"
dependencies = [
 "libc",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-intrusive"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d930c203dd0b6ff06e0201a4a2fe9149b43c684fd4420555b26d21b1a02956f"
dependencies = [
 "futures-core",
 "lock_api",
 "parking_lot",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generator"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d18470a76cb7f8ff746cf1f7470914f900252ec36bbc40b569d74b1258446827"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "log",
 "rustversion",
 "windows 0.61.3",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
 "zeroize",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "ghash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0d8a4362ccb29cb0b265253fb0a2728f592895ee6854fd9bc13f2ffda266ff1"
dependencies = [
 "opaque-debug",
 "polyval",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "glob"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2"

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "hashlink"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7382cf6263419f2d8df38c55d7da83da5c18aef87fc7a7fc1fb1e344edfe14c1"
dependencies = [
 "hashbrown 0.15.4",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hex-literal"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fe2267d4ed49bc07b63801559be28c718ea06c4738b7a03c94df7386d2cde46"

[[package]]
name = "hkdf"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5f8eb2ad728638ea2c7d47a21db23b7b58a72ed6a38256b8a1849f15fbbdf7"
dependencies = [
 "hmac",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core 0.61.2",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown 0.15.4",
]

[[package]]
name = "inotify"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
dependencies = [
 "bitflags 2.9.1",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "inout"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
dependencies = [
 "block-padding",
 "generic-array",
]

[[package]]
name = "internal-russh-forked-ssh-key"
version = "0.6.11+upstream-0.6.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0a77eae781ed6a7709fb15b64862fcca13d886b07c7e2786f5ed34e5e2b9187"
dependencies = [
 "argon2",
 "bcrypt-pbkdf",
 "ecdsa",
 "ed25519-dalek",
 "hex",
 "hmac",
 "num-bigint-dig",
 "p256",
 "p384",
 "p521",
 "rand_core 0.6.4",
 "rsa",
 "sec1",
 "sha1",
 "sha2",
 "signature",
 "ssh-cipher",
 "ssh-encoding",
 "subtle",
 "zeroize",
]

[[package]]
name = "inventory"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab08d7cd2c5897f2c949e5383ea7c7db03fb19130ffcfbf7eda795137ae3cb83"
dependencies = [
 "rustversion",
]

[[package]]
name = "io-uring"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b86e202f00093dcba4275d4636b93ef9dd75d025ae560d2521b45ea28ab49013"
dependencies = [
 "bitflags 2.9.1",
 "cfg-if",
 "libc",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "jobserver"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38f262f097c174adebe41eb73d66ae9c06b2844fb0da69969647bbddd9b0538a"
dependencies = [
 "getrandom 0.3.3",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "kqueue"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac30106d7dce88daf4a3fcb4879ea939476d5074a9b7ddd0fb97fa4bed5596a"
dependencies = [
 "kqueue-sys",
 "libc",
]

[[package]]
name = "kqueue-sys"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed9625ffda8729b85e45cf04090035ac368927b8cebc34898e7c120f52e4838b"
dependencies = [
 "bitflags 1.3.2",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libloading"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07033963ba89ebaf1584d767badaa2e8fcec21aedea6b8c0346d487d49c28667"
dependencies = [
 "cfg-if",
 "windows-targets 0.52.6",
]

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1580801010e535496706ba011c15f8532df6b42297d2e471fec38ceadd8c0638"
dependencies = [
 "bitflags 2.9.1",
 "libc",
 "redox_syscall",
]

[[package]]
name = "libsqlite3-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "libssh2-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "220e4f05ad4a218192533b300327f5150e809b54c4ec83b5a1d91833601811b9"
dependencies = [
 "cc",
 "libc",
 "libz-sys",
 "openssl-sys",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "libz-sys"
version = "1.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b70e7a7df205e92a1a4cd9aaae7898dac0aa555503cc0a649494d0d60e7651d"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "loom"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "419e0dc8046cb947daa77eb95ae174acfbddb7673b4151f56d1eed8e93fbfaca"
dependencies = [
 "cfg-if",
 "generator",
 "scoped-tls",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest",
]

[[package]]
name = "md5"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "490cc448043f947bae3cbee9c203358d62dbee0db12107a74be5c30ccfd09771"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess"
version = "2.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "log",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "moka"
version = "0.12.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9321642ca94a4282428e6ea4af8cc2ca4eac48ac7a6a4ea8f33f76d0ce70926"
dependencies = [
 "async-lock",
 "crossbeam-channel",
 "crossbeam-epoch",
 "crossbeam-utils",
 "event-listener",
 "futures-util",
 "loom",
 "parking_lot",
 "portable-atomic",
 "rustc_version",
 "smallvec",
 "tagptr",
 "thiserror 1.0.69",
 "uuid",
]

[[package]]
name = "nix"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71e2746dc3a24dd78b3cfcb7be93368c6de9963d30f43a6a73998a9cf4b17b46"
dependencies = [
 "bitflags 2.9.1",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "notify"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fee8403b3d66ac7b26aee6e40a897d85dc5ce26f44da36b8b73e987cc52e943"
dependencies = [
 "bitflags 2.9.1",
 "filetime",
 "fsevent-sys",
 "inotify",
 "kqueue",
 "libc",
 "log",
 "mio",
 "notify-types",
 "walkdir",
 "windows-sys 0.59.0",
]

[[package]]
name = "notify-types"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e0826a989adedc2a244799e823aece04662b66609d96af8dff7ac6df9a8925d"

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
dependencies = [
 "num-integer",
 "num-traits",
 "rand 0.8.5",
]

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand 0.8.5",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_cpus"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91df4bbde75afed763b708b7eee1e8e7651e02d97f6d5dd763e89367e957b23b"
dependencies = [
 "hermit-abi",
 "libc",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "openssl-sys"
version = "0.9.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90096e2e47630d78b7d1c20952dc621f957103f8bc2c8359ec81290d75238571"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "organize-cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "chrono",
 "clap",
 "colored",
 "dialoguer",
 "lazy_static",
 "notify",
 "organize-sdk",
 "organize-std",
 "tokio",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
]

[[package]]
name = "organize-sdk"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "clap",
 "dashmap",
 "deadpool",
 "dialoguer",
 "dirs",
 "dotenvy",
 "dyn-clone",
 "dyn-eq",
 "futures",
 "glob",
 "inventory",
 "libc",
 "mime_guess",
 "moka",
 "pest",
 "pest_derive",
 "russh",
 "russh-sftp",
 "serde",
 "serde_json",
 "sha2",
 "sqlx",
 "ssh2",
 "strum",
 "tempfile",
 "thiserror 2.0.12",
 "tokio",
 "toml",
 "tracing",
 "typetag",
 "url",
 "uuid",
]

[[package]]
name = "organize-std"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "deadpool",
 "dirs",
 "dyn-clone",
 "dyn-eq",
 "futures",
 "inventory",
 "libc",
 "num_cpus",
 "organize-sdk",
 "path-clean",
 "rand 0.9.1",
 "russh",
 "russh-sftp",
 "serde",
 "tempfile",
 "tokio",
 "tokio-stream",
 "tracing",
 "typetag",
 "walkdir",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "p256"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9863ad85fa8f4460f9c48cb909d38a0d689dba1f6f6988a5e3e0d31071bcd4b"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "sha2",
]

[[package]]
name = "p384"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe42f1670a52a47d448f14b6a5c61dd78fce51856e68edaa38f7ae3a46b8d6b6"
dependencies = [
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "sha2",
]

[[package]]
name = "p521"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fc9e2161f1f215afdfce23677034ae137bbd45016a880c2eb3ba8eb95f085b2"
dependencies = [
 "base16ct",
 "ecdsa",
 "elliptic-curve",
 "primeorder",
 "rand_core 0.6.4",
 "sha2",
]

[[package]]
name = "pageant"
version = "0.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdd27df01428302f915ea74737fe88170dd1bab4cbd00ff9548ca85618fcd4e4"
dependencies = [
 "bytes",
 "delegate",
 "futures",
 "log",
 "rand 0.8.5",
 "thiserror 1.0.69",
 "tokio",
 "windows 0.58.0",
]

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "password-hash"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "346f04948ba92c43e8469c1ee6736c7563d71012b17d40745260fe106aac2166"
dependencies = [
 "base64ct",
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "path-clean"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17359afc20d7ab31fdb42bb844c8b3bb1dabd7dcf7e68428492da7f16966fcef"

[[package]]
name = "pbkdf2"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8ed6a7761f76e3b9f92dfb0a60a6a6477c61024b775147ff0973a02653abaf2"
dependencies = [
 "digest",
 "hmac",
]

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1db05f56d34358a8b1066f67cbb203ee3e7ed2ba674a6263a1d5ec6db2204323"
dependencies = [
 "memchr",
 "thiserror 2.0.12",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb056d9e8ea77922845ec74a1c4e8fb17e7c218cc4fc11a15c5d25e189aa40bc"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e404e638f781eb3202dc82db6760c8ae8a1eeef7fb3fa8264b2ef280504966"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edd1101f170f5903fde0914f899bb503d9ff5271d7ba76bbb70bea63690cc0d5"
dependencies = [
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs5"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e847e2c91a18bfa887dd028ec33f2fe6f25db77db3619024764914affe8b69a6"
dependencies = [
 "aes",
 "cbc",
 "der",
 "pbkdf2",
 "scrypt",
 "sha2",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "pkcs5",
 "rand_core 0.6.4",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "poly1305"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8159bd90725d2df49889a078b54f4f79e87f1f8a8444194cdca81d38f5393abf"
dependencies = [
 "cpufeatures",
 "opaque-debug",
 "universal-hash",
]

[[package]]
name = "polyval"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d1fe60d06143b2430aa532c94cfe9e29783047f06c0d7fd359a9a51b729fa25"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "opaque-debug",
 "universal-hash",
]

[[package]]
name = "portable-atomic"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "prettyplease"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6837b9e10d61f45f987d50808f83d1ee3d206c66acf650c3e4ae2e1f6ddedf55"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "primeorder"
version = "0.13.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "353e1ca18966c16d9deb1c69278edbc5f194139612772bd9537af60ac231e1e6"
dependencies = [
 "elliptic-curve",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fbfd9d094a40bf3ae768db9361049ace4c0e04a4fd6b359518bd7b73a73dd97"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "redox_syscall"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d04b7d0ee6b4a0207a0a7adb104d23ecb0b47d6beae7152d0fa34b692b29fd6"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 1.0.69",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rfc6979"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8dd2a808d456c4a54e300a23e9f5a67e122c3024119acbfd73e3bf664491cb2"
dependencies = [
 "hmac",
 "subtle",
]

[[package]]
name = "rsa"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78928ac1ed176a5ca1d17e578a1825f3d81ca54cf41053a592584b020cfd691b"
dependencies = [
 "const-oid",
 "digest",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core 0.6.4",
 "sha2",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "russh"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b71d6d784c75ab19c421b7c3df21b100c9643f8b2563ae345a495ee792e85e4"
dependencies = [
 "aes",
 "aws-lc-rs",
 "base64ct",
 "bitflags 2.9.1",
 "block-padding",
 "byteorder",
 "bytes",
 "cbc",
 "ctr",
 "curve25519-dalek",
 "data-encoding",
 "delegate",
 "der",
 "digest",
 "ecdsa",
 "ed25519-dalek",
 "elliptic-curve",
 "enum_dispatch",
 "flate2",
 "futures",
 "generic-array",
 "getrandom 0.2.16",
 "hex-literal",
 "hmac",
 "home",
 "inout",
 "internal-russh-forked-ssh-key",
 "log",
 "md5",
 "num-bigint",
 "once_cell",
 "p256",
 "p384",
 "p521",
 "pageant",
 "pbkdf2",
 "pkcs1",
 "pkcs5",
 "pkcs8",
 "rand 0.8.5",
 "rand_core 0.6.4",
 "rsa",
 "russh-cryptovec",
 "russh-util",
 "sec1",
 "sha1",
 "sha2",
 "signature",
 "spki",
 "ssh-encoding",
 "subtle",
 "thiserror 1.0.69",
 "tokio",
 "typenum",
 "zeroize",
]

[[package]]
name = "russh-cryptovec"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fb0ed583ff0f6b4aa44c7867dd7108df01b30571ee9423e250b4cc939f8c6cf"
dependencies = [
 "libc",
 "log",
 "nix",
 "ssh-encoding",
 "winapi",
]

[[package]]
name = "russh-sftp"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3bb94393cafad0530145b8f626d8687f1ee1dedb93d7ba7740d6ae81868b13b5"
dependencies = [
 "bitflags 2.9.1",
 "bytes",
 "chrono",
 "flurry",
 "log",
 "serde",
 "thiserror 2.0.12",
 "tokio",
 "tokio-util",
]

[[package]]
name = "russh-util"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "668424a5dde0bcb45b55ba7de8476b93831b4aa2fa6947e145f3b053e22c60b6"
dependencies = [
 "chrono",
 "tokio",
 "wasm-bindgen",
 "wasm-bindgen-futures",
]

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys 0.4.15",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustix"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys 0.9.4",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "salsa20"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97a22f5af31f73a954c10289c93e8a50cc23d971e80ee446f1f6f7137a088213"
dependencies = [
 "cipher",
]

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "scrypt"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0516a385866c09368f0b5bcd1caff3366aace790fcd46e2bb032697bb172fd1f"
dependencies = [
 "pbkdf2",
 "salsa20",
 "sha2",
]

[[package]]
name = "sec1"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3e97a565f76233a6003f9f5c54be1d9c5bdfa3eccfb189469f11ec4901c47dc"
dependencies = [
 "base16ct",
 "der",
 "generic-array",
 "pkcs8",
 "subtle",
 "zeroize",
]

[[package]]
name = "seize"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "689224d06523904ebcc9b482c6a3f4f7fb396096645c4cd10c0d2ff7371a34d3"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.140"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shell-words"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
dependencies = [
 "serde",
]

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "sqlx"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fefb893899429669dcdd979aff487bd78f4064e5e7907e4269081e0ef7d97dc"
dependencies = [
 "sqlx-core",
 "sqlx-macros",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
]

[[package]]
name = "sqlx-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6798b1838b6a0f69c007c133b8df5866302197e404e8b6ee8ed3e3a5e68dc6"
dependencies = [
 "base64",
 "bytes",
 "chrono",
 "crc",
 "crossbeam-queue",
 "either",
 "event-listener",
 "futures-core",
 "futures-intrusive",
 "futures-io",
 "futures-util",
 "hashbrown 0.15.4",
 "hashlink",
 "indexmap",
 "log",
 "memchr",
 "once_cell",
 "percent-encoding",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "thiserror 2.0.12",
 "tokio",
 "tokio-stream",
 "tracing",
 "url",
]

[[package]]
name = "sqlx-macros"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2d452988ccaacfbf5e0bdbc348fb91d7c8af5bee192173ac3636b5fb6e6715d"
dependencies = [
 "proc-macro2",
 "quote",
 "sqlx-core",
 "sqlx-macros-core",
 "syn",
]

[[package]]
name = "sqlx-macros-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19a9c1841124ac5a61741f96e1d9e2ec77424bf323962dd894bdb93f37d5219b"
dependencies = [
 "dotenvy",
 "either",
 "heck",
 "hex",
 "once_cell",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "sha2",
 "sqlx-core",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
 "syn",
 "tokio",
 "url",
]

[[package]]
name = "sqlx-mysql"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa003f0038df784eb8fecbbac13affe3da23b45194bd57dba231c8f48199c526"
dependencies = [
 "atoi",
 "base64",
 "bitflags 2.9.1",
 "byteorder",
 "bytes",
 "chrono",
 "crc",
 "digest",
 "dotenvy",
 "either",
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-util",
 "generic-array",
 "hex",
 "hkdf",
 "hmac",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "percent-encoding",
 "rand 0.8.5",
 "rsa",
 "serde",
 "sha1",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-postgres"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db58fcd5a53cf07c184b154801ff91347e4c30d17a3562a635ff028ad5deda46"
dependencies = [
 "atoi",
 "base64",
 "bitflags 2.9.1",
 "byteorder",
 "chrono",
 "crc",
 "dotenvy",
 "etcetera",
 "futures-channel",
 "futures-core",
 "futures-util",
 "hex",
 "hkdf",
 "hmac",
 "home",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "rand 0.8.5",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-sqlite"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2d12fe70b2c1b4401038055f90f151b78208de1f9f89a7dbfd41587a10c3eea"
dependencies = [
 "atoi",
 "chrono",
 "flume",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-intrusive",
 "futures-util",
 "libsqlite3-sys",
 "log",
 "percent-encoding",
 "serde",
 "serde_urlencoded",
 "sqlx-core",
 "thiserror 2.0.12",
 "tracing",
 "url",
]

[[package]]
name = "ssh-cipher"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caac132742f0d33c3af65bfcde7f6aa8f62f0e991d80db99149eb9d44708784f"
dependencies = [
 "aes",
 "aes-gcm",
 "cbc",
 "chacha20",
 "cipher",
 "ctr",
 "poly1305",
 "ssh-encoding",
 "subtle",
]

[[package]]
name = "ssh-encoding"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb9242b9ef4108a78e8cd1a2c98e193ef372437f8c22be363075233321dd4a15"
dependencies = [
 "base64ct",
 "bytes",
 "pem-rfc7468",
 "sha2",
]

[[package]]
name = "ssh2"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f84d13b3b8a0d4e91a2629911e951db1bb8671512f5c09d7d4ba34500ba68c8"
dependencies = [
 "bitflags 2.9.1",
 "libc",
 "libssh2-sys",
 "parking_lot",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "stringprep"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4df3d392d81bd458a8a621b8bffbd2302a12ffe288a9d931670948749463b1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
 "unicode-properties",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4307e30089d6fd6aff212f2da3a1f9e32f3223b1f010fb09b7c95f90f3ca1e8"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tagptr"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b2093cf4c8eb1e67749a6762251bc9cd836b6fc171623bd0a9d324d37af2417"

[[package]]
name = "tempfile"
version = "3.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix 1.0.7",
 "windows-sys 0.59.0",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl 2.0.12",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1140bb80481756a8cbe10541f37433b459c5aa1e727b4c020fbfebdc25bf3ec4"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "slab",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-stream"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_write",
 "winnow",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-appender"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3566e8ce28cc0a3fe42519fc80e6b4c943cc4c8cef275620eb8dac2d3d4e06cf"
dependencies = [
 "crossbeam-channel",
 "thiserror 1.0.69",
 "time",
 "tracing-subscriber",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "typetag"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73f22b40dd7bfe8c14230cf9702081366421890435b2d625fa92b4acc4c3de6f"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35f5380909ffc31b4de4f4bdf96b877175a016aa2ca98cee39fcfd8c4d53d952"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicase"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"

[[package]]
name = "unicode-bidi"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-normalization"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-properties"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e70f2a8b45122e719eb623c01822704c4e0907e7e426a05927e1a1cfff5b75d0"

[[package]]
name = "unicode-width"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"

[[package]]
name = "universal-hash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
dependencies = [
 "crypto-common",
 "subtle",
]

[[package]]
name = "untrusted"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix 0.38.44",
]

[[package]]
name = "whoami"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6994d13118ab492c3c80c1f81928718159254c53c472bf9ce36f8dae4add02a7"
dependencies = [
 "redox_syscall",
 "wasite",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core 0.58.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core 0.61.2",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core 0.61.2",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement 0.58.0",
 "windows-interface 0.58.0",
 "windows-result 0.2.0",
 "windows-strings 0.1.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement 0.60.0",
 "windows-interface 0.59.1",
 "windows-link",
 "windows-result 0.3.4",
 "windows-strings 0.4.2",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core 0.61.2",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core 0.61.2",
 "windows-link",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result 0.2.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

```

`organizer/Cargo.toml`:

```toml
[workspace.package]
name = "organize"
version = "0.4.0-alpha"
authors = ["KBR9 <cabero96@gmail.com>"]
edition = "2018"
description = "file butler for the poweruser"
repository = "https://github.com/cbr9/organize"

[workspace]
resolver = "2"
members = [
  "organize-cli",
  "organize-sdk",
  "organize-std",
]

default-members = ["organize-cli"]

[workspace.dependencies]
anyhow = "1.0.98"
clap = { version = "4.5.40", features = ["derive"] }
dialoguer = "0.10.4"
dirs = "5.0.1"
dyn-clone = "1.0.19"
dyn-eq = "0.1.3"
serde = { version = "1.0.160", features = ["derive"] }
strum = { version = "0.26", features = ["derive"] }
typetag = "0.2.20"


```

`organizer/README.md`:

```md
TODO:
- [ ] implement custom variables
  - [x] regex based (using named capture groups)
  - [x] simple (string)
  - [ ] script 
- [x] integrate external templating library
- [x] file content filter
- [ ] download action; struct Download { to: PathBuf, url: String?, if_exists: ConflictOption, confirm: bool}
- [x] write action to write files based on some content
- [x] compressed file extraction action
- [x] refactor
- [x] refactor logger so all logs are put into one file. debug logs should not be written to stout unless a --verbose option is provided. each run should have its own log file in a folder named with the time the program was run
- [x] create a resource struct that represents a file and holds a context for that specific file, so operations can be parallelized without affecting the Tera context; get rid of global context. Take the list of rule variables in constructor
- [ ] look for configs at git repo root
- [ ] TESTS!!

---


# Planned Features
- A watch command
  - A corresponding file watcher synchronization service that keeps the known_files cache in sync with the fs
- Undo capabilities
- backups

```

`organizer/org.md`:

```md
Project Path: organizer

Source Tree:

```txt
organizer
├── Cargo.lock
├── Cargo.toml
├── README.md
├── organize-cli
│   ├── Cargo.toml
│   └── src
│       ├── cmd
│       │   ├── edit.rs
│       │   ├── logs.rs
│       │   ├── mod.rs
│       │   ├── run.rs
│       │   └── undo.rs
│       └── main.rs
├── organize-core
│   ├── Cargo.toml
│   ├── migrations
│   │   └── 20250623125855_initial_schema.sql
│   └── src
│       ├── action.rs
│       ├── batch.rs
│       ├── builtins
│       │   ├── actions
│       │   │   ├── echo.rs
│       │   │   └── mod.rs
│       │   ├── mod.rs
│       │   ├── selectors
│       │   │   ├── first.rs
│       │   │   └── mod.rs
│       │   ├── sorters
│       │   │   ├── mod.rs
│       │   │   └── random.rs
│       │   ├── storage
│       │   │   └── mod.rs
│       │   └── variables
│       │       ├── env.rs
│       │       ├── file.rs
│       │       └── mod.rs
│       ├── common
│       │   └── mod.rs
│       ├── config.rs
│       ├── context
│       │   ├── mod.rs
│       │   └── services
│       │       ├── fs
│       │       │   ├── locker.rs
│       │       │   ├── manager.rs
│       │       │   └── mod.rs
│       │       ├── history
│       │       │   ├── known_files.rs
│       │       │   ├── mod.rs
│       │       │   ├── sessions.rs
│       │       │   └── transactions.rs
│       │       └── mod.rs
│       ├── engine.rs
│       ├── errors.rs
│       ├── filter.rs
│       ├── folder.rs
│       ├── grouper.rs
│       ├── lib.rs
│       ├── options.rs
│       ├── parser
│       │   ├── ast.rs
│       │   ├── errors.rs
│       │   ├── lexer.rs
│       │   ├── mod.rs
│       │   └── parser.rs
│       ├── pipeline.rs
│       ├── resource.rs
│       ├── rule.rs
│       ├── selector.rs
│       ├── sorter.rs
│       ├── stdx
│       │   ├── mod.rs
│       │   └── path.rs
│       ├── storage.rs
│       ├── templates
│       │   ├── accessor.rs
│       │   ├── compiler.rs
│       │   ├── engine.rs
│       │   ├── filter.rs
│       │   ├── mod.rs
│       │   ├── registry.rs
│       │   ├── schema.rs
│       │   ├── template.rs
│       │   ├── value.rs
│       │   └── variable.rs
│       └── utils
│           ├── backup.rs
│           └── mod.rs
├── rules
│   └── test.rule.toml
└── rustfmt.toml

```

`organizer/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "ariadne"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f5e3dca4e09a6f340a61a0e9c7b61e030c69fc27bf29d73218f7e5e3b7638f"
dependencies = [
 "unicode-width 0.1.14",
 "yansi",
]

[[package]]
name = "arraydeque"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d902e3d592a523def97af8f317b08ce16b7ab854c1985a0c671e6f15cebc236"

[[package]]
name = "async-lock"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-trait"
version = "0.1.88"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "atoi"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
dependencies = [
 "num-traits",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "beef"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a8241f3ebb85c056b509d4327ad0358fbbba6ffb340bf388f26350aeda225b1"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
dependencies = [
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d487aa071b5f64da6f19a3e848e3578944b726ee5a4854b82172f02aa876bfdc"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "chumsky"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14377e276b2c8300513dff55ba4cc4142b44e5d6de6d00eb5b2307d650bb4ec1"
dependencies = [
 "hashbrown 0.15.4",
 "regex-automata 0.3.9",
 "serde",
 "stacker",
 "unicode-ident",
 "unicode-segmentation",
]

[[package]]
name = "clap"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c7947ae4cc3d851207c1adb5b5e260ff0cca11446b1d6d1423788e442257ce"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "colored"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fde0e0ec90c9dfb3b4b1a0891a7dcd0e2bffde2f7efed5fe7c9bb00e5bfb915e"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "config"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68578f196d2a33ff61b27fae256c3164f65e36382648e30666dde05b8cc9dfdf"
dependencies = [
 "async-trait",
 "convert_case",
 "json5",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust2",
]

[[package]]
name = "console"
version = "0.15.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
dependencies = [
 "encode_unicode",
 "libc",
 "once_cell",
 "unicode-width 0.2.1",
 "windows-sys 0.59.0",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom 0.2.16",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "convert_case"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec182b0ca2f35d8fc196cf3404988fd8b8c739a4d270ff118a398feb0cbec1ca"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "dashmap"
version = "6.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
]

[[package]]
name = "dialoguer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59c6f2989294b9a498d3ad5491a79c6deb604617378e1cdc4bfc1c1361fe2f87"
dependencies = [
 "console",
 "shell-words",
 "tempfile",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "dlv-list"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442039f5147480ba31067cb00ada1adae6892028e40e45fc5de7b7df6dcc1b5f"
dependencies = [
 "const-random",
]

[[package]]
name = "dotenvy"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"

[[package]]
name = "dotenvy_macro"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb0235d912a8c749f4e0c9f18ca253b4c28cfefc1d2518096016d6e3230b6424"
dependencies = [
 "dotenvy",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "dyn-clone"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c7a8fb8a9fbf66c1f703fe16184d10ca0ee9d23be5b4436400408ba54a95005"

[[package]]
name = "dyn-eq"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c2d035d21af5cde1a6f5c7b444a5bf963520a9f142e5d06931178433d7d5388"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
dependencies = [
 "serde",
]

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e004d887f51fcb9fef17317a2f3525c887d8aa3f4f50fed920816a688284a5b7"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "etcetera"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "136d1b5283a1ab77bd9257427ffd09d8667ced0570b6f938942bc7568ed5b943"
dependencies = [
 "cfg-if",
 "home",
 "windows-sys 0.48.0",
]

[[package]]
name = "event-listener"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "filetime"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
dependencies = [
 "cfg-if",
 "libc",
 "libredox",
 "windows-sys 0.59.0",
]

[[package]]
name = "flume"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da0e4dd2a88388a1f4ccc7c9ce104604dab68d9f408dc34cd45823d5a9069095"
dependencies = [
 "futures-core",
 "futures-sink",
 "spin",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fsevent-sys"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2"
dependencies = [
 "libc",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-intrusive"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d930c203dd0b6ff06e0201a4a2fe9149b43c684fd4420555b26d21b1a02956f"
dependencies = [
 "futures-core",
 "lock_api",
 "parking_lot",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generator"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d18470a76cb7f8ff746cf1f7470914f900252ec36bbc40b569d74b1258446827"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "log",
 "rustversion",
 "windows",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "hashlink"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8094feaf31ff591f651a2664fb9cfd92bba7a60ce3197265e9482ebe753c8f7"
dependencies = [
 "hashbrown 0.14.5",
]

[[package]]
name = "hashlink"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7382cf6263419f2d8df38c55d7da83da5c18aef87fc7a7fc1fb1e344edfe14c1"
dependencies = [
 "hashbrown 0.15.4",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hkdf"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5f8eb2ad728638ea2c7d47a21db23b7b58a72ed6a38256b8a1849f15fbbdf7"
dependencies = [
 "hmac",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown 0.15.4",
]

[[package]]
name = "inotify"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
dependencies = [
 "bitflags 2.9.1",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "inventory"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab08d7cd2c5897f2c949e5383ea7c7db03fb19130ffcfbf7eda795137ae3cb83"
dependencies = [
 "rustversion",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "kqueue"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac30106d7dce88daf4a3fcb4879ea939476d5074a9b7ddd0fb97fa4bed5596a"
dependencies = [
 "kqueue-sys",
 "libc",
]

[[package]]
name = "kqueue-sys"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed9625ffda8729b85e45cf04090035ac368927b8cebc34898e7c120f52e4838b"
dependencies = [
 "bitflags 1.3.2",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1580801010e535496706ba011c15f8532df6b42297d2e471fec38ceadd8c0638"
dependencies = [
 "bitflags 2.9.1",
 "libc",
 "redox_syscall",
]

[[package]]
name = "libsqlite3-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "logos"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab6f536c1af4c7cc81edf73da1f8029896e7e1e16a219ef09b184e76a296f3db"
dependencies = [
 "logos-derive",
]

[[package]]
name = "logos-codegen"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "189bbfd0b61330abea797e5e9276408f2edbe4f822d7ad08685d67419aafb34e"
dependencies = [
 "beef",
 "fnv",
 "lazy_static",
 "proc-macro2",
 "quote",
 "regex-syntax 0.8.5",
 "rustc_version",
 "syn 2.0.103",
]

[[package]]
name = "logos-derive"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebfe8e1a19049ddbfccbd14ac834b215e11b85b90bab0c2dba7c7b92fb5d5cba"
dependencies = [
 "logos-codegen",
]

[[package]]
name = "loom"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "419e0dc8046cb947daa77eb95ae174acfbddb7673b4151f56d1eed8e93fbfaca"
dependencies = [
 "cfg-if",
 "generator",
 "scoped-tls",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess"
version = "2.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "log",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "moka"
version = "0.12.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9321642ca94a4282428e6ea4af8cc2ca4eac48ac7a6a4ea8f33f76d0ce70926"
dependencies = [
 "async-lock",
 "crossbeam-channel",
 "crossbeam-epoch",
 "crossbeam-utils",
 "event-listener",
 "futures-util",
 "loom",
 "parking_lot",
 "portable-atomic",
 "rustc_version",
 "smallvec",
 "tagptr",
 "thiserror 1.0.69",
 "uuid",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "notify"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fee8403b3d66ac7b26aee6e40a897d85dc5ce26f44da36b8b73e987cc52e943"
dependencies = [
 "bitflags 2.9.1",
 "filetime",
 "fsevent-sys",
 "inotify",
 "kqueue",
 "libc",
 "log",
 "mio",
 "notify-types",
 "walkdir",
 "windows-sys 0.59.0",
]

[[package]]
name = "notify-types"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e0826a989adedc2a244799e823aece04662b66609d96af8dff7ac6df9a8925d"

[[package]]
name = "ntapi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a3895c6391c39d7fe7ebc444a87eb2991b2a0bc718fdabd071eec617fc68e4"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand 0.8.5",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "objc2-core-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "objc2-io-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71c1c64d6120e51cd86033f67176b1cb66780c2efe34dec55176f77befd93c0a"
dependencies = [
 "libc",
 "objc2-core-foundation",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "ordered-multimap"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49203cdcae0030493bad186b28da2fa25645fa276a51b6fec8010d281e02ef79"
dependencies = [
 "dlv-list",
 "hashbrown 0.14.5",
]

[[package]]
name = "organize-cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "chrono",
 "clap",
 "colored",
 "dialoguer",
 "lazy_static",
 "notify",
 "organize-core",
 "tokio",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
]

[[package]]
name = "organize-core"
version = "0.4.0-alpha"
dependencies = [
 "anyhow",
 "ariadne",
 "async-trait",
 "chumsky",
 "clap",
 "config",
 "dashmap",
 "dialoguer",
 "dirs",
 "dotenvy",
 "dotenvy_macro",
 "dyn-clone",
 "dyn-eq",
 "futures",
 "inventory",
 "itertools",
 "libc",
 "logos",
 "mime_guess",
 "moka",
 "notify",
 "path-clean",
 "rand 0.9.1",
 "serde",
 "serde_json",
 "serde_yaml",
 "sha2",
 "sqlx",
 "strum",
 "sysinfo",
 "tempfile",
 "thiserror 2.0.12",
 "tokio",
 "toml",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
 "typetag",
 "url",
 "uuid",
 "walkdir",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "path-clean"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17359afc20d7ab31fdb42bb844c8b3bb1dabd7dcf7e68428492da7f16966fcef"

[[package]]
name = "pathdiff"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1db05f56d34358a8b1066f67cbb203ee3e7ed2ba674a6263a1d5ec6db2204323"
dependencies = [
 "memchr",
 "thiserror 2.0.12",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb056d9e8ea77922845ec74a1c4e8fb17e7c218cc4fc11a15c5d25e189aa40bc"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e404e638f781eb3202dc82db6760c8ae8a1eeef7fb3fa8264b2ef280504966"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "pest_meta"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edd1101f170f5903fde0914f899bb503d9ff5271d7ba76bbb70bea63690cc0d5"
dependencies = [
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "portable-atomic"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "psm"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e944464ec8536cd1beb0bbfd96987eb5e3b72f2ecdafdc5c769a37f1fa2ae1f"
dependencies = [
 "cc",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fbfd9d094a40bf3ae768db9361049ace4c0e04a4fd6b359518bd7b73a73dd97"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "redox_syscall"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d04b7d0ee6b4a0207a0a7adb104d23ecb0b47d6beae7152d0fa34b692b29fd6"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 1.0.69",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59b23e92ee4318893fa3fe3e6fb365258efbfe6ac6ab30f090cdcbb7aa37efa9"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.7.5",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "ron"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
dependencies = [
 "base64 0.21.7",
 "bitflags 2.9.1",
 "serde",
 "serde_derive",
]

[[package]]
name = "rsa"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78928ac1ed176a5ca1d17e578a1825f3d81ca54cf41053a592584b020cfd691b"
dependencies = [
 "const-oid",
 "digest",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core 0.6.4",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rust-ini"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e0698206bcb8882bf2a9ecb4c1e7785db57ff052297085a6efd4fe42302068a"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "serde_json"
version = "1.0.140"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shell-words"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
dependencies = [
 "serde",
]

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "sqlx"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fefb893899429669dcdd979aff487bd78f4064e5e7907e4269081e0ef7d97dc"
dependencies = [
 "sqlx-core",
 "sqlx-macros",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
]

[[package]]
name = "sqlx-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6798b1838b6a0f69c007c133b8df5866302197e404e8b6ee8ed3e3a5e68dc6"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "chrono",
 "crc",
 "crossbeam-queue",
 "either",
 "event-listener",
 "futures-core",
 "futures-intrusive",
 "futures-io",
 "futures-util",
 "hashbrown 0.15.4",
 "hashlink 0.10.0",
 "indexmap",
 "log",
 "memchr",
 "once_cell",
 "percent-encoding",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "thiserror 2.0.12",
 "tokio",
 "tokio-stream",
 "tracing",
 "url",
]

[[package]]
name = "sqlx-macros"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2d452988ccaacfbf5e0bdbc348fb91d7c8af5bee192173ac3636b5fb6e6715d"
dependencies = [
 "proc-macro2",
 "quote",
 "sqlx-core",
 "sqlx-macros-core",
 "syn 2.0.103",
]

[[package]]
name = "sqlx-macros-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19a9c1841124ac5a61741f96e1d9e2ec77424bf323962dd894bdb93f37d5219b"
dependencies = [
 "dotenvy",
 "either",
 "heck",
 "hex",
 "once_cell",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "sha2",
 "sqlx-core",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
 "syn 2.0.103",
 "tokio",
 "url",
]

[[package]]
name = "sqlx-mysql"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa003f0038df784eb8fecbbac13affe3da23b45194bd57dba231c8f48199c526"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "bytes",
 "chrono",
 "crc",
 "digest",
 "dotenvy",
 "either",
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-util",
 "generic-array",
 "hex",
 "hkdf",
 "hmac",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "percent-encoding",
 "rand 0.8.5",
 "rsa",
 "serde",
 "sha1",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-postgres"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db58fcd5a53cf07c184b154801ff91347e4c30d17a3562a635ff028ad5deda46"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "chrono",
 "crc",
 "dotenvy",
 "etcetera",
 "futures-channel",
 "futures-core",
 "futures-util",
 "hex",
 "hkdf",
 "hmac",
 "home",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "rand 0.8.5",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-sqlite"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2d12fe70b2c1b4401038055f90f151b78208de1f9f89a7dbfd41587a10c3eea"
dependencies = [
 "atoi",
 "chrono",
 "flume",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-intrusive",
 "futures-util",
 "libsqlite3-sys",
 "log",
 "percent-encoding",
 "serde",
 "serde_urlencoded",
 "sqlx-core",
 "thiserror 2.0.12",
 "tracing",
 "url",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "stacker"
version = "0.1.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cddb07e32ddb770749da91081d8d0ac3a16f1a569a18b20348cd371f5dead06b"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "psm",
 "windows-sys 0.59.0",
]

[[package]]
name = "stringprep"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4df3d392d81bd458a8a621b8bffbd2302a12ffe288a9d931670948749463b1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
 "unicode-properties",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.103",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4307e30089d6fd6aff212f2da3a1f9e32f3223b1f010fb09b7c95f90f3ca1e8"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "sysinfo"
version = "0.35.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c3ffa3e4ff2b324a57f7aeb3c349656c7b127c3c189520251a648102a92496e"
dependencies = [
 "libc",
 "memchr",
 "ntapi",
 "objc2-core-foundation",
 "objc2-io-kit",
 "windows",
]

[[package]]
name = "tagptr"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b2093cf4c8eb1e67749a6762251bc9cd836b6fc171623bd0a9d324d37af2417"

[[package]]
name = "tempfile"
version = "3.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl 2.0.12",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.45.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75ef51a33ef1da925cea3e4eb122833cb377c61439ca401b770f54902b806779"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tokio-stream"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_write",
 "winnow",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-appender"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3566e8ce28cc0a3fe42519fc80e6b4c943cc4c8cef275620eb8dac2d3d4e06cf"
dependencies = [
 "crossbeam-channel",
 "thiserror 1.0.69",
 "time",
 "tracing-subscriber",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "typetag"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73f22b40dd7bfe8c14230cf9702081366421890435b2d625fa92b4acc4c3de6f"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35f5380909ffc31b4de4f4bdf96b877175a016aa2ca98cee39fcfd8c4d53d952"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicase"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"

[[package]]
name = "unicode-bidi"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-normalization"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-properties"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e70f2a8b45122e719eb623c01822704c4e0907e7e426a05927e1a1cfff5b75d0"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-width"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "whoami"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6994d13118ab492c3c80c1f81928718159254c53c472bf9ce36f8dae4add02a7"
dependencies = [
 "redox_syscall",
 "wasite",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core",
 "windows-link",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yaml-rust2"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8902160c4e6f2fb145dbe9d6760a75e3c9522d8bf796ed7047c85919ac7115f8"
dependencies = [
 "arraydeque",
 "encoding_rs",
 "hashlink 0.8.4",
]

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

```

`organizer/Cargo.toml`:

```toml
[workspace.package]
name = "organize"
version = "0.4.0-alpha"
authors = ["KBR9 <cabero96@gmail.com>"]
edition = "2018"
description = "file butler for the poweruser"
repository = "https://github.com/cbr9/organize"

[workspace]
resolver = "2"
members = [
  "organize-cli",
  "organize-core" ,
]

default-members = ["organize-cli"]

[workspace.dependencies]
anyhow = "1.0.98"
clap = { version = "4.5.40", features = ["derive"] }
config = "0.14.0"
dialoguer = "0.10.4"
dirs = "5.0.1"
dyn-clone = "1.0.19"
dyn-eq = "0.1.3"
itertools = "0.10.5"
path-clean = "1.0.1"
serde = { version = "1.0.160", features = ["derive"] }
strum = { version = "0.26", features = ["derive"] }
typetag = "0.2.20"




```

`organizer/README.md`:

```md
TODO:
- [ ] implement custom variables
  - [x] regex based (using named capture groups)
  - [x] simple (string)
  - [ ] script 
- [x] integrate external templating library
- [x] file content filter
- [ ] download action; struct Download { to: PathBuf, url: String?, if_exists: ConflictOption, confirm: bool}
- [x] write action to write files based on some content
- [x] compressed file extraction action
- [x] refactor
- [x] refactor logger so all logs are put into one file. debug logs should not be written to stout unless a --verbose option is provided. each run should have its own log file in a folder named with the time the program was run
- [x] create a resource struct that represents a file and holds a context for that specific file, so operations can be parallelized without affecting the Tera context; get rid of global context. Take the list of rule variables in constructor
- [ ] look for configs at git repo root
- [ ] TESTS!!

---


# Planned Features
- A watch command
  - A corresponding file watcher synchronization service that keeps the known_files cache in sync with the fs
- Undo capabilities
- backups

```

`organizer/organize-cli\Cargo.toml`:

```toml
[package]
name = "organize-cli"
version = "0.1.0"
edition = "2024"

[[bin]]
name = "organize"
path = "src/main.rs"

[dependencies]
async-trait = "0.1.88"
tokio = { version = "1.45.1", features = ["full"] }
organize-core = { path = "../organize-core" }
lazy_static = "1.5.0"
chrono = "0.4.41"
anyhow.workspace = true
clap.workspace = true
colored = "3.0.0"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = "0.3.19"
dialoguer.workspace = true
notify = "8.0.0"


```

`organizer/organize-cli\src\cmd\edit.rs`:

```rs
use std::{
	env,
	path::Path,
	process::{self, ExitStatus},
};

use anyhow::{Context, Result};
use async_trait::async_trait;
use clap::Parser;
use organize_core::config::Config;

use crate::cmd::Cmd;

#[derive(Parser, Debug)]
pub struct Edit;

#[async_trait]
impl Cmd for Edit {
	async fn run(self) -> Result<()> {
		Self::edit(Config::resolve_path(None)).map(|_| ())
	}
}

impl Edit {
	pub(crate) fn edit<T: AsRef<Path>>(path: T) -> Result<ExitStatus> {
		env::var("EDITOR").map(|editor| {
			process::Command::new(&editor)
				.arg(path.as_ref())
				.spawn()
				.context(editor)?
				.wait()
				.context("command wasn't running")
		})?
	}
}

```

`organizer/organize-cli\src\cmd\logs.rs`:

```rs
use chrono::Local;
use clap::ValueEnum;
use std::path::PathBuf;
use tracing::Level;
use tracing_appender::non_blocking::WorkerGuard; // Import the guard type
use tracing_subscriber::{
	Layer,
	filter::LevelFilter,
	fmt::{self},
	layer::SubscriberExt,
	util::SubscriberInitExt,
};

#[derive(ValueEnum, Clone, Debug, Default)]
pub enum LogLevel {
	#[default]
	Info,
	Debug,
	Trace,
	Warn,
	Error,
}

// Implement a conversion from our CLI enum to the `tracing` LevelFilter.
impl From<LogLevel> for Level {
	fn from(level: LogLevel) -> Self {
		match level {
			LogLevel::Info => Level::INFO,
			LogLevel::Debug => Level::DEBUG,
			LogLevel::Trace => Level::TRACE,
			LogLevel::Warn => Level::WARN,
			LogLevel::Error => Level::ERROR,
		}
	}
}

/// Initializes the logging system and returns a guard that must be kept in scope.
pub fn init(level: LogLevel) -> WorkerGuard {
	// 1. Determine the destination directory for logs.
	let logs_dir = PathBuf::from(".").join("logs"); // A hidden folder is a common convention

	// 2. Create a non-blocking file appender for the current run.
	// We add milliseconds to the timestamp to increase uniqueness.
	let timestamp = Local::now().format("%Y-%m-%d-%H-%M-%S%.3f");
	let log_file = format!("{timestamp}.log");
	let file_appender = tracing_appender::rolling::never(&logs_dir, log_file);
	let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);

	// 3. Define the two logging layers.
	let file_layer = fmt::layer()
		.with_writer(non_blocking_writer)
		.with_ansi(false)
		.pretty()
		.with_filter(LevelFilter::TRACE);

	let stdout_layer = fmt::layer()
		.with_writer(std::io::stdout)
		.with_filter(LevelFilter::from_level(level.into()));

	// 4. Combine the layers and initialize the global subscriber.
	tracing_subscriber::registry().with(file_layer).with(stdout_layer).init();

	tracing::debug!("Logging initialized. Log file in: {}", logs_dir.display());

	// 5. Return the guard to the caller.
	guard
}

```

`organizer/organize-cli\src\cmd\mod.rs`:

```rs
use crate::cmd::{logs::LogLevel, run::Run};
use async_trait::async_trait;
use clap::{Parser, Subcommand};
use undo::Undo;

mod logs;
mod run;
mod undo;

#[derive(Subcommand)]
enum Command {
	Run(Run),
	Undo(Undo),
}

#[derive(Parser)]
#[command(about, author, version)]
pub struct App {
	#[command(subcommand)]
	command: Command,
	#[arg(long, value_enum, global = true, default_value_t = LogLevel::Info)]
	pub log_level: LogLevel,
}

#[async_trait]
pub trait Cmd {
	async fn run(self) -> anyhow::Result<()>;
}

#[async_trait]
impl Cmd for App {
	async fn run(self) -> anyhow::Result<()> {
		let _guard = logs::init(self.log_level);
		match self.command {
			Command::Run(cmd) => cmd.run().await,
			Command::Undo(undo) => undo.run().await,
		}
	}
}

```

`organizer/organize-cli\src\cmd\run.rs`:

```rs
use std::path::PathBuf;

use anyhow::Result;
use async_trait::async_trait;
use clap::{Parser, ValueHint};
use organize_core::{context::RunSettings, engine::Engine};

use crate::Cmd;


#[derive(Parser, Default, Debug)]
pub struct Run {
	#[arg(long, short = 'r', value_hint = ValueHint::FilePath)]
	rule: PathBuf,
	#[arg(long, default_value_t = true, conflicts_with = "no_dry_run")]
	dry_run: bool,
	#[arg(long, conflicts_with = "dry_run")]
	no_dry_run: bool,
}

#[async_trait]
impl Cmd for Run {
	async fn run(mut self) -> Result<()> {
		if self.no_dry_run {
			self.dry_run = false;
		}
		let settings = RunSettings { dry_run: self.dry_run };
		let engine = Engine::new(&self.rule, settings).await?;
		engine.run().await?;

		Ok(())
	}
}

```

`organizer/organize-cli\src\cmd\undo.rs`:

```rs
use std::error::Error;

use anyhow::{Result, anyhow};
use async_trait::async_trait;
use clap::Parser;
use organize_core::{
	action::{Input, UndoConflict, UndoError, UndoSettings},
	context::{RunSettings, services::history::Journal},
};

use super::Cmd;

#[derive(Parser, Debug)]
#[command(author, version, about)]
pub struct Undo {
	/// The ID of the session to undo.
	#[arg(long, conflicts_with = "last_session")]
	session_id: Option<i64>,

	/// Use the most recent session.
	#[arg(long, default_value_t = true)]
	last_session: bool,

	// If there is a name collision conflict while undoing, ask me what to do
	#[arg(long, short = 'i', conflicts_with_all = &["on_conflict"])]
	interactive: bool,

	#[arg(long, value_enum, default_value_t = UndoConflict::Abort)]
	on_conflict: UndoConflict,
}

#[async_trait]
impl Cmd for Undo {
	async fn run(self) -> Result<()> {
		let settings = RunSettings { dry_run: false };
		let journal = Journal::new(&settings).await?; // Assumes a simple ::new()

		let settings = UndoSettings {
			interactive: self.interactive,
			on_conflict: self.on_conflict,
		};
		let target_id = if self.last_session {
			journal
				.get_last_session_id()
				.await?
				.ok_or_else(|| anyhow!("No sessions found in the journal."))?
		} else {
			self.session_id.unwrap()
		};

		let transactions = journal.get_pending_transactions_for_session(target_id).await?;

		if transactions.is_empty() {
			println!("No pending operations to undo for session {target_id}.");
			return Ok(());
		}

		for transaction in &transactions {
			for undo_op in &transaction.receipt.undo {
				if undo_op.verify().await.is_ok() {
					match undo_op.undo(&settings).await {
						Ok(_) => {
							journal.update_transaction_undo_status(transaction.id, "DONE").await?;
							tracing::info!("Transaction {} undone.", transaction.id);
						}
						Err(e) => {
							if let Some(source) = e.source().and_then(|s| s.downcast_ref::<UndoError>())
								&& matches!(source, UndoError::Abort)
							{
								let inputs = transaction
									.receipt
									.inputs
									.iter()
									.map(|input: &Input| match input {
										Input::Processed(resource) => resource.as_path().to_string_lossy().to_string(),
										Input::Skipped(resource) => resource.as_path().to_string_lossy().to_string(),
									})
									.collect::<Vec<String>>()
									.join("\n -");

								eprintln!(
									"There was a conflict undoing transaction {}.\nOne of the following files may already exist: \n - {}\nAborting \
									 undo process. Run in interactive mode or choose a default conflict resolution strategy. You can also move the \
									 file manually.",
									transaction.id, inputs
								);
								return Ok(());
							}

							eprintln!("Failed to undo transaction {}: {}", transaction.id, e);
							return Err(e.into());
						}
					}
				}
			}
		}

		Ok(())
	}
}

```

`organizer/organize-cli\src\main.rs`:

```rs
use crate::cmd::{App, Cmd};
use anyhow::Result;
use clap::Parser;
mod cmd;

#[tokio::main]
async fn main() -> Result<()> {
	let app: App = App::parse();
	app.run().await
}

```

`organizer/organize-core\Cargo.toml`:

```toml
[package]
name = "organize-core"
version.workspace = true
authors.workspace = true
edition.workspace = true
description.workspace = true
repository.workspace = true

[dependencies]
ariadne = "0.5.1"
chumsky = "0.10.1"
logos = "0.15.0"
anyhow.workspace = true
async-trait = "0.1.88"
clap.workspace = true
config.workspace = true
dashmap = "6.1.0"
dialoguer.workspace = true
dirs.workspace = true
dotenvy = "0.15.7"
dyn-clone.workspace = true
dyn-eq.workspace = true
itertools.workspace = true
moka = { version = "0.12.10", features = ["future"] }
path-clean.workspace = true
serde.workspace = true
serde_json = "1.0.140"
serde_yaml = "0.9.34"
sqlx = { version = "0.8.6", features = ["chrono", "runtime-tokio", "sqlite"] }
strum.workspace = true
thiserror = "2.0.12"
typetag.workspace = true
dotenvy_macro = "0.15.7"
tokio = { version = "1.45.1", features = ["full"] }
libc = "0.2.174"
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
tracing-appender = "0.2.3"
futures = "0.3.31"
walkdir = "2.5.0"
tempfile = "3.20.0"
sha2 = "0.10.9"
uuid = "1.17.0"
mime_guess = "2.0.5"
sysinfo = "0.35.2"
notify = "8.0.0"
url = "2.5.4"
toml = "0.8.23"
inventory = "0.3.20"
rand = "0.9.1"

```

`organizer/organize-core\migrations\20250623125855_initial_schema.sql`:

```sql
CREATE TABLE IF NOT EXISTS sessions (
    id              INTEGER PRIMARY KEY,
    start_time      INTEGER NOT NULL,
    end_time        INTEGER,
    status          TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS transactions (
    id              INTEGER PRIMARY KEY,
    session_id      INTEGER NOT NULL,
    type               TEXT NOT NULL,
    action             TEXT NOT NULL,
    receipt            TEXT NOT NULL, 
    timestamp       INTEGER NOT NULL,
    undo_status TEXT NOT NULL DEFAULT "PENDING",
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);


```

`organizer/organize-core\src\action.rs`:

```rs
use async_trait::async_trait;
use clap::ValueEnum;
use dialoguer::{theme::ColorfulTheme, Input as RenameInput, Select};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ffi::OsStr, fmt::Debug, path::Path, sync::Arc};
use strum::{Display, EnumIter, IntoEnumIterator};

use anyhow::Result;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::path::PathBuf;
use thiserror::Error;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource, utils::backup::Backup};

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Input {
	Processed(Arc<Resource>),
	Skipped(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Output {
	Created(Arc<Resource>),
	Deleted(Arc<Resource>),
	Modified(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct Receipt {
	pub inputs: Vec<Input>,
	pub outputs: Vec<Output>,
	pub next: Vec<Arc<Resource>>,
	pub undo: Vec<Box<dyn Undo>>,
	pub metadata: HashMap<String, serde_json::Value>,
}

impl From<String> for Receipt {
	fn from(value: String) -> Self {
		serde_json::from_str(&value).expect("Could not convert string to Receipt object")
	}
}

dyn_clone::clone_trait_object!(Undo);
dyn_eq::eq_trait_object!(Undo);

#[derive(Debug, Error)]
pub enum UndoError {
	#[error("Path '{0}' does not exist, but is required for the undo operation.")]
	PathNotFound(PathBuf),

	#[error("Path '{0}' already exists. The undo operation would overwrite it.")]
	PathAlreadyExists(PathBuf),

	#[error("Backup file is missing for path '{0}'. Cannot restore.")]
	BackupMissing(PathBuf),

	#[error("Parent directory '{0}' for the restore path does not exist.")]
	ParentDirectoryNotFound(PathBuf),

	#[error("Any error")]
	Anyhow(#[from] anyhow::Error),

	#[error("IO error")]
	IO(#[from] std::io::Error),

	#[error("Undo aborted by the user")]
	Abort,
}

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Undo: Debug + DynEq + DynClone + Send + Sync {
	async fn undo(&self, settings: &UndoSettings) -> Result<(), Error>;

	fn backup(&self) -> Option<&Backup> {
		None
	}

	async fn verify(&self) -> Result<(), Error>;
}

pub struct UndoSettings {
	pub interactive: bool,
	pub on_conflict: UndoConflict,
}

#[derive(Clone, Debug, ValueEnum, EnumIter, Display)]
#[strum(serialize_all = "snake_case")]
pub enum UndoConflict {
	Skip,
	Abort,
	Overwrite,
	AutoRename,
	Rename,
}

async fn suggest_new_path(resource: Resource) -> Result<Resource> {
	let parent = resource.as_path().parent().unwrap_or_else(|| Path::new(""));
	let stem = resource.as_path().file_stem().unwrap_or_else(|| OsStr::new("file"));
	let extension = resource.as_path().extension().unwrap_or_else(|| OsStr::new(""));

	let mut count = 1;
	loop {
		// 2. Construct the new filename purely from strings and path components.
		let new_filename_str = format!("{} ({}).{}", stem.to_string_lossy(), count, extension.to_string_lossy());

		// 3. Create a new PathBuf to check for existence. This does not touch the original `resource`.
		let new_path = parent.join(&new_filename_str);

		if !tokio::fs::try_exists(&new_path).await? {
			// 4. Once a valid path is found, consume the original `resource` exactly once
			//    to create the final, evolved struct and return it. The loop is guaranteed to terminate here.
			return Ok(resource.with_path(new_path));
		}
		count += 1;
	}
}

impl UndoConflict {
	/// This new method encapsulates all the conflict handling logic.
	/// It takes a mutable reference to the destination to allow the Rename variant to change it.
	pub async fn resolve(resource: Resource) -> Result<Option<Resource>, UndoError> {
		let choices: Vec<Self> = Self::iter().collect();
		let strategy: &UndoConflict = Select::with_theme(&ColorfulTheme::default())
			.with_prompt(format!("Destination '{}' already exists.", resource.path.display()))
			.items(&choices)
			.interact()
			.map(|choice| &choices[choice])
			.expect("Unknown option");
		strategy.handle(resource).await
	}

	pub async fn handle(&self, resource: Resource) -> Result<Option<Resource>, UndoError> {
		match self {
			UndoConflict::Overwrite => {
				// The logic for overwriting the destination file.
				if resource.as_path().is_file() {
					tokio::fs::remove_file(resource.as_path()).await?;
				} else {
					tokio::fs::remove_dir_all(resource.as_path()).await?;
				}
				Ok(Some(resource))
			}
			UndoConflict::Rename => {
				// The logic for prompting the user and renaming the destination.
				let theme = ColorfulTheme::default();
				let input = RenameInput::<String>::with_theme(&theme)
					.with_prompt("Enter a new name for the destination")
					.with_initial_text(format!("{}", resource.as_path().file_name().unwrap_or_default().display()))
					.interact_text()
					.map(PathBuf::from)?;
				let new = resource.with_path(input);
				Ok(Some(new))
			}
			UndoConflict::Skip => Ok(None),
			UndoConflict::Abort => Err(UndoError::Abort),
			UndoConflict::AutoRename => Ok(Some(suggest_new_path(resource).await?)),
		}
	}
}

dyn_clone::clone_trait_object!(ActionBuilder);
dyn_eq::eq_trait_object!(ActionBuilder);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait ActionBuilder: DynEq + DynClone + Sync + Send + Debug {
	async fn build(&self, _ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error>;
}

dyn_clone::clone_trait_object!(Action);
dyn_eq::eq_trait_object!(Action);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Action: DynEq + DynClone + Sync + Send + Debug {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::default()
	}
	async fn commit(&self, _ctx: &ExecutionContext<'_>) -> Result<Receipt, Error>;
}

```

`organizer/organize-core\src\batch.rs`:

```rs
use std::{collections::HashMap, sync::Arc};

use crate::resource::Resource;

/// Represents a batch of files that have been grouped by one or more criteria.
/// This is the primary data structure that flows between pipeline stages.
#[derive(Debug, Clone)]
pub struct Batch {
	pub files: Vec<Arc<Resource>>,
	pub context: HashMap<String, String>,
}

impl Batch {
	pub fn new() -> Self {
		Self {
			files: Vec::new(),
			context: HashMap::new(),
		}
	}

	pub fn initial(files: Vec<Arc<Resource>>) -> Self {
		Self {
			files,
			context: HashMap::new(),
		}
	}
}

impl Default for Batch {
	fn default() -> Self {
		Self::new()
	}
}

```

`organizer/organize-core\src\builtins\actions\echo.rs`:

```rs
use crate::{
	action::{Action, ActionBuilder, Receipt},
	common::enabled,
	context::ExecutionContext,
	errors::Error,
	templates::template::{Template, TemplateString},
};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

use anyhow::Result;

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct EchoBuilder {
	pub message: TemplateString,
	#[serde(default = "enabled")]
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl ActionBuilder for EchoBuilder {
	async fn build(&self, ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error> {
		let message = ctx.services.compiler.compile_template(&self.message)?;
		Ok(Box::new(Echo {
			message,
			enabled: self.enabled,
		}))
	}
}

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct Echo {
	pub message: Template,
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl Action for Echo {
	async fn commit(&self, ctx: &ExecutionContext<'_>) -> Result<Receipt, Error> {
		if self.enabled {
			self.message
				.render(ctx)
				.await
				.inspect(|message| tracing::info!("{}", message))?;
		}
		Ok(Receipt {
			next: vec![ctx.scope.resource()?],
			..Default::default()
		})
	}
}

```

`organizer/organize-core\src\builtins\actions\mod.rs`:

```rs
pub mod echo;
// pub mod r#move;

```

`organizer/organize-core\src\builtins\mod.rs`:

```rs
pub mod actions;
pub mod selectors;
pub mod sorters;
pub mod storage;
pub mod variables;

```

`organizer/organize-core\src\builtins\selectors\first.rs`:

```rs
use crate::{
    batch::Batch,
    errors::Error,
    selector::Selector,
};
use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FirstSelector {
    pub n: usize,
}

#[async_trait]
#[typetag::serde(name = "first")]
impl Selector for FirstSelector {
    async fn select(&self, batch: &Batch) -> Result<Batch, Error> {
        let mut selected_batch = Batch::new();
        selected_batch.files = batch.files.iter().take(self.n).cloned().collect();
        // The context from the original batch is not preserved by default,
        // as it might not be relevant to the new, smaller batch.
        Ok(selected_batch)
    }
}

```

`organizer/organize-core\src\builtins\selectors\mod.rs`:

```rs
pub mod first;

```

`organizer/organize-core\src\builtins\sorters\mod.rs`:

```rs
pub mod random;

```

`organizer/organize-core\src\builtins\sorters\random.rs`:

```rs
use crate::{resource::Resource, sorter::Sorter};
use async_trait::async_trait;
use rand::{rng, seq::SliceRandom};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub struct RandomSorter;

#[async_trait]
#[typetag::serde(name = "random")]
impl Sorter for RandomSorter {
	async fn sort(&self, files: &mut [Arc<Resource>]) {
		let mut rng = rng();
		files.shuffle(&mut rng);
	}
}

```

`organizer/organize-core\src\builtins\variables\env.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

// This accessor is created dynamically. It stores the environment
// variable key that it needs to look up.
#[derive(Debug, Clone, PartialEq, Eq)]
struct EnvAccessor {
	key: String,
}

#[async_trait]
impl Accessor for EnvAccessor {
	async fn get(&self, _ctx: &ExecutionContext) -> Result<Value> {
		let value = std::env::var(&self.key).ok();
		Ok(Value::OptionString(value))
	}
}

/// The provider for the `{{ env }}` variable.
#[derive(Debug, Clone)]
pub struct EnvProvider;

impl StatelessVariable for EnvProvider {
	fn name(&self) -> &'static str {
		"env"
	}

	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			// This node indicates that `env` is a map with dynamic keys.
			node: SchemaNode::DynamicMap(Arc::new(|key: &str| {
				// The constructor captures the key from the property chain
				// (e.g., "HOME") and creates an EnvAccessor for it.
				Box::new(EnvAccessor { key: key.to_string() })
			})),
		}
	}
}

// Automatically register the `EnvProvider` with the global inventory.
static ENV_PROVIDER: EnvProvider = EnvProvider;
inventory::submit!(VariableInventory { provider: &ENV_PROVIDER });

```

`organizer/organize-core\src\builtins\variables\file.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FileProvider;

#[derive(Debug, Clone, PartialEq, Eq)]
struct Path;

#[async_trait]
impl Accessor for Path {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let path_str = resource.path.to_string_lossy().to_string();
		Ok(Value::String(path_str))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Name;

#[async_trait]
impl Accessor for Name {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_name().map(|name| name.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Stem;

#[async_trait]
impl Accessor for Stem {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_stem().map(|stem| stem.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Extension;

#[async_trait]
impl Accessor for Extension {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.extension().map(|ext| ext.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

// SCHEMA AND REGISTRATION

impl StatelessVariable for FileProvider {
	fn name(&self) -> &'static str {
		"file"
	}

	/// Defines the schema for the `file` variable.
	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			node: SchemaNode::Object(vec![
				Property {
					name: "path",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Path))),
				},
				Property {
					name: "name",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Name))),
				},
				Property {
					name: "stem",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Stem))),
				},
				Property {
					name: "extension",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Extension))),
				},
			]),
		}
	}
}

inventory::submit! {
	VariableInventory {
		provider: &FileProvider
	}
}

```

`organizer/organize-core\src\builtins\variables\mod.rs`:

```rs
pub mod env;
pub mod file;

```

`organizer/organize-core\src\common\mod.rs`:

```rs
pub fn enabled() -> bool {
	true
}

```

`organizer/organize-core\src\config.rs`:

```rs



// #[cfg(test)]
// mod tests {
// 	use std::sync::LazyLock;

// 	use super::ConfigBuilder;
// 	use itertools::Itertools;
// 	use toml::toml;

// 	static TOML: LazyLock<toml::Table> = LazyLock::new(|| {
// 		toml! {

// 				[[rules]]
// 				id = "test-rule-1"
// 				tags = ["tag1"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-2"
// 				tags = ["tag2"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-3"
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				actions = []
// 				filters = []
// 				folders = []

// 		}
// 	});

// 	static CONFIG: LazyLock<ConfigBuilder> = LazyLock::new(|| toml::from_str(&TOML.to_string()).unwrap());

// 	#[test]
// 	fn filter_rules_by_tag_positive() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["tag2"]).iter().map(|&r| r.clone()).collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_negative() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["!tag2"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap(), CONFIG.rules.get(3).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["!tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(2..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_positive() {
// 		let found_rules = CONFIG.filter_rules_by_id(["test-rule-1"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1"])
// 			.iter()
// 			.map(|r| (*r).clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=2).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "test-rule-2"])
// 			.iter()
// 			.map(|&r| r.clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(0..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// }

```

`organizer/organize-core\src\context\mod.rs`:

```rs
use anyhow::Result;
use dashmap::DashMap;
use std::{
	any::Any,
	path::{Path, PathBuf},
	sync::Arc,
};

pub mod services;

use crate::{
	batch::Batch,
	context::services::{fs::manager::FileSystemManager, history::Journal},
	errors::Error,
	folder::Location,
	resource::Resource,
	rule::RuleMetadata,
	templates::compiler::TemplateCompiler,
};

#[derive(Debug, Clone)]
pub struct RunServices {
	pub blackboard: Blackboard,
	pub fs: FileSystemManager,
	pub journal: Arc<Journal>,
	pub compiler: TemplateCompiler,
}

#[derive(Debug, Clone)]
pub struct Blackboard {
	pub scratchpad: Arc<DashMap<String, Box<dyn Any + Send + Sync>>>,
	pub shared_context: Arc<DashMap<String, String>>,
}

impl Default for Blackboard {
	fn default() -> Self {
		Self {
			scratchpad: Arc::new(DashMap::new()),
			shared_context: Arc::new(DashMap::new()),
		}
	}
}

/// A container for run-wide operational settings.
#[derive(Debug, Clone, Copy)]
pub struct RunSettings {
	pub dry_run: bool,
}

/// A read-only "view" into the current position in the configuration tree.
// #[derive(Debug, Clone)]
// pub struct ExecutionScope<'a> {
// 	pub config: &'a Config,
// 	pub rule: Option<&'a Rule>,
// 	pub folder: Option<&'a Folder>,
// 	pub resource: Option<Arc<Resource>>,
// 	pub resources: Option<Vec<Arc<Resource>>>,
// }

#[derive(Debug, Clone)]
pub enum ExecutionScope<'a> {
	Rule(RuleScope),
	Search(SearchScope<'a>),
	Resource(ResourceScope),
	Batch(BatchScope<'a>),
	Build(BuildScope),
	Blank,
}

impl<'a> ExecutionScope<'a> {
	pub fn new_rule_scope(rule: Arc<RuleMetadata>) -> ExecutionScope<'a> {
		ExecutionScope::Rule(RuleScope { rule })
	}

	pub fn new_location_scope(rule: Arc<RuleMetadata>, location: &'a Location) -> ExecutionScope<'a> {
		ExecutionScope::Search(SearchScope { rule, location })
	}

	pub fn new_resource_scope(rule: Arc<RuleMetadata>, resource: Arc<Resource>) -> ExecutionScope<'a> {
		ExecutionScope::Resource(ResourceScope { rule, resource })
	}

	pub fn new_batch_scope(rule: Arc<RuleMetadata>, batch: &'a Batch) -> ExecutionScope<'a> {
		ExecutionScope::Batch(BatchScope { rule, batch })
	}

	pub fn new_build_scope(root: &Path) -> ExecutionScope<'a> {
		ExecutionScope::Build(BuildScope { root: root.to_path_buf() })
	}

	pub fn rule(&self) -> Result<Arc<RuleMetadata>, Error> {
		match self {
			ExecutionScope::Rule(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Batch(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Search(scope) => Ok(scope.rule.clone()),
			_ => Err(Error::OutOfScope("rule".into())),
		}
	}

	pub fn resource(&self) -> Result<Arc<Resource>, Error> {
		match self {
			ExecutionScope::Resource(scope) => Ok(scope.resource.clone()),
			_ => Err(Error::OutOfScope("resource".into())),
		}
	}

	pub fn batch(&self) -> Result<&'a Batch, Error> {
		match self {
			ExecutionScope::Batch(scope) => Ok(scope.batch),
			_ => Err(Error::OutOfScope("batch".into())),
		}
	}

	pub fn root(&self) -> Result<PathBuf, Error> {
		match self {
			ExecutionScope::Search(scope) => Ok(scope.location.path.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.resource.location.path.clone()),
			ExecutionScope::Build(path) => Ok(path.root.clone()), // <-- ADD THIS CASE
			_ => Err(Error::OutOfScope("root".into())),
		}
	}
}

#[derive(Debug, Clone)]
pub struct RuleScope {
	pub rule: Arc<RuleMetadata>,
}
#[derive(Debug, Clone)]
pub struct SearchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub location: &'a Location,
}
#[derive(Debug, Clone)]
pub struct ResourceScope {
	pub rule: Arc<RuleMetadata>,
	pub resource: Arc<Resource>,
}
#[derive(Debug, Clone)]
pub struct BatchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub batch: &'a Batch,
}

#[derive(Debug, Clone)]
pub struct BuildScope {
	pub root: PathBuf,
}

/// The top-level context object, composed of the three distinct categories of information.
#[derive(Clone, Debug)]
pub struct ExecutionContext<'a> {
	pub services: &'a RunServices,
	pub scope: ExecutionScope<'a>,
	pub settings: &'a RunSettings,
}

impl<'a> ExecutionContext<'a> {
	pub fn with_scope(&'a self, scope: ExecutionScope<'a>) -> ExecutionContext<'a> {
		Self {
			services: self.services,
			scope,
			settings: self.settings,
		}
	}
}

// #[cfg(test)]
// pub struct ContextHarness {
// 	pub services: RunServices,
// 	pub settings: RunSettings,
// 	pub config: Config,
// 	pub rule: Rule,
// 	pub folder: Folder,
// 	pub resource: Resource,
// 	pub resources: Vec<Resource>,
// }

// #[cfg(test)]
// impl<'a> ContextHarness {
// 	/// Creates a new harness with default, dummy data.
// 	pub fn new(resource: Resource, resources: Vec<Resource>) -> Self {
// 		Self {
// 			services: RunServices::default(),
// 			config: Config::default(),
// 			settings: RunSettings {
// 				dry_run: true,
// 				no_parallel: true,
// 			},
// 			rule: Rule::default(),
// 			folder: Folder::default(),
// 			resource,
// 			resources,
// 		}
// 	}

// 	/// Returns a valid `ExecutionContext` with references to the harness's data.
// 	pub fn context(&'a self) -> ExecutionContext<'a> {
// 		let scope = ExecutionScope {
// 			config: &self.config,
// 			rule: &self.rule,
// 			folder: &self.folder,
// 			resource: &self.resource,
// 			resources: &self.resources,
// 		};
// 		ExecutionContext {
// 			services: &self.services,
// 			settings: &self.settings,
// 			scope,
// 		}
// 	}
// }
// Provide `Default` implementations for the final, compiled structs.
// These are only compiled for tests and allow for easy instantiation of dummy objects.

```

`organizer/organize-core\src\context\services\fs\locker.rs`:

```rs
use crate::{
	context::{services::fs::manager::Destination, ExecutionContext},
	engine::ConflictResolution,
	errors::Error,
};
use anyhow::Result;
use dashmap::DashSet;
use std::{future::Future, path::PathBuf, sync::Arc};

#[derive(Debug, Clone, Default)]
pub struct Locker {
	active_paths: Arc<DashSet<PathBuf>>,
}

impl Locker {
	pub async fn with_locked_destination<F, Fut, T>(
		&self,
		ctx: &ExecutionContext<'_>,
		destination: &Destination,
		strategy: &ConflictResolution,
		action: F,
	) -> Result<Option<T>, Error>
	where
		F: FnOnce(PathBuf) -> Fut,
		Fut: Future<Output = Result<T, Error>>,
	{
		let mut path = destination.resolve(ctx).await?;
		let mut n = 1;

		let reserved = loop {
			if self.active_paths.contains(&path) {
				match strategy {
					ConflictResolution::Skip | ConflictResolution::Overwrite => return Ok(None),
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			let exists = if let Some(res) = ctx.services.fs.resources.get(&path).await {
				res.try_exists(ctx).await?
			} else {
				tokio::fs::try_exists(&path).await?
			};

			if exists {
				match strategy {
					ConflictResolution::Skip => return Ok(None),
					ConflictResolution::Overwrite => {
						if !self.active_paths.insert(path.to_path_buf()) {
							return Ok(None);
						}
						break Some(path);
					}
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			if !self.active_paths.insert(path.to_path_buf()) {
				continue;
			}
			break Some(path);
		};

		if let Some(target) = reserved {
			ctx.services.fs.ensure_parent_dir_exists(&target).await?;
			let result = action(target.clone()).await?;

			self.active_paths.remove(&target.to_path_buf());

			Ok(Some(result))
		} else {
			Ok(None)
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\manager.rs`:

```rs
use crate::{
	context::{services::fs::locker::Locker, ExecutionContext},
	errors::Error,
	folder::LocalFileSystem,
	resource::{FileState, Resource},
	storage::StorageProvider,
	templates::template::{Template, TemplateString},
};
use anyhow::Result;
use moka::future::Cache;
use serde::{Deserialize, Serialize};
use std::{
	collections::HashMap,
	iter::FromIterator,
	path::{Path, PathBuf},
	sync::Arc,
};
use url::Url; // Assuming this is needed for dry_run and context

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub struct DestinationBuilder {
	pub folder: TemplateString,
	pub filename: Option<TemplateString>,
}
impl DestinationBuilder {
	/// Compiles the raw DestinationBuilder into an executable Destination.
	pub fn build(self, ctx: &ExecutionContext<'_>) -> Result<Destination, Error> {
		let folder = ctx.services.compiler.compile_template(&self.folder)?;
		let filename = self.filename.map(|f| ctx.services.compiler.compile_template(&f)).transpose()?; // This elegantly handles the Option<Result<T, E>>
		Ok(Destination { folder, filename })
	}
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Destination {
	pub folder: Template,
	pub filename: Option<Template>,
}

impl Destination {
	pub async fn resolve(&self, ctx: &ExecutionContext<'_>) -> Result<PathBuf> {
		let mut folder = PathBuf::from(self.folder.render(ctx).await?);
		if let Some(filename_template) = &self.filename {
			let filename = filename_template.render(ctx).await?;
			folder.push(filename);
		}
		// A placeholder for the original filename if `filename` is not provided.
		// This would need access to the resource from the context.
		else if let Ok(resource) = ctx.scope.resource() {
			if let Some(name) = resource.path.file_name() {
				folder.push(name);
			}
		}
		Ok(folder)
	}
}

#[derive(Debug, Clone)]
pub struct FileSystemManager {
	pub locker: Locker,
	pub resources: Cache<PathBuf, Arc<Resource>>,
	pub tracked_files: Cache<PathBuf, FileState>,
	pub backends: HashMap<String, Arc<dyn StorageProvider>>,
}

pub fn parse_uri(uri_str: &str) -> anyhow::Result<(String, String)> {
	// For local paths, we must construct a valid file URI first.
	if !uri_str.contains("://") {
		// let path = PathBuf::from(uri_str).clean();
		// dbg!(&path);
		// This will correctly handle paths on both Windows and Unix.
		// let url = Url::from_file_path(path).map_err(|_| anyhow::anyhow!("Invalid local path"))?;
		// Return "local" as the host (backend) and the original path.
		return Ok(("local".to_string(), uri_str.to_string()));
	}

	let url = Url::parse(uri_str)?;
	let host = url
		.host_str()
		.ok_or_else(|| anyhow::anyhow!("URI is missing a host (connection name)"))?;
	let path = url.path().to_string();

	Ok((host.to_string(), path))
}

impl Default for FileSystemManager {
	fn default() -> Self {
		Self::new()
	}
}

impl FileSystemManager {
	pub fn new() -> Self {
		let local: Arc<dyn StorageProvider> = Arc::new(LocalFileSystem);
		let backends = HashMap::from_iter(vec![("local".to_string(), local)]);
		Self {
			locker: Locker::default(),
			resources: Cache::new(10_000),
			tracked_files: Cache::new(10_000),
			backends,
		}
	}

	pub async fn ensure_parent_dir_exists(&self, path: &Path) -> std::io::Result<()> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		// resources: CacheBuilder::new(1_000_000)
		// 	.time_to_live(Duration::new(60 * 60 * 24, 0)) // ONE DAY
		// 	.name("cached_resources")
		// 	.build(),
		Ok(())
	}

	pub async fn r#move(&self, source: Arc<Resource>, destination: Arc<Resource>) -> Result<(), Error> {
		// Attempt a direct rename first
		self.ensure_parent_dir_exists(destination.as_path()).await?;
		match tokio::fs::rename(source.as_path(), destination.as_path()).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					source.as_path().display(),
					destination.as_path().display()
				);

				// Perform copy
				tokio::fs::copy(source.as_path(), destination.as_path()).await?;

				// If copy is successful, delete the original
				Ok(tokio::fs::remove_file(source.as_path()).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\mod.rs`:

```rs
pub mod locker;
pub mod manager;

```

`organizer/organize-core\src\context\services\history\mod.rs`:

```rs
use crate::{
	action::{Action, Receipt},
	context::RunSettings,
};
use anyhow::Result;
use sqlx::{sqlite::SqlitePoolOptions, SqlitePool};
use std::time::{SystemTime, UNIX_EPOCH};

/// The Journal service, responsible for all database interactions.
#[derive(Debug, Clone)]
pub struct Journal {
	pool: SqlitePool,
}

#[derive(Debug)]
pub struct Transaction {
	pub id: i64,
	pub receipt: Receipt,
}

impl Journal {
	/// Creates a new Journal instance, connects to the database, and runs migrations.
	pub async fn new(settings: &RunSettings) -> Result<Self> {
		let db_url = if settings.dry_run {
			// For a dry run, use a temporary, private in-memory SQLite database.
			"sqlite::memory:".to_string()
		} else {
			// For a real run, use the persistent database file specified in .env.
			dotenvy::dotenv().ok();
			std::env::var("DATABASE_URL").expect("DATABASE_URL must be set for real runs")
		};

		let pool = SqlitePoolOptions::new().max_connections(5).connect(&db_url).await?;
		sqlx::migrate!("./migrations").run(&pool).await?;

		Ok(Self { pool })
	}

	pub async fn start_session(&self) -> Result<i64> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;

		let record = sqlx::query!(
			r#"
            INSERT INTO sessions (start_time, status)
            VALUES (?1, 'running')
            "#,
			now,
		)
		.execute(&self.pool)
		.await?;

		Ok(record.last_insert_rowid())
	}

	#[allow(clippy::borrowed_box)]
	pub async fn record_transaction(&self, session_id: i64, action: &Box<dyn Action>, receipt: &Receipt) -> Result<()> {
		if receipt.undo.is_empty() {
			return Ok(());
		}

		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		let action_type = action.typetag_name();

		let action_data = serde_json::to_string(action)?;
		let receipt_data = serde_json::to_string(receipt)?;

		sqlx::query!(
			r#"
            INSERT INTO transactions (session_id, type, action, receipt, timestamp)
            VALUES (?1, ?2, ?3, ?4, ?5)
            "#,
			session_id,
			action_type,
			action_data,
			receipt_data,
			now
		)
		.execute(&self.pool)
		.await?;

		Ok(())
	}

	pub async fn get_pending_transactions_for_session(&self, session_id: i64) -> Result<Vec<Transaction>> {
		let transactions = sqlx::query_as!(
			Transaction,
			"SELECT id, receipt FROM transactions WHERE session_id = ? AND undo_status = 'PENDING' ORDER BY timestamp DESC",
			session_id
		)
		.fetch_all(&self.pool)
		.await?;

		Ok(transactions)
	}

	pub async fn update_transaction_undo_status(&self, transaction_id: i64, status: &str) -> Result<()> {
		sqlx::query!("UPDATE transactions SET undo_status = ? WHERE id = ?", status, transaction_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	/// Marks a session as completed with a final status.
	pub async fn end_session(&self, session_id: i64, status: &str) -> Result<()> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		sqlx::query!("UPDATE sessions SET end_time = ?1, status = ?2 WHERE id = ?3", now, status, session_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	pub async fn get_last_session_id(&self) -> Result<Option<i64>> {
		let result = sqlx::query!("SELECT id FROM sessions ORDER BY start_time DESC LIMIT 1")
			.fetch_optional(&self.pool)
			.await?;
		Ok(result.map(|row| row.id))
	}
}

```

`organizer/organize-core\src\context\services\mod.rs`:

```rs
pub mod fs;
pub mod history;

```

`organizer/organize-core\src\engine.rs`:

```rs
use crate::{
	context::{
		services::{fs::manager::FileSystemManager, history::Journal},
		Blackboard,
		ExecutionContext,
		ExecutionScope,
		RunServices,
		RunSettings,
	},
	pipeline::Pipeline,
	rule::{Rule, RuleBuilder},
	templates::compiler::TemplateCompiler,
};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::{path::PathBuf, sync::Arc};
use strum::Display;

#[derive(Default)]
pub enum ExecutionModel {
	#[default]
	Single,
	Batch,
}

#[derive(Eq, Display, PartialEq, Default, Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all(serialize = "lowercase", deserialize = "lowercase"))]
#[strum(serialize_all = "snake_case")]
pub enum ConflictResolution {
	Overwrite,
	#[default]
	Skip,
	Rename,
}

/// The main engine for the application.
/// It owns the compiled configuration and all run-wide services.
pub struct Engine {
	rule: Rule,
	services: RunServices,
	settings: RunSettings,
}

impl Engine {
	pub async fn new(path: &PathBuf, settings: RunSettings) -> Result<Arc<Self>> {
		let services = RunServices {
			blackboard: Blackboard::default(),
			journal: Arc::new(Journal::new(&settings).await?),
			fs: FileSystemManager::new(),
			compiler: TemplateCompiler::new(),
		};
		let content = tokio::fs::read_to_string(path).await?;
		let rule = {
			let builder: RuleBuilder = toml::from_str(&content)?;
			let ctx = ExecutionContext {
				services: &services,
				scope: ExecutionScope::Blank,
				settings: &settings,
			};
			let rule = builder.build(&ctx).await?;
			rule
		};

		Ok(Arc::new(Self { rule, services, settings }))
	}

	pub async fn run(&self) -> Result<()> {
		let pipeline = Pipeline::new(self.rule.clone());

		// Create the top-level execution context with a blank scope.
		let ctx = ExecutionContext {
			services: &self.services,
			settings: &self.settings, // Assuming you have settings
			scope: ExecutionScope::Blank,
		};

		let _final_stream = pipeline.run(&ctx).await?;
		Ok(())
	}
}

```

`organizer/organize-core\src\errors.rs`:

```rs
use std::path::PathBuf;
use thiserror::Error;

use crate::{action::UndoError, parser::errors::ParseError, templates::engine::TemplateError};

/// The primary error type for all actions within the application.
#[derive(Error, Debug)]
pub enum Error {
	#[error("Error converting to value")]
	Json(#[from] serde_json::Error),

	#[error(transparent)]
	Io(#[from] std::io::Error),

	#[error(transparent)]
	Other(#[from] anyhow::Error),

	#[error("Could not create backup for: {path:?}")]
	Backup {
		#[source]
		source: std::io::Error,
		path: PathBuf,
	},

	#[error(transparent)]
	ParseError(#[from] ParseError),

	#[error("Error in prompt")]
	Interaction {
		#[source]
		source: std::io::Error,
		prompt: String,
	},

	#[error(transparent)]
	TemplateError(#[from] TemplateError),

	#[error("Tried to retrieve `{0}` from the scope but it is not defined")]
	OutOfScope(String),

	#[error(transparent)]
	UndoError(#[from] UndoError),
}

```

`organizer/organize-core\src\filter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

// pub mod content;
// pub mod empty;
// pub mod extension;
// pub mod filename;
// pub mod mime;
// pub mod regex;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource};

dyn_clone::clone_trait_object!(Filter);
dyn_eq::eq_trait_object!(Filter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Filter: DynClone + DynEq + Debug + Send + Sync {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::Single
	}

	/// Takes the execution context, which contains the appropriate scope,
	/// and returns a Result containing the list of files that passed.
	async fn filter(&self, ctx: &ExecutionContext) -> Result<Vec<Arc<Resource>>, Error>;
}

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct Not(Box<dyn Filter>);

// impl std::ops::Deref for Not {
// 	type Target = Box<dyn Filter>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "not")]
// impl Filter for Not {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		!self.filter(ctx).await
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AnyOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AnyOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "any_of")]
// impl Filter for AnyOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().any(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AllOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AllOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "all_of")]
// impl Filter for AllOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().all(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct NoneOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for NoneOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "none_of")]
// impl Filter for NoneOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		!results.iter().any(|&result| result)
// 	}
// }

```

`organizer/organize-core\src\folder.rs`:

```rs
use std::{
	collections::HashSet,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

use anyhow::{Context as ErrorContext, Result};
use async_trait::async_trait;
use futures::{stream, StreamExt};
use serde::{Deserialize, Serialize};

use crate::{
	context::{services::fs::manager::parse_uri, ExecutionContext, ExecutionScope},
	errors::Error,
	options::OptionsBuilder,
	resource::Resource,
	stdx::path::PathExt,
	storage::StorageProvider,
	templates::template::TemplateString,
};

use super::options::{Options, Target};

#[derive(Debug, Serialize, PartialEq, Eq, Clone, Deserialize)]
pub struct LocationBuilder {
	pub path: TemplateString,
	#[serde(flatten)]
	pub options: OptionsBuilder,
	#[serde(default)]
	pub mode: SearchMode,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Location {
	pub path: PathBuf,
	pub options: Options,
	pub mode: SearchMode,
	pub backend: Arc<dyn StorageProvider>,
}

impl PartialEq for Location {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path && self.options == other.options && self.mode == other.mode
	}
}

impl Eq for Location {}

impl LocationBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Location, Error> {
		let path_template = ctx.services.compiler.compile_template(&self.path)?;
		let uri = path_template.render(ctx).await?;
		let (host, path) = parse_uri(&uri)?;
		let path = PathBuf::from(path);

		let ctx = &ExecutionContext {
			services: ctx.services,
			scope: ExecutionScope::new_build_scope(&path),
			settings: ctx.settings,
		};

		Ok(Location {
			path,
			options: self.options.compile(ctx).await?,
			mode: self.mode,
			backend: ctx.services.fs.backends.get(&host).unwrap().clone(), // The direct Arc clone to the provider
		})
	}
}
/// The final, compiled `Folder` object, ready for execution.

#[derive(Debug, Deserialize, Serialize, Default, PartialEq, Eq, Clone)]
#[serde(rename_all = "lowercase")]
pub enum SearchMode {
	Replace,
	#[default]
	Append,
}

impl SearchMode {
	/// Returns `true` if the search mode is [`Replace`].
	///
	/// [`Replace`]: SearchMode::Replace
	#[must_use]
	pub fn is_replace(&self) -> bool {
		matches!(self, Self::Replace)
	}

	/// Returns `true` if the search mode is [`Append`].
	///
	/// [`Append`]: SearchMode::Append
	#[must_use]
	pub fn is_append(&self) -> bool {
		matches!(self, Self::Append)
	}
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct LocalFileSystem;

#[async_trait]
#[typetag::serde(name = "local")]
impl StorageProvider for LocalFileSystem {
	fn prefix(&self) -> &'static str {
		"file"
	}

	fn home(&self) -> Result<PathBuf, Error> {
		Ok(dirs::home_dir().context("unable to find home directory")?)
	}

	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		Ok(())
	}

	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		// ctx.services.fs.ensure_parent_dir_exists(destination.as_path()).await?;
		self.mkdir(to, ctx).await?;
		match tokio::fs::rename(from, to).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					from.display(),
					to.display()
				);

				tokio::fs::copy(from, to).await?;
				Ok(tokio::fs::remove_file(from).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}

	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn delete(&self, path: &Path) -> Result<(), Error> {
		todo!()
	}

	async fn download(&self, from: &Path) -> Result<PathBuf, Error> {
		Ok(PathBuf::new())
	}

	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		Ok(())
	}

	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error> {
		let concurrency_limit = 50;
		let home = self.home()?;
		let min_depth = {
			let base = if location.path == home {
				1.0 as usize
			} else {
				location.options.min_depth
			};
			(base as f64).max(1.0) as usize
		};

		let max_depth = if location.path == home {
			1.0 as usize
		} else {
			location.options.max_depth
		};

		let mut collected_paths = Vec::new();
		let mut dirs_to_visit: Vec<(PathBuf, usize)> = vec![];

		let excluded_paths_set: HashSet<&PathBuf> = location.options.exclude.iter().collect();

		if excluded_paths_set.contains(&location.path) {
			tracing::warn!(
				"Start directory '{}' is in the excluded paths. Aborting search.",
				&location.path.display()
			);
			return Ok(Vec::new());
		}

		if min_depth == 0 {
			collected_paths.push(location.path.clone());
		}

		dirs_to_visit.push((location.path.clone(), 0));

		while let Some((current_dir, current_depth)) = dirs_to_visit.pop() {
			if current_depth >= max_depth {
				continue;
			}

			let mut entries = match tokio::fs::read_dir(&current_dir).await {
				Ok(e) => e,
				Err(e) => {
					eprintln!("Warning: Could not read directory {}: {}", current_dir.display(), e);
					continue;
				}
			};

			while let Some(entry) = entries.next_entry().await? {
				let path = entry.path();
				let next_depth = current_depth + 1;

				// --- Exclusion Logic for encountered paths (files or directories) ---
				if excluded_paths_set.contains(&path) {
					eprintln!("Excluding path: {}", path.display());
					// If it's a directory, we effectively prune the branch.
					// If it's a file, we just don't collect it.
					continue;
				}
				// --- End Exclusion Logic ---

				// Only add &location.path if it's within the specified depth range
				if next_depth >= min_depth && next_depth <= max_depth {
					collected_paths.push(path.clone());
				}

				// If it's a directory and still within max_depth, add it to dirs_to_visit
				// (after checking for exclusion, which is done above)
				if path.is_dir() && next_depth < max_depth {
					dirs_to_visit.push((path, next_depth));
				}
			}
		}

		// let all_files = self.find_all_files(min_depth, max_depth, ctx).await?;
		let location: Arc<Location> = Arc::new(location.clone());
		let resource_creation_futures = collected_paths
			.into_iter()
			.filter(|e| self.filter_entries(e, &location.options))
			.map(|e| {
				// Capture `e` by moving it into the async block
				// Capture `ctx` by reference (or clone/Arc if its lifetime is an issue)
				let ctx_ref = ctx;
				let location = location.clone();
				async move {
					e.as_resource(ctx_ref, location).await // Returns Result<Resource, AsResourceError>
				}
			});

		Ok(stream::iter(resource_creation_futures) // stream::iter expects an Iterator<Item=Future>
			.buffer_unordered(concurrency_limit) // Execute Futures concurrently
			.collect()
			.await)
	}

	async fn metadata(&self, path: &Path) -> Result<Metadata, Error> {
		Ok(tokio::fs::metadata(path).await?)
	}

	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error> {
		let mut dir = tokio::fs::read_dir(path).await?;
		let mut paths = vec![];
		while let Some(entry) = dir.next_entry().await? {
			paths.push(entry.path());
		}
		Ok(paths)
	}

	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error> {
		Ok(tokio::fs::read(path).await?)
	}

	async fn write(&self, path: &Path, content: &[u8]) -> Result<()> {
		todo!()
	}
}

impl LocalFileSystem {
	fn filter_entries(&self, path: &Path, options: &Options) -> bool {
		if path.is_file() && options.target == Target::Folders {
			return false;
		}
		if path.is_dir() && options.target == Target::Files {
			return false;
		}

		if path.is_file() {
			if let Some(extension) = path.extension() {
				let partial_extensions = &["crdownload", "part", "download"];
				if partial_extensions.contains(&&*extension.to_string_lossy()) && !options.partial_files {
					return false;
				}
			}
			if path.is_hidden().unwrap_or(false) && !options.hidden_files {
				return false;
			}
		}
		true
	}
}

```

`organizer/organize-core\src\grouper.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

use crate::{batch::Batch, errors::Error};

dyn_clone::clone_trait_object!(Grouper);
dyn_eq::eq_trait_object!(Grouper);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Grouper: DynEq + DynClone + Sync + Send + Debug {
	fn name(&self) -> &str;
	async fn group(&self, batch: &Batch) -> Result<Vec<Batch>, Error>;
}

```

`organizer/organize-core\src\lib.rs`:

```rs
#![feature(file_lock)]
#![feature(path_add_extension)]
#![feature(lock_value_accessors)]

pub const PROJECT_NAME: &str = "organize";

pub mod action;
pub mod batch;
pub mod builtins;
pub mod common;
pub mod config;
pub mod context;
pub mod engine;
pub mod errors;
pub mod filter;
pub mod folder;
pub mod grouper;
pub mod selector;
// pub mod hook;
pub mod options;
pub mod parser;
pub mod pipeline;
pub mod resource;
pub mod rule;
pub mod sorter;
pub mod stdx;
pub mod storage;
pub mod templates;
pub mod utils;

```

`organizer/organize-core\src\options.rs`:

```rs
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, path::PathBuf};

use crate::{context::ExecutionContext, errors::Error, templates::template::TemplateString};

fn default_usize() -> usize {
	1.0 as usize
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct OptionsBuilder {
	#[serde(default = "default_usize")]
	pub max_depth: usize,
	#[serde(default = "default_usize")]
	pub min_depth: usize,
	#[serde(default)]
	pub exclude: Vec<TemplateString>,
	#[serde(default)]
	pub hidden_files: bool,
	#[serde(default)]
	pub partial_files: bool,
	#[serde(default)]
	pub target: Target,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Options {
	pub max_depth: usize,
	pub min_depth: usize,
	pub exclude: Vec<PathBuf>,
	pub hidden_files: bool,
	pub partial_files: bool,
	pub target: Target,
}

impl OptionsBuilder {
	pub async fn compile(self, ctx: &ExecutionContext<'_>) -> Result<Options, Error> {
		let mut excluded_paths = Vec::new();

		for template in &self.exclude {
			let template = ctx.services.compiler.compile_template(template)?;
			if let Ok(rendered_path_str) = template.render(ctx).await {
				excluded_paths.push(PathBuf::from(rendered_path_str));
			}
		}

		Ok(Options {
			max_depth: self.max_depth,
			min_depth: self.min_depth,
			exclude: excluded_paths,
			hidden_files: self.hidden_files,
			partial_files: self.partial_files,
			target: self.target,
		})
	}
}

#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Target {
	#[default]
	Files,
	Folders,
}

```

`organizer/organize-core\src\parser\ast.rs`:

```rs
use chumsky::Parser;
use logos::Logos;

use crate::parser::{
	errors::ParseError,
	lexer::{LexingError, Token},
	parser,
};

// For now, an Expression is just a VariablePath.
// We can add Literals here later if needed.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Expression {
	Variable(Vec<String>),
}

// A full template is a sequence of literal text and expressions.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Segment {
	Literal(String),
	Expression(Expression),
}

#[derive(Debug, PartialEq, Clone, Eq)]
pub struct AST {
	pub segments: Vec<Segment>,
}

impl AST {
	/// Parses a raw string into an Abstract Syntax Tree (AST).
	/// This function orchestrates the lexer and expression parser.
	pub fn parse(s: &str) -> Result<Self, ParseError> {
		let mut segments = Vec::new();
		let mut input = s;

		while !input.is_empty() {
			// Find the start of the next expression
			if let Some(start_delim) = input.find("{{") {
				// Anything before the `{{` is a literal
				if start_delim > 0 {
					segments.push(Segment::Literal(input[..start_delim].to_string()));
				}

				// Find the end of the expression
				let expr_content_start = start_delim + 2;
				if let Some(end_delim_relative) = input[expr_content_start..].find("}}") {
					let expr_content_end = expr_content_start + end_delim_relative;
					let expression_content = &input[expr_content_start..expr_content_end].trim();

					// Lex and parse the content inside the delimiters
					let tokens = Token::lexer(expression_content).collect::<Result<Vec<Token<'_>>, LexingError>>()?;

					let (expression, errs) = parser().parse(&tokens).into_output_errors();

					match expression {
						Some(expr) => segments.push(Segment::Expression(expr)),
						None => {
							return Err(ParseError::InvalidExpression {
								content: format!("Could not parse expression: '{{ {expression_content} }}'. Errors: {errs:?}"),
							})
						}
					}

					// Advance the input slice past the `}}`
					input = &input[expr_content_end + 2..];
				} else {
					return Err(ParseError::MismatchedDelimiters {
						position: expr_content_start,
					});
				}
			} else {
				// No more `{{` found, the rest of the string is a literal
				segments.push(Segment::Literal(input.to_string()));
				break;
			}
		}

		Ok(AST { segments })
	}
}

```

`organizer/organize-core\src\parser\errors.rs`:

```rs
use crate::parser::lexer::LexingError;
use thiserror::Error;

// This will be the single, unified error type returned by your parser.
#[derive(Error, Debug)]
pub enum ParseError {
	#[error("Mismatched delimiters: found '{{' at position {position} with no closing '}}'")]
	MismatchedDelimiters { position: usize },

	#[error("Could not parse expression: '{{ {content} }}'")]
	InvalidExpression { content: String },

	#[error(transparent)]
	LexingError(#[from] LexingError),
}

impl ParseError {
	/// Returns `true` if the parse error is [`MismatchedDelimiters`].
	///
	/// [`MismatchedDelimiters`]: ParseError::MismatchedDelimiters
	#[must_use]
	pub fn is_mismatched_delimiters(&self) -> bool {
		matches!(self, Self::MismatchedDelimiters { .. })
	}

	/// Returns `true` if the parse error is [`InvalidExpression`].
	///
	/// [`InvalidExpression`]: ParseError::InvalidExpression
	#[must_use]
	pub fn is_invalid_expression(&self) -> bool {
		matches!(self, Self::InvalidExpression { .. })
	}

	/// Returns `true` if the parse error is [`LexingError`].
	///
	/// [`LexingError`]: ParseError::LexingError
	#[must_use]
	pub fn is_lexing_error(&self) -> bool {
		matches!(self, Self::LexingError { .. })
	}
}

```

`organizer/organize-core\src\parser\lexer.rs`:

```rs
use logos::Logos;
use thiserror::Error;

#[derive(Error, Default, Debug, Clone, PartialEq)]
pub enum LexingError {
	#[error("Invalid identifier: {0}")]
	InvalidIdentifier(String),
	#[default]
	#[error("Unknown lexing error")]
	Other,
}

#[derive(Logos, Debug, PartialEq, Clone)]
#[logos(skip r"[ \t\f\n]+", error = LexingError, extras = (usize, usize))]
pub enum Token<'a> {
	#[token("{{")]
	OpenDelim,
	#[token("}}")]
	CloseDelim,
	#[token(".")]
	Dot,
	#[regex(r"[a-zA-Z0-9_][a-zA-Z0-9_]*")]
	Identifier(&'a str),
	#[regex(".",  |lex| Err(LexingError::InvalidIdentifier(lex.slice().to_string())), priority = 1)]
	InvalidToken(LexingError),
}

#[cfg(test)]
mod tests {
	use super::*; // Import Token and Logos

	fn lex<'a>(input: &'a str) -> Vec<Result<Token<'a>, LexingError>> {
		// A helper function to collect all tokens from the lexer
		Token::lexer(input).collect()
	}

	#[test]
	fn test_simple_variable() {
		let tokens = lex("{{ name }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("name".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_path_expression() {
		let tokens = lex("{{ user.address.city }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("address".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("city".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_invalid_token() {
		// Logos will produce an Error token for characters it doesn't recognize
		// In our current lexer, most symbols would be skipped or cause an error.
		// Let's assume we modify the lexer slightly to capture errors.
		// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ user.name! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("name".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_character_within_expression() {
		// 	// Logos will produce an Error token for characters it doesn't recognize
		// 	// In our current lexer, most symbols would be skipped or cause an error.
		// 	// Let's assume we modify the lexer slightly to capture errors.
		// 	// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ path! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("path".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_start_of_identifier() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ 1st_place }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Err(LexingError::InvalidIdentifier("1".into())),
			Ok(Token::Identifier("st_place".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_multiple_errors() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ user.@email + }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Err(LexingError::InvalidIdentifier("@".into())),
			Ok(Token::Identifier("email".into())),
			Err(LexingError::InvalidIdentifier("+".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_empty_expression() {
		let tokens = lex("{{}}");
		assert_eq!(tokens, vec![Ok(Token::OpenDelim), Ok(Token::CloseDelim)])
	}
}

```

`organizer/organize-core\src\parser\mod.rs`:

```rs
use chumsky::prelude::*;

use crate::parser::{ast::Expression, lexer::Token};

pub mod ast;
pub mod errors;
pub mod lexer;

pub fn parser<'a>() -> impl Parser<'a, &'a [Token<'a>], Expression, extra::Err<Simple<'a, Token<'a>>>> {
	// A parser for a single identifier token
	let ident = select! { Token::Identifier(s) => s.to_string() };

	// A parser for a dot-separated path of one or more identifiers
	let var_path = ident
		.separated_by(just(Token::Dot))
		.at_least(1) // must have at least one part
		.collect::<Vec<String>>()
		.map(|parts| parts);

	var_path.map(Expression::Variable)
}

```

`organizer/organize-core\src\pipeline.rs`:

```rs
use futures::future;

use crate::{
	action::Receipt,
	batch::Batch,
	context::{ExecutionContext, ExecutionScope},
	engine::ExecutionModel,
	errors::Error,
	grouper::Grouper,
	resource::Resource,
	rule::{Rule, Stage},
	sorter::Sorter,
};
use std::sync::Arc;

/// Represents the data flowing through the pipeline.
/// It tracks the current set of file batches and the sequence of
/// groupers that have been applied to create them.
#[derive(Debug)]
pub struct PipelineStream {
	/// The current data, always represented as a list of batches.
	/// An "ungrouped" state is simply a Vec with one Batch.
	pub batches: Vec<Batch>,
	/// The ordered stack of groupers that have been applied.
	pub groupers: Vec<Box<dyn Grouper>>,
	pub sorters: Vec<Box<dyn Sorter>>,
}

impl PipelineStream {
	/// Creates a new stream with a single batch of files and no groupings.
	pub fn new(files: Vec<Arc<Resource>>) -> Self {
		Self {
			batches: vec![Batch::initial(files)],
			groupers: Vec::new(),
			sorters: Vec::new(),
		}
	}

	/// Flattens all batches into a single, unordered list of files.
	pub fn all_files(&self) -> Vec<Arc<Resource>> {
		self.batches.iter().flat_map(|batch| batch.files.clone()).collect()
	}

	pub async fn resort(&mut self) {
		for batch in self.batches.iter_mut() {
			for sorter in &self.sorters {
				sorter.sort(&mut batch.files).await;
			}
		}
	}

	/// Re-applies the entire stack of stored groupers to a new set of files.
	/// This is the key to maintaining a consistent state.
	pub async fn regroup(&self, files: Vec<Arc<Resource>>) -> Result<Vec<Batch>, anyhow::Error> {
		let mut current_batches = vec![Batch::initial(files)];

		for grouper in &self.groupers {
			let mut next_level_batches = Vec::new();
			for batch in current_batches {
				// Apply the grouper to each batch from the previous level
				next_level_batches.extend(grouper.group(&batch).await?);
			}
			current_batches = next_level_batches;
		}
		Ok(current_batches)
	}
}

pub struct Pipeline {
	stages: Vec<Stage>,
	stream: PipelineStream,
}

impl Pipeline {
	pub fn new(rule: Rule) -> Self {
		Self {
			stages: rule.pipeline,
			stream: PipelineStream::new(Vec::new()), // Start with no files
		}
	}

	pub async fn run(mut self, ctx: &ExecutionContext<'_>) -> Result<PipelineStream, Error> {
		for stage in self.stages.into_iter() {
			match stage {
				Stage::Search { location, source } => {
					let scope = ExecutionScope::new_location_scope(source.clone(), &location);
					let ctx = ctx.with_scope(scope);
					let new_files = location.backend.discover(&location, &ctx).await?;
					if location.mode.is_append() {
						let mut all_files = self.stream.all_files();
						all_files.extend(new_files);
						self.stream.batches = self.stream.regroup(all_files).await?;
						self.stream.resort().await;
					} else {
						self.stream = PipelineStream::new(new_files);
					}
				}
				Stage::Grouper { grouper, .. } => {
					let all_files = self.stream.all_files();
					self.stream.groupers.push(grouper);
					self.stream.batches = self.stream.regroup(all_files).await?;
					self.stream.resort().await;
				}
				Stage::Sorter { sorter, .. } => {
					self.stream.sorters.push(sorter);
					self.stream.resort().await;
				}
				Stage::Filter { filter, source } => {
					let mut next_batches = Vec::new();
					match filter.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let passed_files = filter.filter(&batch_ctx).await?;
								if !passed_files.is_empty() {
									next_batches.push(Batch {
										files: passed_files,
										context: batch.context.clone(),
									});
								}
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let filter = filter.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										filter.filter(&ctx).await
									};
									futs.push(fut);
								}
								let results: Vec<Arc<Resource>> = future::try_join_all(futs).await?.into_iter().flatten().collect();
								if !results.is_empty() {
									next_batches.push(Batch {
										files: results,
										context: batch.context.clone(),
									});
								}
							}
						}
					}
					self.stream.batches = next_batches;
				}
				Stage::Action { action, source } => {
					let mut all_next_files = Vec::new();
					match action.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let receipt = action.commit(&batch_ctx).await?;
								all_next_files.extend(receipt.next);
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let action = action.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										action.commit(&ctx).await
									};
									futs.push(fut);
								}
								let receipts: Vec<Receipt> = future::try_join_all(futs).await?;
								for receipt in receipts {
									all_next_files.extend(receipt.next);
								}
							}
						}
					}
					// An action's output always replaces the current data stream and resets grouping.
					self.stream = PipelineStream::new(all_next_files);
				}
				Stage::Flatten { flatten, .. } => {
					if flatten {
						self.stream = PipelineStream::new(self.stream.all_files());
					}
				}
				Stage::Select { selector, .. } => {
					let selection_futures = self.stream.batches.iter().map(|batch| selector.select(batch));
					let selected_batches: Vec<Batch> = future::try_join_all(selection_futures).await?.into_iter().collect();
					self.stream.batches = selected_batches;
				}
			}
		}
		Ok(self.stream)
	}
}

```

`organizer/organize-core\src\resource.rs`:

```rs
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::{
	fmt::{Debug, Display},
	fs::Metadata,
	hash::Hash,
	path::{Path, PathBuf},
	sync::{Arc, OnceLock},
};
use tokio::{fs::File, io::AsyncReadExt};

use crate::{context::ExecutionContext, errors::Error, folder::Location};

#[derive(Debug, Default, Clone)]
pub enum FileState {
	Unknown,
	#[default]
	Exists,
	Deleted,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Resource {
	pub path: PathBuf,
	pub location: Arc<Location>,
	#[serde(skip)]
	mime: OnceLock<String>,
	#[serde(skip)]
	bytes: OnceLock<Vec<u8>>,
	#[serde(skip)]
	hash: OnceLock<String>,
	#[serde(skip)]
	metadata: OnceLock<Metadata>,
}

impl AsRef<Path> for Resource {
	fn as_ref(&self) -> &Path {
		self.path.as_path()
	}
}

impl Display for Resource {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.path.display())
	}
}

impl PartialEq for Resource {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path
	}
}

impl Hash for Resource {
	fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
		self.path.hash(state);
	}
}

impl Eq for Resource {}

impl Resource {
	pub fn as_path(&self) -> &Path {
		self.path.as_path()
	}

	pub fn with_filename(self, filename: &str) -> Self {
		let new_path = self.path.with_file_name(filename);
		self.with_path(new_path)
	}

	pub fn with_path(self, new_path: PathBuf) -> Self {
		Self {
			path: new_path,
			location: self.location, // The origin root folder remains the same.

			// The content, hash, and MIME type of a file do not change when it is moved.
			// We can move these initialized OnceLock fields to the new struct to preserve the cache.
			bytes: self.bytes,
			hash: self.hash,
			mime: self.mime,

			// The filesystem metadata (like modification times of parent dirs) IS different
			// at the new location. We reset this field to force a re-fetch if needed.
			metadata: OnceLock::new(),
		}
	}

	pub fn get_mime(&self) -> &str {
		match self.mime.get() {
			Some(mime) => mime.as_str(),
			None => {
				let mime = mime_guess::from_path(&self.path).first_or_octet_stream().to_string();
				self.mime.set(mime).unwrap();
				self.mime.get().unwrap().as_str()
			}
		}
	}

	pub async fn get_metadata(&self) -> &Metadata {
		match self.metadata.get() {
			Some(metadata) => metadata,
			None => {
				let metadata = tokio::fs::metadata(&self.path).await.unwrap();
				self.metadata.set(metadata).unwrap();
				self.metadata.get().unwrap()
			}
		}
	}

	pub async fn get_bytes(&self) -> &Vec<u8> {
		match self.bytes.get() {
			Some(content) => content,
			None => {
				let content = tokio::fs::read(&self.path).await.unwrap();
				self.bytes.set(content).unwrap();
				self.bytes.get().unwrap()
			}
		}
	}

	pub async fn get_hash(&self) -> &String {
		match self.hash.get() {
			Some(hash) => hash,
			None => {
				let mut file = File::open(&self.path).await.unwrap();
				let mut hasher = Sha256::new();
				let mut buffer = [0; 1024];
				loop {
					let count = file.read(&mut buffer).await.unwrap();
					if count == 0 {
						break;
					}
					hasher.update(&buffer[..count]);
				}
				let hash = hasher.finalize();
				let hash_str = format!("{hash:x}");
				self.hash.set(hash_str).unwrap();
				self.hash.get().unwrap()
			}
		}
	}
}

// impl Serialize for Resource {
// 	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
// 	where
// 		S: Serializer,
// 	{
// 		// Serialize the PathBuf that the Arc points to.
// 		self.path.serialize(serializer)
// 	}
// }
//
impl Resource {
	pub fn new(path: &PathBuf, location: Arc<Location>) -> Self {
		Self {
			path: path.clone(),
			location,
			mime: OnceLock::new(),
			bytes: OnceLock::new(),
			hash: OnceLock::new(),
			metadata: OnceLock::new(),
		}
	}

	pub async fn try_exists(&self, ctx: &ExecutionContext<'_>) -> Result<bool, Error> {
		if ctx.settings.dry_run {
			return match ctx
				.services
				.fs
				.tracked_files
				.get(self.as_path())
				.await
				.unwrap_or(FileState::Unknown)
			{
				FileState::Exists => Ok(true),
				FileState::Deleted => Ok(false),
				FileState::Unknown => Ok(tokio::fs::try_exists(&self.path).await?),
			};
		}

		// Otherwise, check the physical filesystem using the resource's path.
		Ok(tokio::fs::try_exists(&self.path).await?)
	}
}

// #[cfg(test)]
// mod tests {
// 	use super::*;
// 	use std::path::PathBuf;

// 	#[test]
// 	fn new_with_valid_path_succeeds() {
// 		let path = PathBuf::from("/tmp/test.txt");
// 		let root = PathBuf::from("/tmp");
// 		let resource = Resource::new(&path, &root).unwrap();
// 		assert_eq!(resource.path(), &path);
// 		assert_eq!(resource.root(), &root);
// 	}

// 	#[test]
// 	fn new_with_root_path_returns_err() {
// 		let path = PathBuf::from("/");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_dot_path_succeeds_on_windows_fails_on_unix() {
// 		let path = PathBuf::from(".");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_relative_path_succeeds() {
// 		let path = PathBuf::from("some/dir/file.txt");
// 		let result = Resource::new(&path, "some/dir");
// 		assert!(result.is_ok());
// 	}

// 	#[test]
// 	fn new_with_bare_filename_returns_err() {
// 		// A bare filename like "file.txt" has an empty parent, which the new logic correctly rejects.
// 		let path = PathBuf::from("file.txt");
// 		let result = Resource::new(&path, ".");
// 		assert!(result.is_err());
// 	}
// }

```

`organizer/organize-core\src\rule.rs`:

```rs
use std::{path::PathBuf, sync::Arc};

use itertools::Itertools;
use serde::{Deserialize, Deserializer, Serialize};

use crate::{
	action::{Action, ActionBuilder},
	context::ExecutionContext,
	errors::Error,
	filter::Filter,
	folder::{Location, LocationBuilder},
	grouper::Grouper,
	selector::Selector,
	sorter::Sorter,
};

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct RuleMetadata {
	pub name: Option<String>,
	pub description: Option<String>,
	#[serde(default)]
	pub tags: Vec<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct RuleBuilder {
	#[serde(flatten)]
	pub metadata: RuleMetadata,
	#[serde(rename = "stage")]
	pub pipeline: Vec<StageBuilder>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Rule {
	pub metadata: Arc<RuleMetadata>,
	pub pipeline: Vec<Stage>,
}

async fn load_rule_builder_from_path(path: &std::path::Path) -> Result<RuleBuilder, anyhow::Error> {
	let content = tokio::fs::read_to_string(path).await?;
	let builder: RuleBuilder = toml::from_str(&content)?;
	Ok(builder)
}

impl RuleBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Rule, Error> {
		let mut final_pipeline = Vec::new();
		let main_meta = Arc::new(self.metadata);
		let mut processing_stack: Vec<(StageBuilder, Arc<RuleMetadata>)> = self
			.pipeline
			.into_iter()
			.map(|builder| (builder, main_meta.clone()))
			.rev()
			.collect();

		while let Some((builder, meta)) = processing_stack.pop() {
			match builder {
				StageBuilder::Compose(path) => {
					let composed_builder = load_rule_builder_from_path(&path).await?;
					let composed_meta = Arc::new(composed_builder.metadata);
					for stage_builder in composed_builder.pipeline.into_iter().rev() {
						processing_stack.push((stage_builder, composed_meta.clone()));
					}
				}
				// The logic to build the final Stage enum now changes slightly
				other_builder => {
					let stage_enum = other_builder.build(ctx, meta).await?;
					final_pipeline.push(stage_enum);
				}
			}
		}

		Ok(Rule {
			metadata: main_meta.clone(),
			pipeline: final_pipeline,
		})
	}
}

#[derive(Debug, Serialize, PartialEq, Eq, Clone)]
pub enum StageBuilder {
	Search(LocationBuilder),
	Compose(PathBuf),
	Action(Box<dyn ActionBuilder>),
	Filter(Box<dyn Filter>),
	Select(Box<dyn Selector>),
	Grouper(Box<dyn Grouper>),
	Sorter(Box<dyn Sorter>),
	Flatten(bool),
}

impl StageBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>, source: Arc<RuleMetadata>) -> Result<Stage, Error> {
		match self {
			StageBuilder::Search(location_builder) => {
				let stage = location_builder.build(ctx).await.unwrap();
				Ok(Stage::Search { location: stage, source })
			}
			StageBuilder::Flatten(bool) => Ok(Stage::Flatten {
				flatten: bool,
				source,
			}),
			StageBuilder::Action(builder) => {
				let stage = builder.build(ctx).await?;
				Ok(Stage::Action { action: stage, source })
			}
			StageBuilder::Filter(stage) => Ok(Stage::Filter { filter: stage, source }),
			StageBuilder::Grouper(stage) => Ok(Stage::Grouper { grouper: stage, source }),
			StageBuilder::Sorter(stage) => Ok(Stage::Sorter { sorter: stage, source }),
			StageBuilder::Compose(_) => unreachable!("Compose stages should be flattened"),
			StageBuilder::Select(stage) => Stage::Select { selector: stage, source },
		}
	}
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Stage {
	Search {
		location: Location,
		source: Arc<RuleMetadata>,
	},
	Action {
		action: Box<dyn Action>,
		source: Arc<RuleMetadata>,
	},
	Filter {
		filter: Box<dyn Filter>,
		source: Arc<RuleMetadata>,
	},
	Select {
		selector: Box<dyn Selector>,
		source: Arc<RuleMetadata>,
	},
	Flatten {
		flatten: bool,
		source: Arc<RuleMetadata>,
	},
	Grouper {
		grouper: Box<dyn Grouper>,
		source: Arc<RuleMetadata>,
	},
	Sorter {
		sorter: Box<dyn Sorter>,
		source: Arc<RuleMetadata>,
	},
}

// impl<'de> Deserialize<'de> for StageBuilder {
// 	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
// 	where
// 		D: Deserializer<'de>,
// 	{
// 		// Deserialize the TOML [[stage]] table into a generic Value.
// 		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
// 		let table = map
// 			.as_table_mut()
// 			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

// 		// Find the single key that defines the stage type.
// 		let key = {
// 			let keys: Vec<_> = table.keys().cloned().collect();
// 			if keys.len() != 1 {
// 				// This handles the case where a stage has multiple primary keys, like both `filter` and `action`.
// 				// We need to check for this AFTER handling the parameters that live alongside the primary key.
// 				// We will find the primary key first, and then deserialize the rest.
// 			}

// 			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
// 			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
// 				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
// 			})?
// 		};

// 		// The value associated with the primary key.
// 		let value = table
// 			.remove(&key)
// 			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{}'", key)))?;

// 		// The rest of the table contains the parameters.
// 		let params = toml::Value::Table(table.clone());

// 		match key.as_str() {
// 			"search" => {
// 				let path_template = value.try_into::<String>().map_err(serde::de::Error::custom)?;
// 				let mut builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;
// 				builder.path = Template::from_str(&path_template).map_err(serde::de::Error::custom)?; // Set the path from the primary key's value
// 				Ok(StageBuilder::Search(builder))
// 			}
// 			"compose" => {
// 				let rules_to_compose = value.try_into::<Vec<PathBuf>>().map_err(serde::de::Error::custom)?;
// 				Ok(StageBuilder::Compose(rules_to_compose))
// 			}
// 			"filter" | "action" | "group-by" | "sort-by" => {
// 				// This handles all the typetag'd trait objects.
// 				let component_type = value
// 					.as_str()
// 					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{}'", key)))?;

// 				// We inject the `type` field that `typetag` expects into the parameters table.
// 				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
// 				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
// 				let component_value = toml::Value::Table(component_table);

// 				// Now deserialize from this new value into the correct trait object.
// 				match key.as_str() {
// 					"filter" => Ok(StageBuilder::Filter(
// 						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"action" => Ok(StageBuilder::Action(
// 						Box::<dyn Action>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"group-by" => Ok(StageBuilder::Grouper(
// 						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"sort-by" => Ok(StageBuilder::Sorter(
// 						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					_ => unreachable!(),
// 				}
// 			}
// 			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{}'", other))),
// 		}
// 	}
// }

impl<'de> Deserialize<'de> for StageBuilder {
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where
		D: Deserializer<'de>,
	{
		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
		let table = map
			.as_table_mut()
			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

		let key = {
			let keys: Vec<_> = table.keys().cloned().collect();
			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
			})?
		};

		let value = table
			.remove(&key)
			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{key}'")))?;

		let params = toml::Value::Table(table.clone());

		match key.as_str() {
			"search" => {
				let path_template_str = value.try_into::<String>().map_err(serde::de::Error::custom)?;
				let mut params = params.as_table().unwrap().clone();
				params.insert("path".to_string(), path_template_str.into());
				let builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;

				Ok(StageBuilder::Search(builder))
			}
			"compose" => {
				let rule_to_compose = value.try_into::<PathBuf>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Compose(rule_to_compose))
			}
			"flatten" => {
				let value = value.try_into::<bool>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Flatten(value))
			}
			"filter" | "select" | "action" | "group-by" | "sort-by" => {
				let component_type = value
					.as_str()
					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{key}'")))?;

				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
				let component_value = toml::Value::Table(component_table);

				match key.as_str() {
					"filter" => Ok(StageBuilder::Filter(
						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"select" => Ok(StageBuilder::Select(
						Box::<dyn Selector>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"action" => Ok(StageBuilder::Action(
						Box::<dyn ActionBuilder>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"group-by" => Ok(StageBuilder::Grouper(
						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"sort-by" => Ok(StageBuilder::Sorter(
						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					_ => unreachable!(),
				}
			}
			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{other}'"))),
		}
	}
}

```

`organizer/organize-core\src\selector.rs`:

```rs
use crate::{batch::Batch, errors::Error};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Selector);
dyn_eq::eq_trait_object!(Selector);

/// A trait for any component that selects a subset of files from a batch based on
/// positional or quantitative criteria (e.g., first, last, random sample).
#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Selector: DynEq + DynClone + Sync + Send + Debug {
	async fn select(&self, batch: &Batch) -> Result<Batch, Error>;
}

```

`organizer/organize-core\src\sorter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

use crate::resource::Resource;

dyn_clone::clone_trait_object!(Sorter);
dyn_eq::eq_trait_object!(Sorter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Sorter: DynEq + DynClone + Sync + Send + Debug {
	/// Sorts a slice of resources in-place.
	async fn sort(&self, files: &mut [Arc<Resource>]);
}

```

`organizer/organize-core\src\stdx\mod.rs`:

```rs
pub mod path;

```

`organizer/organize-core\src\stdx\path.rs`:

```rs
#[cfg(target_family = "windows")]
use std::path::Path;
use std::{ffi::OsStr, path::PathBuf, sync::Arc};

use async_trait::async_trait;

use crate::{context::ExecutionContext, folder::Location, resource::Resource};

#[async_trait]
pub trait PathExt {
	type HiddenError;
	fn is_hidden(&self) -> Result<bool, Self::HiddenError>;
	fn expand_user(self) -> PathBuf;
	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource>;
}

#[async_trait]
impl<T: AsRef<Path> + Sync + Send> PathExt for T {
	#[cfg(target_family = "unix")]
	type HiddenError = std::convert::Infallible;
	#[cfg(target_family = "windows")]
	type HiddenError = std::io::Error;

	fn expand_user(self) -> PathBuf {
		let path = self.as_ref();
		let mut components = path.components();
		if let Some(component) = components.next() {
			if component.as_os_str() == OsStr::new("~") {
				let mut path = dirs::home_dir().expect("could not find home directory");
				path.extend(components);
				return path;
			}
		}
		path.to_path_buf()
	}

	#[cfg(target_family = "unix")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		match self.file_name() {
			None => Ok(false),
			Some(filename) => Ok(filename.to_string_lossy().starts_with('.')),
		}
	}

	#[cfg(target_family = "windows")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		use std::{fs, os::windows::prelude::*};
		let metadata = fs::metadata(self)?;
		let attributes = metadata.file_attributes();
		Ok((attributes & 0x2) > 0)
	}

	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource> {
		ctx.services
			.fs
			.resources
			.get_with(self.as_ref().to_path_buf(), async move {
				Arc::new(Resource::new(&self.as_ref().to_path_buf(), location))
			})
			.await
	}
}

#[cfg(test)]
mod tests {

	use super::*;

	#[cfg(target_family = "unix")]
	#[test]
	fn check_hidden() {
		use super::*;
		let path = Path::new("/home/user/.testfile");
		assert!(path.is_hidden().unwrap())
	}

	#[cfg(target_family = "windows")]
	#[test]
	fn not_hidden() {
		use tempfile::NamedTempFile;

		use super::*;
		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		assert!(!path.is_hidden().unwrap());
	}

	#[test]
	#[cfg(target_family = "windows")]
	fn check_hidden() {
		use super::*;
		use tempfile::NamedTempFile;

		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		// Use the `attrib` command on Windows to set the hidden attribute.
		let status = std::process::Command::new("attrib")
			.arg("+h")
			.arg(path.as_os_str())
			.status()
			.expect("failed to execute attrib command");
		assert!(status.success(), "attrib command failed");
		assert!(path.is_hidden().unwrap());
	}

	#[test]
	fn invalid_tilde() {
		let original = dirs::home_dir().unwrap().join("Documents~");
		assert_eq!(original.clone().expand_user(), original)
	}

	#[test]
	fn user_tilde() {
		let original = "~/Documents";
		let expected = dirs::home_dir().unwrap().join("Documents");
		assert_eq!(original.expand_user(), expected)
	}
}

```

`organizer/organize-core\src\storage.rs`:

```rs
use crate::{context::ExecutionContext, errors::Error, folder::Location, resource::Resource};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{
	fmt::Debug,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

dyn_clone::clone_trait_object!(StorageProvider);
dyn_eq::eq_trait_object!(StorageProvider);

#[async_trait]
#[typetag::serde(tag = "provider")]
/// A trait for any component that can provide a list of files to be processed.
/// This could be a local folder, an S3 bucket, an SFTP connection, etc.
pub trait StorageProvider: DynEq + DynClone + Sync + Send + Debug {
	fn home(&self) -> Result<PathBuf, Error>;
	fn prefix(&self) -> &'static str;
	async fn metadata(&self, path: &Path) -> Result<Metadata, Error>;
	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error>;
	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error>;
	async fn write(&self, path: &Path, content: &[u8]) -> Result<()>;
	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error>;
	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn delete(&self, path: &Path) -> Result<(), Error>;
	async fn download(&self, from: &Path) -> Result<PathBuf, Error>;
	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
}

```

`organizer/organize-core\src\templates\accessor.rs`:

```rs
use crate::{context::ExecutionContext, templates::value::Value};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Accessor);
dyn_eq::eq_trait_object!(Accessor);

/// Represents a compiled and type-safe property path.
///
/// An Accessor is a function object that encapsulates the logic to retrieve a
/// specific value from a given execution context. This is the output of the
/// template compilation process.
#[async_trait]
pub trait Accessor: DynEq + DynClone + Sync + Send + Debug {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value>;
}

```

`organizer/organize-core\src\templates\compiler.rs`:

```rs
use crate::{
	errors::Error,
	parser::ast::{Expression, Segment, AST},
	templates::{
		accessor::Accessor,
		registry::SchemaRegistry,
		template::{Template, TemplatePart},
	},
};
use anyhow::Result;

/// The central compiler for the template system.
/// It uses a SchemaRegistry to validate variables and a full parser to build the template.
#[derive(Debug, Clone)]
pub struct TemplateCompiler {
	schema: SchemaRegistry,
}

impl Default for TemplateCompiler {
	fn default() -> Self {
		Self::new()
	}
}

impl TemplateCompiler {
	/// Creates a new compiler with a default schema registry that discovers
	/// all registered static variable providers.
	pub fn new() -> Self {
		Self {
			schema: SchemaRegistry::new(),
		}
	}

	/// Creates a compiler from a fully-built schema (e.g., one that includes
	/// user-defined variables from a config file).
	pub fn from_schema(schema: SchemaRegistry) -> Self {
		Self { schema }
	}

	/// Compiles a raw string into an executable Template object using your parser.
	pub fn compile_template(&self, raw_template: &str) -> Result<Template, Error> {
		// Stage 1: Parse the raw string into an Abstract Syntax Tree (AST)
		// using your provided `AST::parse` method.
		let ast = AST::parse(raw_template)?;
		let mut parts = Vec::new();

		// Stage 2: Walk the AST to build the final, executable Template object.
		for segment in ast.segments {
			match segment {
				Segment::Literal(text) => {
					parts.push(TemplatePart::Static(text));
				}
				Segment::Expression(expr) => {
					let accessor = self.build_accessor(expr)?;
					parts.push(TemplatePart::Dynamic(accessor));
				}
			}
		}

		Ok(Template {
			parts,
			text: raw_template.to_string(),
		})
	}

	/// Builds a type-safe accessor from a parsed expression AST node.
	/// This is the bridge between your parser and the execution engine.
	fn build_accessor(&self, expr: Expression) -> Result<Box<dyn Accessor>, Error> {
		match expr {
			Expression::Variable(parts) => {
				// We use the existing SchemaRegistry to validate the path and get the accessor.
				let parts_str: Vec<&str> = parts.iter().map(AsRef::as_ref).collect();
				self.schema.parse_property_chain(&parts_str)
			}
		}
	}
}

```

`organizer/organize-core\src\templates\engine.rs`:

```rs
use std::env::VarError;

use thiserror::Error;


#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Templater;

#[derive(Error, Debug)]
pub enum TemplateError {
	#[error("variable '{variable}' (fields={fields:?}) cannot be resolved.")]
	UndefinedVariable {
		variable: String,
		fields: Vec<String>,
		#[source]
		source: VarError,
	},

	#[error("empty template")]
	EmptyTemplate,

	#[error("variable '{variable}' could not be deserialized. It may be missing fields or they may be wrong.")]
	DeserializationError {
		#[source]
		source: serde_json::Error,
		variable: String,
		fields: Vec<String>,
	},

	#[error("variable {variable} does not accept any fields, but received {fields:?}")]
	FieldsNotSupported { variable: String, fields: Vec<String> },

	#[error("invalid variable ({variable}): it requires {missing_piece} to be in scope")]
	InvalidContext { missing_piece: String, variable: String },

	#[error("variable '{variable}' does not support a '{field}' subfield")]
	InvalidField { variable: String, field: String },

	#[error("variable '{variable}' requires a field (one of: {fields})")]
	MissingField { variable: String, fields: String },

	#[error("unknown variable '{{{{ {0} }}}}'")]
	UnknownVariable(String),

	#[error("variable '{variable}' requires one of the following fields: {fields:?}")]
	RequiredField { variable: String, fields: Vec<String> },
}

// #[cfg(test)]
// mod tests {
// 	use std::convert::{TryFrom, TryInto};

// 	use super::*;
// 	use crate::{config::{context::RunServices, variables::simple::SimpleVariable}, resource::Resource};

// 	#[test]
// 	fn render_template_not_present_in_engine() {
// 		let engine = Templater::default();
// 		let template = Template::try_from("Hello, {{ name }}!").unwrap();
// 		let context = Context::new(ctx)
// 		let mut context = engine.context().build(&engine);
// 		context.insert("name", "Andrés");
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}

// 	#[test]
// 	fn render_template_present_in_engine() {
// 		let mut engine = Templater::default();
// 		let template = Template::try_from("This is a stored template.").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("This is a stored template.".to_string()));
// 	}

// 	#[test]
// 	fn render_with_simple_variable() {
// 		let var = SimpleVariable {
// 			name: "location".into(),
// 			value: "world".try_into().unwrap(),
// 		};
// 		let mut engine = Templater::new(&vec![Box::new(var)]);
// 		let template = Template::try_from("Hello, {{ location }}!").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("Hello, world!".to_string()));
// 	}

// 	#[test]
// 	fn render_with_path_context() {
// 		let mut engine = Templater::default();
// 		let resource = Resource::new_tmp("test.txt");
// 		let template = Template::try_from("The path is {{ path | stem }}").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().path(resource.path().to_path_buf()).build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("The path is test".to_string()));
// 	}

// 	#[test]
// 	fn render_invalid_template_returns_none() {
// 		let engine = Templater::default();
// 		// Invalid syntax: `{%` instead of `{{`
// 		let template = Template::try_from("Hello, {% name }}!").unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}
// }

```

`organizer/organize-core\src\templates\mod.rs`:

```rs
pub mod accessor;
pub mod compiler;
pub mod engine;
pub mod filter;
pub mod registry;
pub mod schema;
pub mod template;
pub mod value;
pub mod variable;

```

`organizer/organize-core\src\templates\registry.rs`:

```rs
use std::collections::HashMap;

use crate::{
	errors::Error,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		variable::VariableInventory,
	},
};

/// The central schema registry and compiler for template variables.
///
/// It discovers all variable providers at startup and uses their schemas
/// to parse and validate property chains.
#[derive(Clone, Debug)]
pub struct SchemaRegistry {
	/// A map of all discovered static schemas for fast lookups by name.
	root_properties: HashMap<&'static str, Property>,
}

impl Default for SchemaRegistry {
	fn default() -> Self {
		Self::new()
	}
}

impl SchemaRegistry {
	/// Creates a new registry by discovering all registered `Variable` providers
	/// via the `inventory` crate.
	pub fn new() -> Self {
		let root_properties = inventory::iter::<VariableInventory>
			.into_iter()
			.map(|inv| {
				let schema = inv.provider.schema();
				// The key is the static name of the variable (e.g., "file").
				(schema.name, schema)
			})
			.collect();

		Self { root_properties }
	}

	/// Parses a property chain against the compiled schema to get an Accessor.
	pub fn parse_property_chain(&self, parts: &[&str]) -> Result<Box<dyn Accessor>, Error> {
		if parts.is_empty() {
			return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(
				"Property chain cannot be empty.".to_string(),
			)));
		}

		let root_part = parts[0];
		let mut current_prop = self.root_properties.get(root_part).ok_or_else(|| {
			let valid_options: Vec<_> = self.root_properties.keys().collect();
			Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Invalid root variable '{root_part}'. Valid options are: {valid_options:?}"
			)))
		})?;

		// Traverse the rest of the chain.
		for (i, &part) in parts.iter().skip(1).enumerate() {
			match &current_prop.node {
				SchemaNode::Object(properties) => {
					current_prop = properties.iter().find(|p| p.name == part).ok_or_else(|| {
						let valid_options: Vec<_> = properties.iter().map(|p| p.name).collect();
						Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Invalid property '{}' at index {}. Valid options for '{}' are: {:?}",
							part,
							i + 1,
							parts[..i + 1].join("."),
							valid_options
						)))
					})?;
				}
				SchemaNode::DynamicMap(constructor) => {
					if i + 2 < parts.len() {
						return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Cannot access properties on a dynamic value. Chain has too many parts after key '{}' in '{}'.",
							part,
							parts.join(".")
						))));
					}
					// The chain ends here. Call the constructor with the key.
					return Ok(constructor(part));
				}
				SchemaNode::Terminal(_) => {
					return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
						"Cannot access property '{}' on a terminal value at '{}'.",
						part,
						parts[..i + 1].join(".")
					))));
				}
			}
		}

		// After the loop, the final node must be a Terminal.
		match &current_prop.node {
			SchemaNode::Terminal(constructor) => Ok(constructor()),
			_ => Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Incomplete property chain '{}'. It points to an object, not a final value.",
				parts.join(".")
			)))),
		}
	}
}

```

`organizer/organize-core\src\templates\schema.rs`:

```rs
use crate::templates::accessor::Accessor;
use std::{fmt::Debug, sync::Arc};

#[derive(Clone)]
pub enum SchemaNode {
	/// A terminal node that creates a specific, type-safe Accessor.
	Terminal(Arc<dyn Fn() -> Box<dyn Accessor> + Send + Sync>),
	/// An object node with a fixed, known set of sub-properties.
	Object(Vec<Property>),
	/// A map node where sub-properties are dynamic keys.
	DynamicMap(Arc<dyn Fn(&str) -> Box<dyn Accessor> + Send + Sync>),
}

#[derive(Clone)]
pub struct Property {
	pub name: &'static str,
	pub node: SchemaNode,
}

impl Debug for SchemaNode {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			SchemaNode::Terminal(_) => f.debug_tuple("Terminal").field(&"<closure>").finish(),
			SchemaNode::Object(properties) => f.debug_tuple("Object").field(properties).finish(),
			SchemaNode::DynamicMap(_) => f.debug_tuple("DynamicMap").field(&"<closure>").finish(),
		}
	}
}

// Manual `Debug` implementation for `Property`
impl Debug for Property {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("Property")
			.field("name", &self.name)
			.field("node", &self.node)
			.finish()
	}
}

```

`organizer/organize-core\src\templates\template.rs`:

```rs
use serde::{Deserialize, Serialize};

use crate::{context::ExecutionContext, errors::Error, templates::accessor::Accessor};

#[derive(Debug, Eq, PartialEq, Clone)]
pub enum TemplatePart {
	Static(String),
	Dynamic(Box<dyn Accessor>),
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct TemplateString(pub String);

impl std::ops::Deref for TemplateString {
	type Target = String;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]
pub struct Template {
	pub text: String,
	#[serde(skip)]
	pub parts: Vec<TemplatePart>,
}

impl Template {
	pub async fn render(&self, ctx: &ExecutionContext<'_>) -> Result<String, Error> {
		let mut output = String::new();
		for part in &self.parts {
			match part {
				TemplatePart::Static(s) => output.push_str(s),
				TemplatePart::Dynamic(accessor) => {
					let value = accessor.get(ctx).await?;
					output.push_str(&value.to_string());
				}
			}
		}
		Ok(output)
	}
}

```

`organizer/organize-core\src\templates\value.rs`:

```rs
use std::fmt;

/// Represents any possible value that can be retrieved from a template variable.
/// This enum provides type safety for the data flowing through the template engine.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
	String(String),
	OptionString(Option<String>),
	// Add other types as needed, e.g., Int(i64), Bool(bool)
	Null,
}

impl fmt::Display for Value {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			Value::String(s) => write!(f, "{s}"),
			Value::OptionString(Some(s)) => write!(f, "{s}"),
			Value::OptionString(None) | Value::Null => Ok(()), // Render None/Null as empty string
		}
	}
}

```

`organizer/organize-core\src\templates\variable.rs`:

```rs
use crate::templates::schema::Property;

/// The plugin interface for a static variable provider.
///
/// Any struct implementing this trait can be automatically discovered and
/// integrated into the template engine's schema. This trait is intended for
/// built-in variables with fixed schemas, like `file` or `env`.
pub trait StatelessVariable: Sync + Send {
	/// Returns the canonical name of the root variable (e.g., "file", "env").
	fn name(&self) -> &'static str;

	/// Returns the schema for this variable, defining its properties and accessors.
	fn schema(&self) -> Property;
}

/// The collectible struct for the `inventory` crate.
/// It holds a static reference to an object that implements our `Variable` trait.
pub struct VariableInventory {
	pub provider: &'static (dyn StatelessVariable + Sync),
}

// Declare the global collection for automatic registration of static variable providers.
inventory::collect!(VariableInventory);

```

`organizer/organize-core\src\utils\backup.rs`:

```rs
use std::path::PathBuf;

use crate::{context::ExecutionContext, errors::Error};
use anyhow::Result;
use dirs;
use serde::{Deserialize, Serialize}; // Import the dirs crate
use tokio::fs;
use uuid::Uuid; // Import Uuid for generating unique IDs // Import chrono for timestamps (already in Cargo.toml)

/// Determines the base directory for all backups.
/// This will be inside the platform-specific local data directory,
/// in a subdirectory named after the project, and then a "backups" folder.
fn get_backup_base_dir(ctx: &ExecutionContext<'_>) -> Result<PathBuf, Error> {
	let project_name = env!("CARGO_PKG_NAME");
	let base_dir = dirs::data_local_dir().expect("Could not determine platform-specific local data directory for backups.");
	let dir = base_dir.join(project_name).join("backups");
	Ok(dir)
}

#[derive(Default, Clone, Deserialize, Serialize, PartialEq, Eq, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BackupLocation {
	#[default]
	System,
	Root,
	Custom(PathBuf),
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Backup(pub PathBuf);

impl std::ops::Deref for Backup {
	type Target = PathBuf;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

impl Backup {
	pub async fn new(ctx: &ExecutionContext<'_>) -> Result<Self, Error> {
		let dir = get_backup_base_dir(ctx)?;

		// Loop until a unique UUID is found for the backup filename
		let path = loop {
			let new_uuid = Uuid::new_v4().to_string();
			let proposed_path = dir.join(&new_uuid);

			if !tokio::fs::try_exists(&proposed_path).await? {
				break proposed_path;
			}
		};
		Ok(Self(path))
	}

	pub async fn persist(&self, ctx: &ExecutionContext<'_>) -> Result<(), Error> {
		let parent = self.0.parent().unwrap();
		fs::create_dir_all(parent).await?;
		let source = ctx.scope.resource()?;

		match fs::hard_link(source.as_path(), self.0.as_path()).await {
			Ok(()) => {
				tracing::debug!("Created hard link backup for {}", source.as_path().display());
				Ok(())
			}
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				tracing::warn!(
					"Backup for {} is on a different filesystem. Falling back to a full copy.",
					ctx.scope.resource()?.as_path().display()
				);
				fs::copy(ctx.scope.resource()?.as_path(), self.0.as_path()).await?;
				Ok(())
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\utils\mod.rs`:

```rs
pub mod backup;

```

`organizer/rules\test.rule.toml`:

```toml
[[stage]]
search = '/Users/cabero/Downloads/'
max_depth = 1

[[stage]]
action = "echo"
message = "{{ env.HOME }}"

```

`organizer/rustfmt.toml`:

```toml
unstable_features = true
imports_layout = "HorizontalVertical"
merge_imports = true
max_width = 150
chain_width = 80
overflow_delimited_expr = true
reorder_impl_items = true
reorder_imports = true
reorder_modules = true
condense_wildcard_suffixes = true
format_strings = true
hard_tabs = true
merge_derives = true
normalize_comments = true

```
```

`organizer/organize-cli\Cargo.toml`:

```toml
[package]
name = "organize-cli"
version = "0.1.0"
edition = "2024"

[[bin]]
name = "organize"
path = "src/main.rs"

[dependencies]
async-trait = "0.1.88"
tokio = { version = "1.45.1", features = ["full"] }
organize-sdk = { path = "../organize-sdk" }
organize-std = { path = "../organize-std" }
lazy_static = "1.5.0"
chrono = "0.4.41"
anyhow.workspace = true
clap.workspace = true
colored = "3.0.0"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = "0.3.19"
dialoguer.workspace = true
notify = "8.0.0"


```

`organizer/organize-cli\src\cmd\edit.rs`:

```rs
use std::{
	env,
	path::Path,
	process::{self, ExitStatus},
};

use anyhow::{Context, Result};
use async_trait::async_trait;
use clap::Parser;
use organize_sdk::config::Config;

use crate::cmd::Cmd;

#[derive(Parser, Debug)]
pub struct Edit;

#[async_trait]
impl Cmd for Edit {
	async fn run(self) -> Result<()> {
		Self::edit(Config::resolve_path(None)).map(|_| ())
	}
}

impl Edit {
	pub(crate) fn edit<T: AsRef<Path>>(path: T) -> Result<ExitStatus> {
		env::var("EDITOR").map(|editor| {
			process::Command::new(&editor)
				.arg(path.as_ref())
				.spawn()
				.context(editor)?
				.wait()
				.context("command wasn't running")
		})?
	}
}

```

`organizer/organize-cli\src\cmd\logs.rs`:

```rs
use chrono::Local;
use clap::ValueEnum;
use std::path::PathBuf;
use tracing::Level;
use tracing_appender::non_blocking::WorkerGuard; // Import the guard type
use tracing_subscriber::{
	Layer,
	filter::LevelFilter,
	fmt::{self},
	layer::SubscriberExt,
	util::SubscriberInitExt,
};

#[derive(ValueEnum, Clone, Debug, Default)]
pub enum LogLevel {
	#[default]
	Info,
	Debug,
	Trace,
	Warn,
	Error,
}

// Implement a conversion from our CLI enum to the `tracing` LevelFilter.
impl From<LogLevel> for Level {
	fn from(level: LogLevel) -> Self {
		match level {
			LogLevel::Info => Level::INFO,
			LogLevel::Debug => Level::DEBUG,
			LogLevel::Trace => Level::TRACE,
			LogLevel::Warn => Level::WARN,
			LogLevel::Error => Level::ERROR,
		}
	}
}

/// Initializes the logging system and returns a guard that must be kept in scope.
pub fn init(level: LogLevel) -> WorkerGuard {
	// 1. Determine the destination directory for logs.
	let logs_dir = PathBuf::from(".").join("logs"); // A hidden folder is a common convention

	// 2. Create a non-blocking file appender for the current run.
	// We add milliseconds to the timestamp to increase uniqueness.
	let timestamp = Local::now().format("%Y-%m-%d-%H-%M-%S%.3f");
	let log_file = format!("{timestamp}.log");
	let file_appender = tracing_appender::rolling::never(&logs_dir, log_file);
	let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);

	// 3. Define the two logging layers.
	let file_layer = fmt::layer()
		.with_writer(non_blocking_writer)
		.with_ansi(false)
		.pretty()
		.with_filter(LevelFilter::TRACE);

	let stdout_layer = fmt::layer()
		.with_writer(std::io::stdout)
		.with_filter(LevelFilter::from_level(level.into()));

	// 4. Combine the layers and initialize the global subscriber.
	tracing_subscriber::registry().with(file_layer).with(stdout_layer).init();

	tracing::debug!("Logging initialized. Log file in: {}", logs_dir.display());

	// 5. Return the guard to the caller.
	guard
}

```

`organizer/organize-cli\src\cmd\mod.rs`:

```rs
use crate::cmd::{logs::LogLevel, run::Run};
use async_trait::async_trait;
use clap::{Parser, Subcommand};
use undo::Undo;

mod logs;
mod run;
mod undo;

#[derive(Subcommand)]
enum Command {
	Run(Run),
	Undo(Undo),
}

#[derive(Parser)]
#[command(about, author, version)]
pub struct App {
	#[command(subcommand)]
	command: Command,
	#[arg(long, value_enum, global = true, default_value_t = LogLevel::Info)]
	pub log_level: LogLevel,
}

#[async_trait]
pub trait Cmd {
	async fn run(self) -> anyhow::Result<()>;
}

#[async_trait]
impl Cmd for App {
	async fn run(self) -> anyhow::Result<()> {
		let _guard = logs::init(self.log_level);
		match self.command {
			Command::Run(cmd) => cmd.run().await,
			Command::Undo(undo) => undo.run().await,
		}
	}
}

```

`organizer/organize-cli\src\cmd\run.rs`:

```rs
use std::path::PathBuf;

use anyhow::{anyhow, Result};
use async_trait::async_trait;
use clap::{Parser, ValueHint};
use organize_sdk::{context::settings::RunSettings, engine::Engine};

use crate::Cmd;

#[derive(Parser, Debug)]
pub struct Run {
	#[arg(long, short = 'r', value_hint = ValueHint::FilePath)]
	rule: PathBuf,
	#[arg(long, default_value_t = false)]
	no_dry_run: bool,
	#[arg(last = true, value_parser = parse_key_val)]
	args: Vec<(String, String)>,
}

#[async_trait]
impl Cmd for Run {
	async fn run(mut self) -> Result<()> {
		let settings = RunSettings {
			dry_run: !self.no_dry_run,
			args: self.args.into_iter().collect(),
		};
		let engine = Engine::new(&self.rule, settings).await?;
		engine.run().await?;

		Ok(())
	}
}

fn parse_key_val(s: &str) -> Result<(String, String)> {
	if s.starts_with("--") {
		return Err(anyhow!("invalid argument: {s}, key-value pairs should not start with --"));
	}
	s.split_once('=')
		.map(|(key, value)| (key.to_string(), value.to_string()))
		.ok_or_else(|| anyhow!("invalid key-value pair, please use the format `key=value`"))
}

```

`organizer/organize-cli\src\cmd\undo.rs`:

```rs
use std::{collections::HashMap, error::Error};

use anyhow::{Result, anyhow};
use async_trait::async_trait;
use clap::Parser;
use organize_sdk::{
	context::{services::history::Journal, settings::RunSettings},
	plugins::action::{Input, UndoConflict, UndoError, UndoSettings},
};

use super::Cmd;

#[derive(Parser, Debug)]
#[command(author, version, about)]
pub struct Undo {
	/// The ID of the session to undo.
	#[arg(long, conflicts_with = "last_session")]
	session_id: Option<i64>,

	/// Use the most recent session.
	#[arg(long, default_value_t = true)]
	last_session: bool,

	// If there is a name collision conflict while undoing, ask me what to do
	#[arg(long, short = 'i', conflicts_with_all = &["on_conflict"])]
	interactive: bool,

	#[arg(long, value_enum, default_value_t = UndoConflict::Abort)]
	on_conflict: UndoConflict,
}

#[async_trait]
impl Cmd for Undo {
	async fn run(self) -> Result<()> {
		let settings = RunSettings { dry_run: false, args: HashMap::new() };
		let journal = Journal::new(&settings).await?; // Assumes a simple ::new()

		let settings = UndoSettings {
			interactive: self.interactive,
			on_conflict: self.on_conflict,
		};
		let target_id = if self.last_session {
			journal
				.get_last_session_id()
				.await?
				.ok_or_else(|| anyhow!("No sessions found in the journal."))?
		} else {
			self.session_id.unwrap()
		};

		let transactions = journal.get_pending_transactions_for_session(target_id).await?;

		if transactions.is_empty() {
			println!("No pending operations to undo for session {target_id}.");
			return Ok(());
		}

		for transaction in &transactions {
			for undo_op in &transaction.receipt.undo {
				if undo_op.verify().await.is_ok() {
					match undo_op.undo(&settings).await {
						Ok(_) => {
							journal.update_transaction_undo_status(transaction.id, "DONE").await?;
							tracing::info!("Transaction {} undone.", transaction.id);
						}
						Err(e) => {
							if let Some(source) = e.source().and_then(|s| s.downcast_ref::<UndoError>())
								&& matches!(source, UndoError::Abort)
							{
								let inputs = transaction
									.receipt
									.inputs
									.iter()
									.map(|input: &Input| match input {
										Input::Processed(resource) => resource.as_path().to_string_lossy().to_string(),
										Input::Skipped(resource) => resource.as_path().to_string_lossy().to_string(),
									})
									.collect::<Vec<String>>()
									.join("\n -");

								eprintln!(
									"There was a conflict undoing transaction {}.\nOne of the following files may already exist: \n - {}\nAborting \
									 undo process. Run in interactive mode or choose a default conflict resolution strategy. You can also move the \
									 file manually.",
									transaction.id, inputs
								);
								return Ok(());
							}

							eprintln!("Failed to undo transaction {}: {}", transaction.id, e);
							return Err(e.into());
						}
					}
				}
			}
		}

		Ok(())
	}
}

```

`organizer/organize-cli\src\main.rs`:

```rs
use crate::cmd::{App, Cmd};
use anyhow::Result;
use clap::Parser;
mod cmd;
#[allow(unused_imports)]
use organize_std::*;

#[tokio::main]
async fn main() -> Result<()> {
	let app: App = App::parse();
	app.run().await
}

```

`organizer/organize-sdk\Cargo.toml`:

```toml
[package]
name = "organize-sdk"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2021"
description = "The core SDK for the organize project."
repository = "https://github.com/cbr9/organizer"

[dependencies]
anyhow = { workspace = true }
async-trait = "0.1.88"
clap = { workspace = true }
dashmap = "6.1.0"
dialoguer = { workspace = true }
dirs = { workspace = true }
dotenvy = "0.15.7"
dyn-clone = { workspace = true }
dyn-eq = { workspace = true }
moka = { version = "0.12.10", features = ["future"] }
serde = { workspace = true }
serde_json = "1.0.140"
sqlx = { version = "0.8.6", features = ["chrono", "runtime-tokio", "sqlite"] }
strum = { workspace = true }
thiserror = "2.0.12"
typetag = { workspace = true }
tokio = { version = "1.45.1", features = ["full"] }
libc = "0.2.174"
tracing = "0.1.41"
futures = "0.3.31"
tempfile = "3.20.0"
sha2 = "0.10.9"
uuid = "1.17.0"
mime_guess = "2.0.5"
url = "2.5.4"
toml = "0.8.23"
pest = "2.8.1"
pest_derive = "2.8.1"
glob = "0.3.1"
inventory = "0.3.20"
ssh2 = "0.9.5"
russh = "0.53.0"
russh-sftp = "2.1.1"
deadpool = "0.12.2"

```

`organizer/organize-sdk\migrations\20250623125855_initial_schema.sql`:

```sql
CREATE TABLE IF NOT EXISTS sessions (
    id              INTEGER PRIMARY KEY,
    start_time      INTEGER NOT NULL,
    end_time        INTEGER,
    status          TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS transactions (
    id              INTEGER PRIMARY KEY,
    session_id      INTEGER NOT NULL,
    type               TEXT NOT NULL,
    action             TEXT NOT NULL,
    receipt            TEXT NOT NULL, 
    timestamp       INTEGER NOT NULL,
    undo_status TEXT NOT NULL DEFAULT "PENDING",
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);


```

`organizer/organize-sdk\src\context\mod.rs`:

```rs
pub mod scope;
pub mod services;
pub mod settings;

use crate::{
    context::{scope::ExecutionScope, services::RunServices, settings::RunSettings},
};

/// The top-level context object, composed of the three distinct categories of information.
#[derive(Clone, Debug)]
pub struct ExecutionContext<'a> {
	pub services: &'a RunServices,
	pub scope: ExecutionScope<'a>,
	pub settings: &'a RunSettings,
}

impl<'a> ExecutionContext<'a> {
	pub fn with_scope(&'a self, scope: ExecutionScope<'a>) -> ExecutionContext<'a> {
		Self {
			services: self.services,
			scope,
			settings: self.settings,
		}
	}
}
```

`organizer/organize-sdk\src\context\scope.rs`:

```rs
use crate::{
	engine::{batch::Batch, rule::RuleMetadata},
	location::Location,
	resource::Resource,
};
use anyhow::Result;
use std::{
	path::{Path, PathBuf},
	sync::Arc,
};

#[derive(Debug, Clone)]
pub enum ExecutionScope<'a> {
	Rule(RuleScope),
	Search(SearchScope<'a>),
	Resource(ResourceScope),
	Batch(BatchScope<'a>),
	Build(BuildScope),
	Blank,
}

impl<'a> ExecutionScope<'a> {
	pub fn new_rule_scope(rule: Arc<RuleMetadata>) -> ExecutionScope<'a> {
		ExecutionScope::Rule(RuleScope { rule })
	}

	pub fn new_location_scope(rule: Arc<RuleMetadata>, location: &'a Location) -> ExecutionScope<'a> {
		ExecutionScope::Search(SearchScope { rule, location })
	}

	pub fn new_resource_scope(rule: Arc<RuleMetadata>, resource: Arc<Resource>) -> ExecutionScope<'a> {
		ExecutionScope::Resource(ResourceScope { rule, resource })
	}

	pub fn new_batch_scope(rule: Arc<RuleMetadata>, batch: &'a Batch) -> ExecutionScope<'a> {
		ExecutionScope::Batch(BatchScope { rule, batch })
	}

	pub fn new_build_scope(root: &Path) -> ExecutionScope<'a> {
		ExecutionScope::Build(BuildScope { root: root.to_path_buf() })
	}

	pub fn rule(&self) -> Result<Arc<RuleMetadata>> {
		match self {
			ExecutionScope::Rule(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Batch(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Search(scope) => Ok(scope.rule.clone()),
			_ => anyhow::bail!("Rule not in scope"),
		}
	}

	pub fn resource(&self) -> Result<Arc<Resource>> {
		match self {
			ExecutionScope::Resource(scope) => Ok(scope.resource.clone()),
			_ => anyhow::bail!("Resource not in scope"),
		}
	}

	pub fn batch(&self) -> Result<&'a Batch> {
		match self {
			ExecutionScope::Batch(scope) => Ok(scope.batch),
			_ => anyhow::bail!("Batch not in scope"),
		}
	}
}

#[derive(Debug, Clone)]
pub struct RuleScope {
	pub rule: Arc<RuleMetadata>,
}
#[derive(Debug, Clone)]
pub struct SearchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub location: &'a Location,
}
#[derive(Debug, Clone)]
pub struct ResourceScope {
	pub rule: Arc<RuleMetadata>,
	pub resource: Arc<Resource>,
}
#[derive(Debug, Clone)]
pub struct BatchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub batch: &'a Batch,
}

#[derive(Debug, Clone)]
pub struct BuildScope {
	pub root: PathBuf,
}

```

`organizer/organize-sdk\src\context\services\fs\backup.rs`:

```rs
use std::path::PathBuf;

use crate::{context::ExecutionContext, error::Error};
use anyhow::Result;
use dirs;
use serde::{Deserialize, Serialize}; // Import the dirs crate
use tokio::fs;
use uuid::Uuid; // Import Uuid for generating unique IDs // Import chrono for timestamps (already in Cargo.toml)

/// Determines the base directory for all backups.
/// This will be inside the platform-specific local data directory,
/// in a subdirectory named after the project, and then a "backups" folder.
fn get_backup_base_dir(_ctx: &ExecutionContext<'_>) -> Result<PathBuf, Error> {
	let project_name = env!("CARGO_PKG_NAME");
	let base_dir = dirs::data_local_dir().expect("Could not determine platform-specific local data directory for backups.");
	let dir = base_dir.join(project_name).join("backups");
	Ok(dir)
}

#[derive(Default, Clone, Deserialize, Serialize, PartialEq, Eq, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BackupLocation {
	#[default]
	System,
	Root,
	Custom(PathBuf),
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Backup(pub PathBuf);

impl std::ops::Deref for Backup {
	type Target = PathBuf;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

impl Backup {
	pub async fn new(ctx: &ExecutionContext<'_>) -> Result<Self, Error> {
		let dir = get_backup_base_dir(ctx)?;

		// Loop until a unique UUID is found for the backup filename
		let path = loop {
			let new_uuid = Uuid::new_v4().to_string();
			let proposed_path = dir.join(&new_uuid);

			if !tokio::fs::try_exists(&proposed_path).await? {
				break proposed_path;
			}
		};
		Ok(Self(path))
	}

	pub async fn persist(&self, ctx: &ExecutionContext<'_>) -> Result<(), Error> {
		let parent = self.0.parent().unwrap();
		fs::create_dir_all(parent).await?;
		let source = ctx.scope.resource()?;

		match fs::hard_link(source.as_path(), self.0.as_path()).await {
			Ok(()) => {
				tracing::debug!("Created hard link backup for {}", source.as_path().display());
				Ok(())
			}
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				tracing::warn!(
					"Backup for {} is on a different filesystem. Falling back to a full copy.",
					ctx.scope.resource()?.as_path().display()
				);
				fs::copy(ctx.scope.resource()?.as_path(), self.0.as_path()).await?;
				Ok(())
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-sdk\src\context\services\fs\locker.rs`:

```rs
use crate::{
	context::{services::fs::manager::Destination, ExecutionContext},
	engine::ConflictResolution,
	error::Error,
};
use anyhow::Result;
use dashmap::DashSet;
use std::{future::Future, path::PathBuf, sync::Arc};

#[derive(Debug, Clone, Default)]
pub struct Locker {
	active_paths: Arc<DashSet<PathBuf>>,
}

impl Locker {
	pub async fn with_locked_destination<F, Fut, T>(
		&self,
		ctx: &ExecutionContext<'_>,
		destination: &Destination,
		strategy: &ConflictResolution,
		action: F,
	) -> Result<Option<T>, Error>
	where
		F: FnOnce(PathBuf) -> Fut,
		Fut: Future<Output = Result<T, Error>>,
	{
		let mut path = destination.resolve(ctx).await?;
		let mut n = 1;

		let reserved = loop {
			if self.active_paths.contains(&path) {
				match strategy {
					ConflictResolution::Skip | ConflictResolution::Overwrite => return Ok(None),
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			let exists = if let Some(res) = ctx.services.fs.resources.get(&path).await {
				res.try_exists(ctx).await?
			} else {
				tokio::fs::try_exists(&path).await?
			};

			if exists {
				match strategy {
					ConflictResolution::Skip => return Ok(None),
					ConflictResolution::Overwrite => {
						if !self.active_paths.insert(path.to_path_buf()) {
							return Ok(None);
						}
						break Some(path);
					}
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			if !self.active_paths.insert(path.to_path_buf()) {
				continue;
			}
			break Some(path);
		};

		if let Some(target) = reserved {
			ctx.services.fs.ensure_parent_dir_exists(&target).await?;
			let result = action(target.clone()).await?;

			self.active_paths.remove(&target.to_path_buf());

			Ok(Some(result))
		} else {
			Ok(None)
		}
	}
}

```

`organizer/organize-sdk\src\context\services\fs\manager.rs`:

```rs
use crate::{
	context::{services::fs::locker::Locker, ExecutionContext},
	engine::rule::RuleBuilder,
	error::Error,
	plugins::storage::StorageProvider,
	resource::{FileState, Resource},
	templates::template::{Template, TemplateString},
};
use anyhow::Result;
use futures;
use moka::future::Cache;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{
	collections::HashMap,
	path::{Path, PathBuf},
	sync::Arc,
};


#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub struct DestinationBuilder {
	pub folder: TemplateString,
	pub filename: Option<TemplateString>,
	pub host: TemplateString,
}
impl DestinationBuilder {
	/// Compiles the raw DestinationBuilder into an executable Destination.
	pub fn build(self, ctx: &ExecutionContext<'_>) -> Result<Destination, Error> {
		let folder = ctx.services.compiler.compile_template(&self.folder)?;
		let filename = self.filename.map(|f| ctx.services.compiler.compile_template(&f)).transpose()?; // This elegantly handles the Option<Result<T, E>>
		let host = ctx.services.compiler.compile_template(&self.host)?;
		Ok(Destination { folder, filename, host })
	}
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Destination {
	pub folder: Template,
	pub filename: Option<Template>,
	pub host: Template,
}

impl Destination {
	pub async fn resolve(&self, ctx: &ExecutionContext<'_>) -> Result<PathBuf> {
		let mut folder = PathBuf::from(self.folder.render(ctx).await?);
		if let Some(filename_template) = &self.filename {
			let filename = filename_template.render(ctx).await?;
			folder.push(filename);
		}
		// A placeholder for the original filename if `filename` is not provided.
		// This would need access to the resource from the context.
		else if let Ok(resource) = ctx.scope.resource() {
			if let Some(name) = resource.path.file_name() {
				folder.push(name);
			}
		}
		Ok(folder)
	}
}

#[derive(Debug, Clone)]
pub struct FileSystemManager {
	pub locker: Locker,
	pub resources: Cache<PathBuf, Arc<Resource>>,
	pub tracked_files: Cache<PathBuf, FileState>,
	pub backends: HashMap<String, Arc<dyn StorageProvider>>,
}



impl FileSystemManager {
	pub fn new(rule: &RuleBuilder) -> Self {
		let mut backends: HashMap<String, Arc<dyn StorageProvider + 'static>> = rule
			.connections
			.iter()
			.map(|(k, v)| (k.clone(), Arc::from(v.clone())))
			.collect();

		backends.insert(
			"file".to_string(),
			serde_json::from_value::<Arc<dyn StorageProvider>>(json!({ "type": "local" })).expect("missing local file system provider"),
		);

		Self {
			locker: Locker::default(),
			resources: Cache::new(10_000),
			tracked_files: Cache::new(10_000),
			backends,
		}
	}

	pub fn get_provider(&self, host: &str) -> Result<Arc<dyn StorageProvider>> {
		self.backends
			.get(host)
			.cloned()
			.ok_or_else(|| anyhow::anyhow!("No provider found for host: {}", host))
	}

	pub async fn ensure_parent_dir_exists(&self, path: &Path) -> std::io::Result<()> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		Ok(())
	}

	pub async fn download_many(&self, resources: &[Arc<Resource>]) -> Result<Vec<PathBuf>, Error> {
		let mut downloaded_paths = Vec::with_capacity(resources.len());
		for resource in resources {
			let provider = &resource.backend;
			let temp_path = provider.download(resource.as_path()).await?;
			downloaded_paths.push(temp_path);
		}
		Ok(downloaded_paths)
	}

	pub async fn copy_many(&self, from: &[Arc<Resource>], to: &[Arc<Resource>]) -> Result<(), Error> {
		if from.len() != to.len() {
			return Err(Error::Other(anyhow::anyhow!(
				"Mismatched number of source and destination resources for copy_many"
			)));
		}

		let mut futures = Vec::with_capacity(from.len());
		for (from_res, to_res) in from.iter().zip(to.iter()) {
			let from_provider = from_res.backend.clone();
			let to_provider = to_res.backend.clone();
			let from_path = from_res.as_path().to_path_buf();
			let to_path = to_res.as_path().to_path_buf();
			let manager_clone = self.clone();

			futures.push(async move {
				manager_clone.ensure_parent_dir_exists(&to_path).await?;

				let from_is_local = from_provider.prefix() == "file";
				let to_is_local = to_provider.prefix() == "file";

				match (from_is_local, to_is_local) {
					(true, false) => to_provider.upload(&from_path, &to_path).await?,
					(false, true) => {
						let temp_path = from_provider.download(&from_path).await?;
						tokio::fs::copy(&temp_path, &to_path)
							.await
							.map_err(Error::Io)
							.map(|_| ())?;
						tokio::fs::remove_file(temp_path).await.map_err(Error::Io)?;
					}
					(false, false) => {
						let temp_path = from_provider.download(&from_path).await?;
						to_provider.upload(&temp_path, &to_path).await?;
					}
					(true, true) => from_provider.copy(&from_path, &to_path).await?,
				}
				Ok::<(), Error>(())
			});
		}
		futures::future::try_join_all(futures)
			.await
			.map(|_| ())
			.map_err(|e| Error::Other(anyhow::anyhow!("Failed to copy one or more resources: {}", e)))?;
		Ok(())
	}

	pub async fn copy(&self, from: &Arc<Resource>, to: &Arc<Resource>) -> Result<(), Error> {
		self.copy_many(std::slice::from_ref(from), std::slice::from_ref(to)).await
	}

	pub async fn delete(&self, path: &Arc<Resource>) -> Result<(), Error> {
		let provider = &path.backend;
		provider.delete(path.as_path()).await
	}

	pub async fn mkdir(&self, path: &Arc<Resource>) -> Result<(), Error> {
		let provider = &path.backend;
		provider.mkdir(path.as_path()).await
	}

	pub async fn hardlink(&self, from: &Arc<Resource>, to: &Arc<Resource>) -> Result<(), Error> {
		let from_provider = &from.backend;
		let to_provider = &to.backend;

		if from_provider == to_provider {
			from_provider.hardlink(from.as_path(), to.as_path()).await
		} else {
			Err(Error::ImpossibleOp("Cannot create hardlink across different filesystems".to_string()))
		}
	}

	pub async fn symlink(&self, from: &Arc<Resource>, to: &Arc<Resource>) -> Result<(), Error> {
		let from_provider = &from.backend;
		let to_provider = &to.backend;

		if from_provider == to_provider {
			from_provider.symlink(from.as_path(), to.as_path()).await
		} else {
			Err(Error::ImpossibleOp("Cannot create symlink across different filesystems".to_string()))
		}
	}

	pub async fn r#move(&self, from: &Arc<Resource>, to: &Arc<Resource>) -> Result<(), Error> {
		let from_provider = &from.backend;
		let to_provider = &to.backend;

		if from_provider == to_provider {
			from_provider.r#move(from.as_path(), to.as_path()).await
		} else {
			self.copy(from, to).await?;
			self.delete(from).await
		}
	}
}

```

`organizer/organize-sdk\src\context\services\fs\mod.rs`:

```rs
pub mod backup;
pub mod locker;
pub mod manager;

```

`organizer/organize-sdk\src\context\services\history\mod.rs`:

```rs
use crate::{
	context::settings::RunSettings,
	plugins::action::{Action, Receipt},
};
use anyhow::Result;
use sqlx::{sqlite::SqlitePoolOptions, SqlitePool};
use std::time::{SystemTime, UNIX_EPOCH};

/// The Journal service, responsible for all database interactions.
#[derive(Debug, Clone)]
pub struct Journal {
	pool: SqlitePool,
}

#[derive(Debug)]
pub struct Transaction {
	pub id: i64,
	pub receipt: Receipt,
}

impl Journal {
	/// Creates a new Journal instance, connects to the database, and runs migrations.
	pub async fn new(settings: &RunSettings) -> Result<Self> {
		let db_url = if settings.dry_run {
			// For a dry run, use a temporary, private in-memory SQLite database.
			"sqlite::memory:".to_string()
		} else {
			// For a real run, use the persistent database file specified in .env.
			dotenvy::dotenv().ok();
			std::env::var("DATABASE_URL").expect("DATABASE_URL must be set for real runs")
		};

		let pool = SqlitePoolOptions::new().max_connections(5).connect(&db_url).await?;
		sqlx::migrate!("./migrations").run(&pool).await?;

		Ok(Self { pool })
	}

	pub async fn start_session(&self) -> Result<i64> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;

		let record = sqlx::query!(
			r#"
            INSERT INTO sessions (start_time, status)
            VALUES (?1, 'running')
            "#,
			now,
		)
		.execute(&self.pool)
		.await?;

		Ok(record.last_insert_rowid())
	}

	#[allow(clippy::borrowed_box)]
	pub async fn record_transaction(&self, session_id: i64, action: &Box<dyn Action>, receipt: &Receipt) -> Result<()> {
		if receipt.undo.is_empty() {
			return Ok(());
		}

		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		let action_type = action.typetag_name();

		let action_data = serde_json::to_string(action)?;
		let receipt_data = serde_json::to_string(receipt)?;

		sqlx::query!(
			r#"
            INSERT INTO transactions (session_id, type, action, receipt, timestamp)
            VALUES (?1, ?2, ?3, ?4, ?5)
            "#,
			session_id,
			action_type,
			action_data,
			receipt_data,
			now
		)
		.execute(&self.pool)
		.await?;

		Ok(())
	}

	pub async fn get_pending_transactions_for_session(&self, session_id: i64) -> Result<Vec<Transaction>> {
		let transactions = sqlx::query_as!(
			Transaction,
			"SELECT id, receipt FROM transactions WHERE session_id = ? AND undo_status = 'PENDING' ORDER BY timestamp DESC",
			session_id
		)
		.fetch_all(&self.pool)
		.await?;

		Ok(transactions)
	}

	pub async fn update_transaction_undo_status(&self, transaction_id: i64, status: &str) -> Result<()> {
		sqlx::query!("UPDATE transactions SET undo_status = ? WHERE id = ?", status, transaction_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	/// Marks a session as completed with a final status.
	pub async fn end_session(&self, session_id: i64, status: &str) -> Result<()> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		sqlx::query!("UPDATE sessions SET end_time = ?1, status = ?2 WHERE id = ?3", now, status, session_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	pub async fn get_last_session_id(&self) -> Result<Option<i64>> {
		let result = sqlx::query!("SELECT id FROM sessions ORDER BY start_time DESC LIMIT 1")
			.fetch_optional(&self.pool)
			.await?;
		Ok(result.map(|row| row.id))
	}
}
```

`organizer/organize-sdk\src\context\services\mod.rs`:

```rs
use std::sync::Arc;

use crate::{
    context::services::{fs::manager::FileSystemManager, history::Journal},
    templates::compiler::TemplateCompiler,
};
use dashmap::DashMap;
use std::any::Any;

pub mod fs;
pub mod history;

#[derive(Debug, Clone)]
pub struct RunServices {
	pub blackboard: Blackboard,
	pub fs: FileSystemManager,
	pub journal: Arc<Journal>,
	pub compiler: TemplateCompiler,
}

#[derive(Debug, Clone)]
pub struct Blackboard {
	pub scratchpad: Arc<DashMap<String, Box<dyn Any + Send + Sync>>>,
	pub shared_context: Arc<DashMap<String, String>>,
}

impl Default for Blackboard {
	fn default() -> Self {
		Self {
			scratchpad: Arc::new(DashMap::new()),
			shared_context: Arc::new(DashMap::new()),
		}
	}
}
```

`organizer/organize-sdk\src\context\settings.rs`:

```rs
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct RunSettings {
	pub dry_run: bool,
	pub args: HashMap<String, String>,
}

```

`organizer/organize-sdk\src\engine\batch.rs`:

```rs
use std::{collections::HashMap, sync::Arc};

use crate::resource::Resource;

/// Represents a batch of files that have been grouped by one or more criteria.
/// This is the primary data structure that flows between pipeline stages.
#[derive(Debug, Clone)]
pub struct Batch {
	pub files: Vec<Arc<Resource>>,
	pub context: HashMap<String, String>,
}

impl Batch {
	pub fn new() -> Self {
		Self {
			files: Vec::new(),
			context: HashMap::new(),
		}
	}

	pub fn initial(files: Vec<Arc<Resource>>) -> Self {
		Self {
			files,
			context: HashMap::new(),
		}
	}
}

impl Default for Batch {
	fn default() -> Self {
		Self::new()
	}
}

```

`organizer/organize-sdk\src\engine\mod.rs`:

```rs
pub mod batch;
pub mod pipeline;
pub mod rule;
pub mod stage;

use crate::{
	context::{
		services::{fs::manager::FileSystemManager, history::Journal, Blackboard, RunServices},
		ExecutionContext,
		scope::ExecutionScope,
		settings::RunSettings,
	},
	engine::{
		pipeline::Pipeline,
		rule::{Rule, RuleBuilder},
	},
	templates::compiler::TemplateCompiler,
};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::{path::PathBuf, sync::Arc};
use strum::Display;

#[derive(Default)]
pub enum ExecutionModel {
	#[default]
	Single,
	Batch,
}

#[derive(Eq, Display, PartialEq, Default, Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all(serialize = "lowercase", deserialize = "lowercase"))]
#[strum(serialize_all = "snake_case")]
pub enum ConflictResolution {
	Overwrite,
	#[default]
	Skip,
	Rename,
}

/// The main engine for the application.
/// It owns the compiled configuration and all run-wide services.
pub struct Engine {
	rule: Rule,
	services: RunServices,
	settings: RunSettings,
}

impl Engine {
	pub async fn new(path: &PathBuf, settings: RunSettings) -> Result<Arc<Self>> {
		let content = tokio::fs::read_to_string(path).await?;
		let builder: RuleBuilder = toml::from_str(&content)?;
		let services = RunServices {
			blackboard: Blackboard::default(),
			journal: Arc::new(Journal::new(&settings).await?),
			fs: FileSystemManager::new(&builder),
			compiler: TemplateCompiler::new(),
		};
		let rule = {
			let ctx = ExecutionContext {
				services: &services,
				scope: ExecutionScope::Blank,
				settings: &settings,
			};
			let rule = builder.build(&ctx).await?;
			rule
		};

		Ok(Arc::new(Self { rule, services, settings }))
	}

	pub async fn run(&self) -> Result<()> {
		let pipeline = Pipeline::new(self.rule.clone());

		// Create the top-level execution context with a blank scope.
		let ctx = ExecutionContext {
			services: &self.services,
			settings: &self.settings, // Assuming you have settings
			scope: ExecutionScope::Blank,
		};

		let _final_stream = pipeline.run(&ctx).await?;
		Ok(())
	}
}
```

`organizer/organize-sdk\src\engine\pipeline.rs`:

```rs
use futures::future;

use crate::{
	context::{scope::ExecutionScope, ExecutionContext},
	engine::{
		batch::Batch,
		rule::Rule,
		stage::{Stage, StageParams},
		ExecutionModel,
	},
	error::Error,
	plugins::{action::Receipt, partitioner::Partitioner, sorter::Sorter},
	resource::Resource,
};
use glob::Pattern;
use std::{
	collections::{HashMap, HashSet},
	sync::Arc,
};

/// Represents the data flowing through the pipeline.
/// It tracks the current set of file batches and the sequence of
/// partitioners that have been applied to create them.
#[derive(Debug)]
pub struct PipelineStream {
	/// The current data, always represented as a list of batches.
	/// An "ungrouped" state is simply a Vec with one Batch.
	pub batches: HashMap<String, Batch>,
	/// The ordered stack of partitioners that have been applied.
	pub partitioners: Vec<Box<dyn Partitioner>>,
	pub sorters: Vec<Box<dyn Sorter>>,
}

impl PipelineStream {
	/// Creates a new stream with a single batch of files and no groupings.
	pub fn new(files: Vec<Arc<Resource>>) -> Self {
		Self {
			batches: HashMap::from([("root".into(), Batch::initial(files))]),
			partitioners: Vec::new(),
			sorters: Vec::new(),
		}
	}

	/// Flattens all batches into a single, unordered list of files.
	pub fn all_files(&self) -> Vec<Arc<Resource>> {
		self.batches.values().flat_map(|batch| batch.files.clone()).collect()
	}

	pub async fn resort(&mut self) {
		for batch in self.batches.values_mut() {
			for sorter in &self.sorters {
				sorter.sort(&mut batch.files).await;
			}
		}
	}

	/// Re-applies the entire stack of stored partitioners to a new set of files.
	/// This is the key to maintaining a consistent state.
	pub async fn repartition(&self, files: Vec<Arc<Resource>>) -> Result<HashMap<String, Batch>, anyhow::Error> {
		let mut current_batches = HashMap::from([("root".into(), Batch::initial(files))]);

		for partitioner in &self.partitioners {
			let mut next_level_batches = HashMap::new();
			for (parent_name, parent_batch) in &current_batches {
				let named_batches_map = partitioner.partition(parent_batch).await?;
				for (new_key_part, mut sub_batch) in named_batches_map {
					let new_name = if parent_name == "root" {
						new_key_part.clone()
					} else {
						format!("{parent_name}.{new_key_part}")
					};
					sub_batch.context.extend(parent_batch.context.clone());
					sub_batch.context.insert(partitioner.name().to_string(), new_key_part.clone());
					next_level_batches.insert(new_name, sub_batch);
				}
			}
			current_batches = next_level_batches;
		}
		Ok(current_batches)
	}
}

pub struct Pipeline {
	stages: Vec<Stage>,
	stream: PipelineStream,
}

fn select_batches<'a>(
	all_batches: &'a HashMap<String, Batch>,
	params: &StageParams,
) -> (HashMap<String, &'a Batch>, HashMap<String, &'a Batch>, Vec<String>) {
	let mut selected_batches = HashMap::new();
	let mut unselected_batches = HashMap::new();
	let mut unmatched_patterns = Vec::new();

	if let Some(patterns) = &params.on_batches {
		let all_batch_names: HashSet<_> = all_batches.keys().cloned().collect();
		let mut matched_names = HashSet::new();

		for pattern_str in patterns {
			let pattern = Pattern::new(pattern_str).unwrap();
			let mut matched_any = false;
			for name in &all_batch_names {
				if pattern.matches(name) {
					matched_names.insert(name.clone());
					matched_any = true;
				}
			}
			if !matched_any {
				unmatched_patterns.push(pattern_str.clone());
			}
		}

		for (name, batch) in all_batches {
			if matched_names.contains(name) {
				selected_batches.insert(name.clone(), batch);
			} else {
				unselected_batches.insert(name.clone(), batch);
			}
		}
	} else {
		// If no patterns are specified, select all batches
		for (name, batch) in all_batches {
			selected_batches.insert(name.clone(), batch);
		}
	}

	(selected_batches, unselected_batches, unmatched_patterns)
}

impl Stage {
	fn params(&self) -> Option<&StageParams> {
		match self {
			Stage::Action { params, .. } => Some(params),
			Stage::Filter { params, .. } => Some(params),
			Stage::Partition { params, .. } => Some(params),
			Stage::Sort { params, .. } => Some(params),
			Stage::Select { params, .. } => Some(params),
			Stage::Search { params, .. } => Some(params),
			Stage::Flatten { params, .. } => Some(params),
		}
	}
}

impl Pipeline {
	pub fn new(rule: Rule) -> Self {
		Self {
			stages: rule.pipeline,
			stream: PipelineStream::new(Vec::new()), // Start with no files
		}
	}

	pub async fn run(mut self, ctx: &ExecutionContext<'_>) -> Result<PipelineStream, Error> {
		for stage in self.stages.into_iter() {
			if let Some(params) = stage.params() {
				if !params.enabled {
					continue;
				}
				if let Some(description) = &params.description {
					tracing::debug!(description = %description, "Running stage");
				}
			}
			match stage {
				Stage::Search { location, source, .. } => {
					let scope = ExecutionScope::new_location_scope(source.clone(), &location);
					let ctx = ctx.with_scope(scope);
					let new_files = ctx.services.fs.get_provider(&location.host)?.discover(&location, &ctx).await?;
					if location.mode.is_replace() {
						if location.keep_structure {
							self.stream.batches = self.stream.repartition(new_files).await?;
							self.stream.resort().await;
						} else {
							self.stream = PipelineStream::new(new_files);
						}
					} else {
						let mut all_files = self.stream.all_files();
						all_files.extend(new_files);
						self.stream.batches = self.stream.repartition(all_files).await?;
						self.stream.resort().await;
					}
				}
				Stage::Partition { partitioner, params, .. } => {
					let (selected_batches, unselected, unmatched) = select_batches(&self.stream.batches, &params);
					if !unmatched.is_empty() {
						println!(
							"Warning: The following patterns in `on_batches` did not match any existing batches: {}",
							unmatched.join(", ")
						);
					}

					let mut next_level_batches: HashMap<String, Batch> = unselected.into_iter().map(|(k, v)| (k, v.clone())).collect();

					for (parent_name, parent_batch) in selected_batches {
						let named_batches_map = partitioner.partition(parent_batch).await?;
						for (new_key_part, mut sub_batch) in named_batches_map {
							let new_name = if parent_name == "root" {
								new_key_part.clone()
							} else {
								format!("{parent_name}.{new_key_part}")
							};
							sub_batch.context.extend(parent_batch.context.clone());
							sub_batch.context.insert(partitioner.name().to_string(), new_key_part);
							next_level_batches.insert(new_name, sub_batch);
						}
					}
					self.stream.batches = next_level_batches;
					self.stream.partitioners.push(partitioner);
					self.stream.resort().await;
				}
				Stage::Sort { sorter, params, .. } => {
					if params.on_batches.is_some() {
						let (selected_batches, _, unmatched) = select_batches(&self.stream.batches, &params);
						if !unmatched.is_empty() {
							println!(
								"Warning: The following patterns in `on_batches` did not match any existing batches: {}",
								unmatched.join(", ")
							);
						}
						let selected_names: Vec<String> = selected_batches.keys().cloned().collect();
						for name in selected_names {
							if let Some(batch) = self.stream.batches.get_mut(&name) {
								sorter.sort(&mut batch.files).await;
							}
						}
					} else {
						self.stream.sorters.push(sorter);
						self.stream.resort().await;
					}
				}
				Stage::Filter { filter, params, source } => {
					let check_path = params.check.as_ref();
					let (selected_batches, unselected, unmatched) = select_batches(&self.stream.batches, &params);
					if !unmatched.is_empty() {
						println!(
							"Warning: The following patterns in `on_batches` did not match any existing batches: {}",
							unmatched.join(", ")
						);
					}

					let mut next_batches: HashMap<String, Batch> = unselected.into_iter().map(|(k, v)| (k, v.clone())).collect();

					match filter.execution_model() {
						ExecutionModel::Batch => {
							for (name, batch) in selected_batches {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let passed_files = filter.filter(check_path, &batch_ctx).await?;
								if !passed_files.is_empty() {
									next_batches.insert(name.clone(), Batch {
										files: passed_files,
										context: batch.context.clone(),
									});
								}
							}
						}
						ExecutionModel::Single => {
							for (name, batch) in selected_batches {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let filter = filter.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										filter.filter(check_path, &ctx).await
									};
									futs.push(fut);
								}
								let results: Vec<Arc<Resource>> = future::try_join_all(futs).await?.into_iter().flatten().collect();
								if !results.is_empty() {
									next_batches.insert(name.clone(), Batch {
										files: results,
										context: batch.context.clone(),
									});
								}
							}
						}
					}
					self.stream.batches = next_batches;
				}
				Stage::Action { action, params, source } => {
					let (selected_batches, unselected, unmatched) = select_batches(&self.stream.batches, &params);
					if !unmatched.is_empty() {
						println!(
							"Warning: The following patterns in `on_batches` did not match any existing batches: {}",
							unmatched.join(", ")
						);
					}

					let mut next_stream_batches: HashMap<String, Batch> = unselected.into_iter().map(|(k, v)| (k, v.clone())).collect();

					for (name, batch) in selected_batches {
						let mut current_batch_next_files = Vec::new();
						match action.execution_model() {
							ExecutionModel::Batch => {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let receipt = action.commit(&batch_ctx).await?;
								current_batch_next_files.extend(receipt.next);
							}
							ExecutionModel::Single => {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let action = action.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										action.commit(&ctx).await
									};
									futs.push(fut);
								}
								let receipts: Vec<Receipt> = future::try_join_all(futs).await?;
								for receipt in receipts {
									current_batch_next_files.extend(receipt.next);
								}
							}
						}

						if !current_batch_next_files.is_empty() {
							next_stream_batches.insert(name.clone(), Batch {
								files: current_batch_next_files,
								context: batch.context.clone(),
							});
						}
					}
					self.stream.batches = next_stream_batches;
				}
				Stage::Flatten { flatten, .. } => {
					if flatten {
						self.stream = PipelineStream::new(self.stream.all_files());
					}
				}
				Stage::Select { selector, params, .. } => {
					let (selected_batches, unselected, unmatched) = select_batches(&self.stream.batches, &params);
					if !unmatched.is_empty() {
						println!(
							"Warning: The following patterns in `on_batches` did not match any existing batches: {}",
							unmatched.join(", ")
						);
					}

					let mut next_batches: HashMap<String, Batch> = unselected.into_iter().map(|(k, v)| (k, v.clone())).collect();

					for (name, batch) in selected_batches {
						let selected_batch = selector.select(batch).await?;
						if !selected_batch.files.is_empty() {
							next_batches.insert(name.clone(), selected_batch);
						}
					}
					self.stream.batches = next_batches;
				}
			}
		}
		Ok(self.stream)
	}
}

```

`organizer/organize-sdk\src\engine\rule.rs`:

```rs
use serde::{Deserialize, Serialize};
use crate::{
	context::ExecutionContext,
	engine::stage::{Stage, StageBuilder},
	error::Error,
	plugins::storage::StorageProvider,
};
use std::{collections::HashMap, sync::Arc};

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct RuleMetadata {
	pub name: Option<String>,
	pub description: Option<String>,
	#[serde(default)]
	pub tags: Vec<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct RuleBuilder {
	#[serde(flatten)]
	pub metadata: RuleMetadata,
	#[serde(default)]
	pub connections: HashMap<String, Box<dyn StorageProvider>>,
	#[serde(rename = "stage")]
	pub pipeline: Vec<StageBuilder>,
}

#[derive(Debug, Clone)]
pub struct Rule {
	pub metadata: Arc<RuleMetadata>,
	pub connections: HashMap<String, Box<dyn StorageProvider>>,
	pub pipeline: Vec<Stage>,
}

impl PartialEq for Rule {
	fn eq(&self, other: &Self) -> bool {
		self.metadata == other.metadata && self.pipeline == other.pipeline
	}
}
impl Eq for Rule {}

async fn load_rule_builder_from_path(path: &std::path::Path) -> Result<RuleBuilder, anyhow::Error> {
	let content = tokio::fs::read_to_string(path).await?;
	let builder: RuleBuilder = toml::from_str(&content)?;
	Ok(builder)
}

impl RuleBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Rule, Error> {
		let mut final_pipeline = Vec::new();
		let main_meta = Arc::new(self.metadata);
		let mut processing_stack: Vec<(StageBuilder, Arc<RuleMetadata>)> = self
			.pipeline
			.into_iter()
			.map(|builder| (builder, main_meta.clone()))
			.rev()
			.collect();

		while let Some((builder, meta)) = processing_stack.pop() {
			match builder {
				StageBuilder::Compose(path) => {
					let composed_builder = load_rule_builder_from_path(&path).await?;
					let composed_meta = Arc::new(composed_builder.metadata);
					for stage_builder in composed_builder.pipeline.into_iter().rev() {
						processing_stack.push((stage_builder, composed_meta.clone()));
					}
				}
				// The logic to build the final Stage enum now changes slightly
				other_builder => {
					let stage_enum = other_builder.build(ctx, meta).await?;
					final_pipeline.push(stage_enum);
				}
			}
		}

		Ok(Rule {
			metadata: main_meta.clone(),
			connections: self.connections,
			pipeline: final_pipeline,
		})
	}
}

```

`organizer/organize-sdk\src\engine\stage.rs`:

```rs
use std::{path::PathBuf, sync::Arc};

use serde::{Deserialize, Deserializer, Serialize};

use crate::{
	context::ExecutionContext,
	engine::rule::RuleMetadata,
	error::Error,
	location::{Location, LocationBuilder},
	plugins::{
		action::{Action, ActionBuilder},
		filter::Filter,
		partitioner::Partitioner,
		selector::Selector,
		sorter::Sorter,
	},
};

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq, Default)]
pub struct StageParams {
	#[serde(default)]
	pub description: Option<String>,
	#[serde(default = "default_true")]
	pub enabled: bool,
	#[serde(default)]
	pub on_batches: Option<Vec<String>>,
	#[serde(default)]
	pub check: Option<PathBuf>,
}

fn default_true() -> bool {
	true
}


#[derive(Debug, Serialize, PartialEq, Eq, Clone)]
pub enum StageBuilder {
	Search(LocationBuilder, StageParams),
	Compose(PathBuf),
	Action(Box<dyn ActionBuilder>, StageParams),
	Filter(Box<dyn Filter>, StageParams),
	Select(Box<dyn Selector>, StageParams),
	Partition(Box<dyn Partitioner>, StageParams),
	Sort(Box<dyn Sorter>, StageParams),
	Flatten(bool, StageParams),
}

impl StageBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>, source: Arc<RuleMetadata>) -> Result<Stage, Error> {
		match self {
			StageBuilder::Search(location_builder, params) => {
				let stage = location_builder.build(ctx).await.unwrap();
				Ok(Stage::Search {
					location: stage,
					params,
					source,
				})
			}
			StageBuilder::Flatten(flatten, params) => Ok(Stage::Flatten {
				flatten,
				params,
				source,
			}),
			StageBuilder::Action(builder, params) => {
				let stage = builder.build(ctx).await?;
				Ok(Stage::Action {
					action: stage,
					params,
					source,
				})
			}
			StageBuilder::Filter(filter, params) => Ok(Stage::Filter { filter, params, source }),
			StageBuilder::Partition(partitioner, params) => Ok(Stage::Partition { partitioner, params, source }),
			StageBuilder::Sort(sorter, params) => Ok(Stage::Sort { sorter, params, source }),
			StageBuilder::Compose(_) => unreachable!("Compose stages should be flattened"),
			StageBuilder::Select(selector, params) => Ok(Stage::Select { selector, params, source }),
		}
	}
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Stage {
	Search {
		location: Location,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Action {
		action: Box<dyn Action>,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Filter {
		filter: Box<dyn Filter>,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Select {
		selector: Box<dyn Selector>,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Flatten {
		flatten: bool,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Partition {
		partitioner: Box<dyn Partitioner>,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
	Sort {
		sorter: Box<dyn Sorter>,
		params: StageParams,
		source: Arc<RuleMetadata>,
	},
}

impl<'de> Deserialize<'de> for StageBuilder {
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where
		D: Deserializer<'de>,
	{
		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
		let table = map
			.as_table_mut()
			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

		let key = {
			let keys: Vec<_> = table.keys().cloned().collect();
			let possible_keys = [
				"search", "compose", "action", "filter", "partition-by", "sort-by", "select", "flatten",
			];
			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'partition-by', 'sort-by', 'select', 'flatten'")
			})?
		};

		let value = table
			.remove(&key)
			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{key}'")))?;

		let params: StageParams = toml::Value::Table(table.clone()).try_into().map_err(serde::de::Error::custom)?;
		table.remove("on_batches");
		table.remove("enabled");
		table.remove("description");
		table.remove("check");

		match key.as_str() {
			"search" => {
				let path_template_str = value.try_into::<String>().map_err(serde::de::Error::custom)?;
				let mut params_table = table.clone();
				params_table.insert("path".to_string(), path_template_str.into());
				let builder: LocationBuilder =
					toml::Value::Table(params_table).try_into().map_err(serde::de::Error::custom)?;

				Ok(StageBuilder::Search(builder, params))
			}
			"compose" => {
				let rule_to_compose = value.try_into::<PathBuf>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Compose(rule_to_compose))
			}
			"flatten" => {
				let value = value.try_into::<bool>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Flatten(value, params))
			}
			"filter" | "select" | "action" | "partition-by" | "sort-by" => {
				let component_type = value
					.as_str()
					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{key}'")))?;

				let mut component_table = table.clone();
				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
				let component_value = toml::Value::Table(component_table);

				match key.as_str() {
					"filter" => Ok(StageBuilder::Filter(
						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
						params,
					)),
					"partition-by" => Ok(StageBuilder::Partition(
						Box::<dyn Partitioner>::deserialize(component_value).map_err(serde::de::Error::custom)?,
						params,
					)),
					"select" => Ok(StageBuilder::Select(
						Box::<dyn Selector>::deserialize(component_value).map_err(serde::de::Error::custom)?,
						params,
					)),
					"action" => Ok(StageBuilder::Action(
						Box::<dyn ActionBuilder>::deserialize(component_value).map_err(serde::de::Error::custom)?,
						params,
					)),
					"sort-by" => Ok(StageBuilder::Sort(
						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
						params,
					)),
					_ => unreachable!(),
				}
			}
			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{other}'"))),
		}
	}
}

```

`organizer/organize-sdk\src\error.rs`:

```rs

use std::path::PathBuf;
use thiserror::Error;

use crate::{
	plugins::action::UndoError,
	templates::{engine::TemplateError, parser::ParseError},
};

/// The primary error type for all actions within the application.
#[derive(Error, Debug)]
pub enum Error {
	#[error(transparent)]
	SFTP(#[from] russh_sftp::client::error::Error),

	#[error(transparent)]
	SSH(#[from] russh::Error),

	#[error("Impossible operation: {0}")]
	ImpossibleOp(String),

	#[error("Error in configuration: {0}")]
	Config(String),

	#[error("Error converting to value")]
	Json(#[from] serde_json::Error),

	#[error(transparent)]
	Io(#[from] std::io::Error),

	#[error(transparent)]
	Other(#[from] anyhow::Error),

	#[error("Could not create backup for: {path:?}")]
	Backup {
		#[source]
		source: std::io::Error,
		path: PathBuf,
	},

	#[error(transparent)]
	ParseError(#[from] ParseError),

	#[error("Error in prompt")]
	Interaction {
		#[source]
		source: std::io::Error,
		prompt: String,
	},

	#[error(transparent)]
	TemplateError(#[from] TemplateError),

	#[error("Tried to retrieve `{0}` from the scope but it is not defined")]
	OutOfScope(String),

	#[error(transparent)]
	UndoError(#[from] UndoError),
}

```

`organizer/organize-sdk\src\errors.rs`:

```rs
use std::path::PathBuf;
use thiserror::Error;

use crate::{
	plugins::action::UndoError,
	templates::{engine::TemplateError, parser::ParseError},
};

/// The primary error type for all actions within the application.
#[derive(Error, Debug)]
pub enum Error {
	#[error("Error converting to value")]
	Json(#[from] serde_json::Error),

	#[error(transparent)]
	Io(#[from] std::io::Error),

	#[error(transparent)]
	Other(#[from] anyhow::Error),

	#[error("Could not create backup for: {path:?}")]
	Backup {
		#[source]
		source: std::io::Error,
		path: PathBuf,
	},

	#[error(transparent)]
	ParseError(#[from] ParseError),

	#[error("Error in prompt")]
	Interaction {
		#[source]
		source: std::io::Error,
		prompt: String,
	},

	#[error(transparent)]
	TemplateError(#[from] TemplateError),

	#[error("Tried to retrieve `{0}` from the scope but it is not defined")]
	OutOfScope(String),

	#[error(transparent)]
	UndoError(#[from] UndoError),
}

```

`organizer/organize-sdk\src\lib.rs`:

```rs
#![feature(file_lock)]
#![feature(path_add_extension)]
#![feature(lock_value_accessors)]

pub const PROJECT_NAME: &str = "organize";

pub mod context;
pub mod engine;
pub mod error;
pub mod location;
pub mod plugins;
pub mod resource;
pub mod stdx;
pub mod templates;
pub mod utils;

```

`organizer/organize-sdk\src\location\mod.rs`:

```rs
use std::{path::PathBuf, sync::Arc};

use anyhow::Result;
use serde::{Deserialize, Serialize};

use crate::{
	context::{scope::ExecutionScope, ExecutionContext},
	error::Error,
	location::options::{Options, OptionsBuilder},
	plugins::storage::StorageProvider,
	templates::template::TemplateString,
};

pub mod options;

#[derive(Debug, Serialize, PartialEq, Eq, Clone, Deserialize)]
pub struct LocationBuilder {
	pub path: TemplateString,
	pub host: TemplateString,
	#[serde(flatten)]
	pub options: OptionsBuilder,
	#[serde(default)]
	pub mode: SearchMode,
	#[serde(default = "defaults::keep_structure")]
	pub keep_structure: bool,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Location {
	pub path: PathBuf,
	pub host: String,
	pub options: Options,
	pub mode: SearchMode,
	pub keep_structure: bool,
}

impl Eq for Location {}

impl PartialEq for Location {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path && self.options == other.options && self.mode == other.mode && self.keep_structure == other.keep_structure
	}
}

impl Location {
	pub fn new_local() -> Arc<dyn StorageProvider> {
		let value = serde_json::json!({
			"type": "local"
		});
		let backend: Box<dyn StorageProvider> = serde_json::from_value(value).unwrap();
		Arc::from(backend)
	}
}

impl LocationBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Location, Error> {
		let path_template = ctx.services.compiler.compile_template(&self.path)?;
		let path = PathBuf::from(path_template.render(ctx).await?);
		let host = ctx.services.compiler.compile_template(&self.host)?.render(ctx).await?;

		let ctx = &ExecutionContext {
			services: ctx.services,
			scope: ExecutionScope::new_build_scope(&path),
			settings: ctx.settings,
		};

		Ok(Location {
			path: path.clone(),
			host,
			options: self.options.compile(ctx, &path.to_string_lossy()).await?,
			mode: self.mode,
			keep_structure: self.keep_structure,
		})
	}
}

mod defaults {
	pub(super) fn keep_structure() -> bool {
		true
	}
}
/// The final, compiled `Folder` object, ready for execution.

#[derive(Debug, Deserialize, Serialize, Default, PartialEq, Eq, Clone)]
#[serde(rename_all = "lowercase")]
pub enum SearchMode {
	Replace,
	#[default]
	Append,
}

impl SearchMode {
	/// Returns `true` if the search mode is [`Replace`].
	///
	/// [`Replace`]: SearchMode::Replace
	#[must_use]
	pub fn is_replace(&self) -> bool {
		matches!(self, Self::Replace)
	}

	/// Returns `true` if the search mode is [`Append`].
	///
	/// [`Append`]: SearchMode::Append
	#[must_use]
	pub fn is_append(&self) -> bool {
		matches!(self, Self::Append)
	}
}

```

`organizer/organize-sdk\src\location\options.rs`:

```rs
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, path::PathBuf};

use crate::{context::ExecutionContext, error::Error, stdx::path::PathExt, templates::template::TemplateString};

fn default_usize() -> usize {
	1.0 as usize
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct OptionsBuilder {
	#[serde(default = "default_usize")]
	pub max_depth: usize,
	#[serde(default = "default_usize")]
	pub min_depth: usize,
	#[serde(default)]
	pub exclude: Vec<TemplateString>,
	#[serde(default)]
	pub hidden_files: bool,
	#[serde(default)]
	pub partial_files: bool,
	#[serde(default)]
	pub follow_symlinks: bool,
	#[serde(default)]
	pub target: Target,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Options {
	pub max_depth: usize,
	pub min_depth: usize,
	pub exclude: Vec<PathBuf>,
	pub hidden_files: bool,
	pub partial_files: bool,
	pub follow_symlinks: bool,
	pub target: Target,
}

impl OptionsBuilder {
	pub async fn compile(self, ctx: &ExecutionContext<'_>, host: &str) -> Result<Options, Error> {
		let mut excluded_paths = Vec::new();
		let backend = ctx.services.fs.get_provider(host)?;

		for template in &self.exclude {
			let template = ctx.services.compiler.compile_template(template)?;
			if let Ok(rendered_path_str) = template.render(ctx).await {
				excluded_paths.push(PathBuf::from(rendered_path_str).expand_user(backend.clone()).await);
			}
		}

		Ok(Options {
			max_depth: self.max_depth,
			min_depth: self.min_depth,
			exclude: excluded_paths,
			hidden_files: self.hidden_files,
			partial_files: self.partial_files,
			follow_symlinks: self.follow_symlinks,
			target: self.target,
		})
	}
}

#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Target {
	#[default]
	Files,
	Folders,
}

impl Target {
	/// Returns `true` if the target is [`Files`].
	///
	/// [`Files`]: Target::Files
	#[must_use]
	pub fn is_files(&self) -> bool {
		matches!(self, Self::Files)
	}

	/// Returns `true` if the target is [`Folders`].
	///
	/// [`Folders`]: Target::Folders
	#[must_use]
	pub fn is_folders(&self) -> bool {
		matches!(self, Self::Folders)
	}
}

```

`organizer/organize-sdk\src\plugins\action.rs`:

```rs
use async_trait::async_trait;
use clap::ValueEnum;
use dialoguer::{theme::ColorfulTheme, Input as RenameInput, Select};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ffi::OsStr, fmt::Debug, path::Path, sync::Arc};
use strum::{Display, EnumIter, IntoEnumIterator};

use anyhow::Result;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::path::PathBuf;
use thiserror::Error;

use crate::{
	context::{services::fs::backup::Backup, ExecutionContext},
	engine::ExecutionModel,
	error::Error,
	resource::Resource,
};

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Input {
	Processed(Arc<Resource>),
	Skipped(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Output {
	Created(Arc<Resource>),
	Deleted(Arc<Resource>),
	Modified(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct Receipt {
	pub inputs: Vec<Input>,
	pub outputs: Vec<Output>,
	pub next: Vec<Arc<Resource>>,
	pub undo: Vec<Box<dyn Undo>>,
	pub metadata: HashMap<String, serde_json::Value>,
}

impl From<String> for Receipt {
	fn from(value: String) -> Self {
		serde_json::from_str(&value).expect("Could not convert string to Receipt object")
	}
}

dyn_clone::clone_trait_object!(Undo);
dyn_eq::eq_trait_object!(Undo);

#[derive(Debug, Error)]
pub enum UndoError {
	#[error("Path '{0}' does not exist, but is required for the undo operation.")]
	PathNotFound(PathBuf),

	#[error("Path '{0}' already exists. The undo operation would overwrite it.")]
	PathAlreadyExists(PathBuf),

	#[error("Backup file is missing for path '{0}'. Cannot restore.")]
	BackupMissing(PathBuf),

	#[error("Parent directory '{0}' for the restore path does not exist.")]
	ParentDirectoryNotFound(PathBuf),

	#[error("Any error")]
	Anyhow(#[from] anyhow::Error),

	#[error("IO error")]
	IO(#[from] std::io::Error),

	#[error("Undo aborted by the user")]
	Abort,
}

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Undo: Debug + DynEq + DynClone + Send + Sync {
	async fn undo(&self, settings: &UndoSettings) -> Result<(), Error>;

	fn backup(&self) -> Option<&Backup> {
		None
	}

	async fn verify(&self) -> Result<(), Error>;
}

pub struct UndoSettings {
	pub interactive: bool,
	pub on_conflict: UndoConflict,
}

#[derive(Clone, Debug, ValueEnum, EnumIter, Display)]
#[strum(serialize_all = "snake_case")]
pub enum UndoConflict {
	Skip,
	Abort,
	Overwrite,
	AutoRename,
	Rename,
}

async fn suggest_new_path(resource: Resource) -> Result<Resource> {
	let parent = resource.as_path().parent().unwrap_or_else(|| Path::new(""));
	let stem = resource.as_path().file_stem().unwrap_or_else(|| OsStr::new("file"));
	let extension = resource.as_path().extension().unwrap_or_else(|| OsStr::new(""));

	let mut count = 1;
	loop {
		// 2. Construct the new filename purely from strings and path components.
		let new_filename_str = format!("{} ({}).{}", stem.to_string_lossy(), count, extension.to_string_lossy());

		// 3. Create a new PathBuf to check for existence. This does not touch the original `resource`.
		let new_path = parent.join(&new_filename_str);

		if !tokio::fs::try_exists(&new_path).await? {
			// 4. Once a valid path is found, consume the original `resource` exactly once
			//    to create the final, evolved struct and return it. The loop is guaranteed to terminate here.
			return Ok(resource.with_path(new_path));
		}
		count += 1;
	}
}

impl UndoConflict {
	/// This new method encapsulates all the conflict handling logic.
	/// It takes a mutable reference to the destination to allow the Rename variant to change it.
	pub async fn resolve(resource: Resource) -> Result<Option<Resource>, UndoError> {
		let choices: Vec<Self> = Self::iter().collect();
		let strategy: &UndoConflict = Select::with_theme(&ColorfulTheme::default())
			.with_prompt(format!("Destination '{}' already exists.", resource.path.display()))
			.items(&choices)
			.interact()
			.map(|choice| &choices[choice])
			.expect("Unknown option");
		strategy.handle(resource).await
	}

	pub async fn handle(&self, resource: Resource) -> Result<Option<Resource>, UndoError> {
		match self {
			UndoConflict::Overwrite => {
				// The logic for overwriting the destination file.
				if resource.as_path().is_file() {
					tokio::fs::remove_file(resource.as_path()).await?;
				} else {
					tokio::fs::remove_dir_all(resource.as_path()).await?;
				}
				Ok(Some(resource))
			}
			UndoConflict::Rename => {
				// The logic for prompting the user and renaming the destination.
				let theme = ColorfulTheme::default();
				let input = RenameInput::<String>::with_theme(&theme)
					.with_prompt("Enter a new name for the destination")
					.with_initial_text(format!("{}", resource.as_path().file_name().unwrap_or_default().display()))
					.interact_text()
					.map(PathBuf::from)?;
				let new = resource.with_path(input);
				Ok(Some(new))
			}
			UndoConflict::Skip => Ok(None),
			UndoConflict::Abort => Err(UndoError::Abort),
			UndoConflict::AutoRename => Ok(Some(suggest_new_path(resource).await?)),
		}
	}
}

dyn_clone::clone_trait_object!(ActionBuilder);
dyn_eq::eq_trait_object!(ActionBuilder);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait ActionBuilder: DynEq + DynClone + Sync + Send + Debug {
	async fn build(&self, _ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error>;
}

dyn_clone::clone_trait_object!(Action);
dyn_eq::eq_trait_object!(Action);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Action: DynEq + DynClone + Sync + Send + Debug {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::default()
	}
	async fn commit(&self, _ctx: &ExecutionContext<'_>) -> Result<Receipt, Error>;
}

```

`organizer/organize-sdk\src\plugins\filter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, path::PathBuf, sync::Arc};

// pub mod content;
// pub mod empty;
// pub mod extension;
// pub mod filename;
// pub mod mime;
// pub mod regex;

use crate::{
	context::ExecutionContext,
	engine::ExecutionModel,
	error::Error,
	resource::Resource,
};

dyn_clone::clone_trait_object!(Filter);
dyn_eq::eq_trait_object!(Filter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Filter: DynClone + DynEq + Debug + Send + Sync {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::Single
	}

	/// Takes the execution context, which contains the appropriate scope,
	/// and returns a Result containing the list of files that passed.
	async fn filter(&self, check: Option<&PathBuf>, ctx: &ExecutionContext) -> Result<Vec<Arc<Resource>>, Error>;
}

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct Not(Box<dyn Filter>);

// impl std::ops::Deref for Not {
// 	type Target = Box<dyn Filter>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "not")]
// impl Filter for Not {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		!self.filter(ctx).await
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AnyOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AnyOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "any_of")]
// impl Filter for AnyOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().any(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AllOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AllOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "all_of")]
// impl Filter for AllOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().all(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct NoneOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for NoneOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "none_of")]
// impl Filter for NoneOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		!results.iter().any(|&result| result)
// 	}
// }
```

`organizer/organize-sdk\src\plugins\mod.rs`:

```rs
pub mod action;
pub mod filter;
pub mod partitioner;
pub mod selector;
pub mod sorter;
pub mod storage;

```

`organizer/organize-sdk\src\plugins\partitioner.rs`:

```rs
use crate::{engine::batch::Batch, error::Error};
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{collections::HashMap, fmt::Debug};

dyn_clone::clone_trait_object!(Partitioner);
dyn_eq::eq_trait_object!(Partitioner);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Partitioner: DynEq + DynClone + Sync + Send + Debug {
	fn name(&self) -> &str;
	async fn partition(&self, batch: &Batch) -> Result<HashMap<String, Batch>, Error>;
}
```

`organizer/organize-sdk\src\plugins\selector.rs`:

```rs
use crate::{engine::batch::Batch, error::Error};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Selector);
dyn_eq::eq_trait_object!(Selector);

/// A trait for any component that selects a subset of files from a batch based on
/// positional or quantitative criteria (e.g., first, last, random sample).
#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Selector: DynEq + DynClone + Sync + Send + Debug {
	async fn select(&self, batch: &Batch) -> Result<Batch, Error>;
}
```

`organizer/organize-sdk\src\plugins\sorter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

use crate::resource::Resource;

dyn_clone::clone_trait_object!(Sorter);
dyn_eq::eq_trait_object!(Sorter);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Sorter: DynEq + DynClone + Sync + Send + Debug {
	/// Sorts a slice of resources in-place.
	async fn sort(&self, files: &mut [Arc<Resource>]);
}
```

`organizer/organize-sdk\src\plugins\storage.rs`:

```rs
use crate::{context::ExecutionContext, error::Error, location::Location, resource::Resource};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use serde_json::Value;
use std::{
	fmt::Debug,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

dyn_clone::clone_trait_object!(StorageProvider);
dyn_eq::eq_trait_object!(StorageProvider);

#[async_trait]
#[typetag::serde(tag = "type")]
/// A trait for any component that can provide a list of files to be processed.
/// This could be a local folder, an S3 bucket, an SFTP connection, etc.
pub trait StorageProvider: DynEq + DynClone + Sync + Send + Debug {
	async fn home(&self) -> Result<PathBuf, Error>;
	fn prefix(&self) -> &'static str;
	async fn metadata(&self, path: &Path) -> Result<Metadata, Error>;
	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error>;
	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error>;
	async fn write(&self, path: &Path, content: &[u8]) -> Result<(), Error>;
	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error>;
	async fn mkdir(&self, path: &Path) -> Result<(), Error>;
	async fn r#move(&self, from: &Path, to: &Path) -> Result<(), Error>;
	async fn copy(&self, from: &Path, to: &Path) -> Result<(), Error>;
	async fn delete(&self, path: &Path) -> Result<(), Error>;
	async fn download(&self, from: &Path) -> Result<PathBuf, Error>;
	async fn download_many(&self, from: &[PathBuf]) -> Result<Vec<PathBuf>, Error>;
	async fn upload(&self, from_local: &Path, to: &Path) -> Result<(), Error>;
	async fn upload_many(&self, from_local: &[PathBuf], to: &[PathBuf]) -> Result<(), Error>;
	async fn hardlink(&self, from: &Path, to: &Path) -> Result<(), Error>;
	async fn symlink(&self, from: &Path, to: &Path) -> Result<(), Error>;
}

pub trait StorageProviderFactory: Send + Sync {
	fn create(&self, config: Value) -> Result<Option<Arc<dyn StorageProvider>>, Error>;
}

```

`organizer/organize-sdk\src\resource.rs`:

```rs
use std::{
	fmt::Display,
	fs::Metadata,
	hash::Hash,
	path::{Path, PathBuf},
	sync::Arc,
};

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use tokio::{fs::File, io::AsyncReadExt, sync::OnceCell};

use crate::{context::ExecutionContext, error::Error, location::Location, plugins::storage::StorageProvider};

#[derive(Debug, Default, Clone)]
pub enum FileState {
	Unknown,
	#[default]
	Exists,
	Deleted,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Resource {
	pub path: PathBuf,
	pub location: Option<Arc<Location>>,
	pub backend: Arc<dyn StorageProvider>,
	#[serde(skip)]
	mime: OnceCell<String>,
	#[serde(skip)]
	bytes: OnceCell<Vec<u8>>,
	#[serde(skip)]
	hash: OnceCell<String>,
	#[serde(skip)]
	metadata: OnceCell<Metadata>,
}

impl AsRef<Path> for Resource {
	fn as_ref(&self) -> &Path {
		self.path.as_path()
	}
}

impl Display for Resource {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.path.display())
	}
}

impl PartialEq for Resource {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path
	}
}

impl Hash for Resource {
	fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
		self.path.hash(state);
	}
}

impl Eq for Resource {}

impl Resource {
	pub fn as_path(&self) -> &Path {
		self.path.as_path()
	}

	pub fn with_filename(self, filename: &str) -> Self {
		let new_path = self.path.with_file_name(filename);
		self.with_path(new_path)
	}

	pub fn with_path(self, new_path: PathBuf) -> Self {
		Self {
			path: new_path,
			location: self.location, // The origin root folder remains the same.
			backend: self.backend,

			// The content, hash, and MIME type of a file do not change when it is moved.
			// We can move these initialized OnceLock fields to the new struct to preserve the cache.
			bytes: self.bytes,
			hash: self.hash,
			mime: self.mime,

			// The filesystem metadata (like modification times of parent dirs) IS different
			// at the new location. We reset this field to force a re-fetch if needed.
			metadata: OnceCell::new(),
		}
	}

	pub fn get_mime(&self) -> &str {
		match self.mime.get() {
			Some(mime) => mime.as_str(),
			None => {
				let mime = mime_guess::from_path(&self.path).first_or_octet_stream().to_string();
				self.mime.set(mime).unwrap();
				self.mime.get().unwrap().as_str()
			}
		}
	}

	pub async fn get_metadata(&self) -> &Metadata {
		match self.metadata.get() {
			Some(metadata) => metadata,
			None => {
				let metadata = self.backend.metadata(&self.path).await.unwrap();
				self.metadata.set(metadata).unwrap();
				self.metadata.get().unwrap()
			}
		}
	}

	pub async fn get_bytes(&self) -> &Vec<u8> {
		match self.bytes.get() {
			Some(content) => content,
			None => {
				let content = self.backend.read(&self.path).await.unwrap();
				self.bytes.set(content).unwrap();
				self.bytes.get().unwrap()
			}
		}
	}

	pub async fn get_hash(&self) -> &String {
		match self.hash.get() {
			Some(hash) => hash,
			None => {
				let mut file = File::open(&self.path).await.unwrap();
				let mut hasher = Sha256::new();
				let mut buffer = [0; 1024];
				loop {
					let count = file.read(&mut buffer).await.unwrap();
					if count == 0 {
						break;
					}
					hasher.update(&buffer[..count]);
				}
				let hash = hasher.finalize();
				let hash_str = format!("{hash:x}");
				self.hash.set(hash_str).unwrap();
				self.hash.get().unwrap()
			}
		}
	}
}

// impl Serialize for Resource {
// 	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
// 	where
// 		S: Serializer,
// 	{
// 		// Serialize the PathBuf that the Arc points to.
// 		self.path.serialize(serializer)
// 	}
// }
//
impl Resource {
	pub fn new(path: &Path, location: Option<Arc<Location>>, backend: Arc<dyn StorageProvider>) -> Self {
		Self {
			path: path.to_path_buf(),
			location,
			backend,
			mime: OnceCell::new(),
			bytes: OnceCell::new(),
			hash: OnceCell::new(),
			metadata: OnceCell::new(),
		}
	}

	pub async fn try_exists(&self, ctx: &ExecutionContext<'_>) -> Result<bool, Error> {
		if ctx.settings.dry_run {
			return match ctx
				.services
				.fs
				.tracked_files
				.get(self.as_path())
				.await
				.unwrap_or(FileState::Unknown)
			{
				FileState::Exists => Ok(true),
				FileState::Deleted => Ok(false),
				FileState::Unknown => Ok(tokio::fs::try_exists(&self.path).await?),
			};
		}

		// Otherwise, check the physical filesystem using the resource's path.
		Ok(tokio::fs::try_exists(&self.path).await?)
	}
}

// #[cfg(test)]
// mod tests {
// 	use super::*;
// 	use std::path::PathBuf;

// 	#[test]
// 	fn new_with_valid_path_succeeds() {
// 		let path = PathBuf::from("/tmp/test.txt");
// 		let root = PathBuf::from("/tmp");
// 		let resource = Resource::new(&path, &root).unwrap();
// 		assert_eq!(resource.path(), &path);
// 		assert_eq!(resource.root(), &root);
// 	}

// 	#[test]
// 	fn new_with_root_path_returns_err() {
// 		let path = PathBuf::from("/");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_dot_path_succeeds_on_windows_fails_on_unix() {
// 		let path = PathBuf::from(".");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_relative_path_succeeds() {
// 		let path = PathBuf::from("some/dir/file.txt");
// 		let result = Resource::new(&path, "some/dir");
// 		assert!(result.is_ok());
// 	}

// 	#[test]
// 	fn new_with_bare_filename_returns_err() {
// 		// A bare filename like "file.txt" has an empty parent, which the new logic correctly rejects.
// 		let path = PathBuf::from("file.txt");
// 		let result = Resource::new(&path, ".");
// 		assert!(result.is_err());
// 	}
// }

```

`organizer/organize-sdk\src\stdx\mod.rs`:

```rs
pub mod path;

```

`organizer/organize-sdk\src\stdx\path.rs`:

```rs
#[cfg(target_family = "windows")]
use std::path::Path;
use std::{ffi::OsStr, path::PathBuf, sync::Arc};

use async_trait::async_trait;

use crate::{context::ExecutionContext, location::Location, plugins::storage::StorageProvider, resource::Resource};

#[async_trait]
pub trait PathExt {
	type HiddenError;
	fn is_hidden(&self) -> Result<bool, Self::HiddenError>;
	async fn expand_user(self, backend: Arc<dyn StorageProvider>) -> PathBuf;
}

#[async_trait]
pub trait PathBufExt {
	async fn as_resource(self, ctx: &ExecutionContext<'_>, location: Option<Arc<Location>>, backend: Arc<dyn StorageProvider>) -> Arc<Resource>;
}

#[async_trait]
impl<T: AsRef<Path> + Sync + Send> PathExt for T {
	#[cfg(target_family = "unix")]
	type HiddenError = std::convert::Infallible;
	#[cfg(target_family = "windows")]
	type HiddenError = std::io::Error;

	async fn expand_user(self, backend: Arc<dyn StorageProvider>) -> PathBuf {
		let path = self.as_ref();
		let mut components = path.components();
		if let Some(component) = components.next() {
			if component.as_os_str() == OsStr::new("~") {
				let mut path = backend.home().await.expect("could not find home directory");
				path.extend(components);
				return path;
			}
		}
		path.to_path_buf()
	}

	#[cfg(target_family = "unix")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		match self.file_name() {
			None => Ok(false),
			Some(filename) => Ok(filename.to_string_lossy().starts_with('.')),
		}
	}

	#[cfg(target_family = "windows")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		use std::{fs, os::windows::prelude::*};
		let metadata = fs::metadata(self)?;
		let attributes = metadata.file_attributes();
		Ok((attributes & 0x2) > 0)
	}
}

#[async_trait]
impl PathBufExt for PathBuf {
	async fn as_resource(self, ctx: &ExecutionContext<'_>, location: Option<Arc<Location>>, backend: Arc<dyn StorageProvider>) -> Arc<Resource> {
		ctx.services
			.fs
			.resources
			.get_with(self.clone(), async move { Arc::new(Resource::new(self.as_ref(), location, backend)) })
			.await
	}
}

```

`organizer/organize-sdk\src\templates\accessor.rs`:

```rs
use crate::{context::ExecutionContext, templates::value::Value};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Accessor);
dyn_eq::eq_trait_object!(Accessor);

/// Represents a compiled and type-safe property path.
///
/// An Accessor is a function object that encapsulates the logic to retrieve a
/// specific value from a given execution context. This is the output of the
/// template compilation process.
#[async_trait]
pub trait Accessor: DynEq + DynClone + Sync + Send + Debug {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value>;
}

```

`organizer/organize-sdk\src\templates\compiler.rs`:

```rs
use crate::{
	error::Error,
	templates::{
		accessor::Accessor,
		registry::SchemaRegistry,
		template::{Template, TemplatePart},
	},
};
use anyhow::Result;

use super::parser::{Expression, Segment, AST};

/// The central compiler for the template system.
/// It uses a SchemaRegistry to validate variables and a full parser to build the template.
#[derive(Debug, Clone)]
pub struct TemplateCompiler {
	schema: SchemaRegistry,
}

impl Default for TemplateCompiler {
	fn default() -> Self {
		Self::new()
	}
}

impl TemplateCompiler {
	/// Creates a new compiler with a default schema registry that discovers
	/// all registered static variable providers.
	pub fn new() -> Self {
		Self {
			schema: SchemaRegistry::new(),
		}
	}

	/// Compiles a raw string into an executable Template object using your parser.
	pub fn compile_template(&self, raw_template: &str) -> Result<Template, Error> {
		// Stage 1: Parse the raw string into an Abstract Syntax Tree (AST)
		// using your provided `AST::parse` method.
		let ast = AST::parse(raw_template)?;
		let mut parts = Vec::new();

		// Stage 2: Walk the AST to build the final, executable Template object.
		for segment in ast.segments {
			match segment {
				Segment::Literal(text) => {
					parts.push(TemplatePart::Static(text));
				}
				Segment::Expression(expr) => {
					let accessor = self.build_accessor(expr)?;
					parts.push(TemplatePart::Dynamic(accessor));
				}
			}
		}

		Ok(Template {
			parts,
			text: raw_template.to_string(),
		})
	}

	/// Builds a type-safe accessor from a parsed expression AST node.
	/// This is the bridge between your parser and the execution engine.
	fn build_accessor(&self, expr: Expression) -> Result<Box<dyn Accessor>, Error> {
		match expr {
			Expression::Variable(parts) => {
				// We use the existing SchemaRegistry to validate the path and get the accessor.
				let parts_str: Vec<&str> = parts.iter().map(AsRef::as_ref).collect();
				self.schema.parse_property_chain(&parts_str)
			}
		}
	}
}

```

`organizer/organize-sdk\src\templates\engine.rs`:

```rs
use std::env::VarError;

use thiserror::Error;


#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Templater;

#[derive(Error, Debug)]
pub enum TemplateError {
	#[error("variable '{variable}' (fields={fields:?}) cannot be resolved.")]
	UndefinedVariable {
		variable: String,
		fields: Vec<String>,
		#[source]
		source: VarError,
	},

	#[error("empty template")]
	EmptyTemplate,

	#[error("variable '{variable}' could not be deserialized. It may be missing fields or they may be wrong.")]
	DeserializationError {
		#[source]
		source: serde_json::Error,
		variable: String,
		fields: Vec<String>,
	},

	#[error("variable {variable} does not accept any fields, but received {fields:?}")]
	FieldsNotSupported { variable: String, fields: Vec<String> },

	#[error("invalid variable ({variable}): it requires {missing_piece} to be in scope")]
	InvalidContext { missing_piece: String, variable: String },

	#[error("variable '{variable}' does not support a '{field}' subfield")]
	InvalidField { variable: String, field: String },

	#[error("variable '{variable}' requires a field (one of: {fields})")]
	MissingField { variable: String, fields: String },

	#[error("unknown variable '{{{{ {0} }}}}'")]
	UnknownVariable(String),

	#[error("variable '{variable}' requires one of the following fields: {fields:?}")]
	RequiredField { variable: String, fields: Vec<String> },
}

// #[cfg(test)]
// mod tests {
// 	use std::convert::{TryFrom, TryInto};

// 	use super::*;
// 	use crate::{config::{context::RunServices, variables::simple::SimpleVariable}, resource::Resource};

// 	#[test]
// 	fn render_template_not_present_in_engine() {
// 		let engine = Templater::default();
// 		let template = Template::try_from("Hello, {{ name }}!").unwrap();
// 		let context = Context::new(ctx)
// 		let mut context = engine.context().build(&engine);
// 		context.insert("name", "Andrés");
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}

// 	#[test]
// 	fn render_template_present_in_engine() {
// 		let mut engine = Templater::default();
// 		let template = Template::try_from("This is a stored template.").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("This is a stored template.".to_string()));
// 	}

// 	#[test]
// 	fn render_with_simple_variable() {
// 		let var = SimpleVariable {
// 			name: "location".into(),
// 			value: "world".try_into().unwrap(),
// 		};
// 		let mut engine = Templater::new(&vec![Box::new(var)]);
// 		let template = Template::try_from("Hello, {{ location }}!").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("Hello, world!".to_string()));
// 	}

// 	#[test]
// 	fn render_with_path_context() {
// 		let mut engine = Templater::default();
// 		let resource = Resource::new_tmp("test.txt");
// 		let template = Template::try_from("The path is {{ path | stem }}").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().path(resource.path().to_path_buf()).build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("The path is test".to_string()));
// 	}

// 	#[test]
// 	fn render_invalid_template_returns_none() {
// 		let engine = Templater::default();
// 		// Invalid syntax: `{%` instead of `{{`
// 		let template = Template::try_from("Hello, {% name }}!").unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}
// }

```

`organizer/organize-sdk\src\templates\grammar.pest`:

```pest
// Whitespace is handled inside expressions but is significant in literals.
// We will trim inside the Rust code where needed.
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

// An identifier is a letter followed by alphanumeric characters or underscores.
identifier = @{ ('a'..'z' | 'A'..'Z') ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_")* }

// A variable is one or more identifiers separated by dots.
variable = { identifier ~ ("." ~ identifier)* }

// A delimited expression, e.g., "{{ file.name }}"
moustache = { "{{" ~ WHITESPACE* ~ variable ~ WHITESPACE* ~ "}}" }

// A literal is any sequence of characters that is NOT an opening delimiter.
// The `+` ensures we match one or more characters.
literal = @{ (!( "{{" | "}}" ) ~ ANY)+ }

// The top-level rule for the entire template string.
template = { SOI ~ (literal | moustache)* ~ EOI }

```

`organizer/organize-sdk\src\templates\mod.rs`:

```rs
pub mod accessor;
pub mod compiler;
pub mod engine;
pub mod filter;
pub mod parser;
pub mod registry;
pub mod schema;
pub mod template;
pub mod value;
pub mod variable;

```

`organizer/organize-sdk\src\templates\parser.rs`:

```rs
use pest::{iterators::Pair, Parser};
use pest_derive::Parser;
use thiserror::Error;

// The AST definitions are moved here. They remain unchanged.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Expression {
	Variable(Vec<String>),
}

#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Segment {
	Literal(String),
	Expression(Expression),
}

#[derive(Debug, PartialEq, Clone, Eq)]
pub struct AST {
	pub segments: Vec<Segment>,
}

// A new, simpler error enum for the pest parser.
#[derive(Error, Debug)]
pub enum ParseError {
	#[error("Mismatched delimiters: found '{{' with no closing '}}'")]
	MismatchedDelimiters,
	#[error("Pest parser error: {0}")]
	Pest(#[from] Box<pest::error::Error<Rule>>),
}

// This struct links our code to the grammar file.
#[derive(Parser)]
#[grammar = "templates/grammar.pest"]
struct PestParser;

fn build_expression_ast(pair: Pair<Rule>) -> Expression {
	match pair.as_rule() {
		Rule::variable => {
			let parts = pair.into_inner().map(|p| p.as_str().to_string()).collect();
			Expression::Variable(parts)
		}
		_ => unreachable!("build_expression_ast expects an expression rule, found {:?}", pair.as_rule()),
	}
}

impl AST {
	/// Parses the entire template string using the pest grammar.
	/// This method now delegates all parsing to pest, which handles the
	/// entire structure of the template, including literals and delimiters.
	pub fn parse(s: &str) -> Result<Self, ParseError> {
		// If the input is empty, return an empty AST.
		if s.is_empty() {
			return Ok(AST { segments: vec![] });
		}

		// Parse the entire string with the top-level `template` rule.
		// This gives us an iterator directly over `literal` and `delimited_expression` pairs.
		let pairs = PestParser::parse(Rule::template, s)?.next().unwrap().into_inner();
		let mut segments = Vec::new();

		for pair in pairs {
			match pair.as_rule() {
				Rule::literal => {
					segments.push(Segment::Literal(pair.as_str().to_string()));
				}
				Rule::moustache => {
					// Go inside `{{...}}` to get the actual `expression`.
					let inner_expr_pair = pair.into_inner().next().unwrap();
					let expression = build_expression_ast(inner_expr_pair);
					segments.push(Segment::Expression(expression));
				}
				Rule::EOI => (), // End-of-input is expected, do nothing.
				_ => unreachable!("Unexpected top-level rule: {:?}", pair.as_rule()),
			}
		}

		Ok(AST { segments })
	}
}

// Helper to convert pest errors into our custom ParseError.
impl From<pest::error::Error<Rule>> for ParseError {
	fn from(error: pest::error::Error<Rule>) -> Self {
		ParseError::Pest(Box::new(error))
	}
}

```

`organizer/organize-sdk\src\templates\registry.rs`:

```rs
use std::collections::HashMap;

use crate::{
	error::Error,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		variable::VariableInventory,
	},
};

/// The central schema registry and compiler for template variables.
///
/// It discovers all variable providers at startup and uses their schemas
/// to parse and validate property chains.
#[derive(Clone, Debug)]
pub struct SchemaRegistry {
	/// A map of all discovered static schemas for fast lookups by name.
	root_properties: HashMap<&'static str, Property>,
}

impl Default for SchemaRegistry {
	fn default() -> Self {
		Self::new()
	}
}

impl SchemaRegistry {
	/// Creates a new registry by discovering all registered `Variable` providers
	/// via the `inventory` crate.
	pub fn new() -> Self {
		let root_properties = inventory::iter::<VariableInventory>
			.into_iter()
			.map(|inv| {
				let schema = inv.provider.schema();
				// The key is the static name of the variable (e.g., "file").
				(schema.name, schema)
			})
			.collect();

		Self { root_properties }
	}

	/// Parses a property chain against the compiled schema to get an Accessor.
	pub fn parse_property_chain(&self, parts: &[&str]) -> Result<Box<dyn Accessor>, Error> {
		if parts.is_empty() {
			return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(
				"Property chain cannot be empty.".to_string(),
			)));
		}

		let root_part = parts[0];
		let mut current_prop = self.root_properties.get(root_part).ok_or_else(|| {
			let valid_options: Vec<_> = self.root_properties.keys().collect();
			Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Invalid root variable '{root_part}'. Valid options are: {valid_options:?}"
			)))
		})?;

		// Traverse the rest of the chain.
		for (i, &part) in parts.iter().skip(1).enumerate() {
			match &current_prop.node {
				SchemaNode::Object(properties) => {
					current_prop = properties.iter().find(|p| p.name == part).ok_or_else(|| {
						let valid_options: Vec<_> = properties.iter().map(|p| p.name).collect();
						Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Invalid property '{}' at index {}. Valid options for '{}' are: {:?}",
							part,
							i + 1,
							parts[..i + 1].join("."),
							valid_options
						)))
					})?;
				}
				SchemaNode::DynamicMap(constructor) => {
					if i + 2 < parts.len() {
						return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Cannot access properties on a dynamic value. Chain has too many parts after key '{}' in '{}'.",
							part,
							parts.join(".")
						))));
					}
					// The chain ends here. Call the constructor with the key.
					return Ok(constructor(part));
				}
				SchemaNode::Terminal(_) => {
					return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
						"Cannot access property '{}' on a terminal value at '{}'.",
						part,
						parts[..i + 1].join(".")
					))));
				}
			}
		}

		// After the loop, the final node must be a Terminal.
		match &current_prop.node {
			SchemaNode::Terminal(constructor) => Ok(constructor()),
			_ => Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Incomplete property chain '{}'. It points to an object, not a final value.",
				parts.join(".")
			)))),
		}
	}
}

```

`organizer/organize-sdk\src\templates\schema.rs`:

```rs
use crate::templates::accessor::Accessor;
use std::{fmt::Debug, sync::Arc};

pub type TerminalAccessorConstructor = Arc<dyn Fn() -> Box<dyn Accessor> + Send + Sync>;
pub type DynamicMapAccessorConstructor = Arc<dyn Fn(&str) -> Box<dyn Accessor> + Send + Sync>;

#[derive(Clone)]
pub enum SchemaNode {
	/// A terminal node that creates a specific, type-safe Accessor.
	Terminal(TerminalAccessorConstructor),
	/// An object node with a fixed, known set of sub-properties.
	Object(Vec<Property>),
	/// A map node where sub-properties are dynamic keys.
	DynamicMap(DynamicMapAccessorConstructor),
}

#[derive(Clone)]
pub struct Property {
	pub name: &'static str,
	pub node: SchemaNode,
}

impl Debug for SchemaNode {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			SchemaNode::Terminal(_) => f.debug_tuple("Terminal").field(&"<closure>").finish(),
			SchemaNode::Object(properties) => f.debug_tuple("Object").field(properties).finish(),
			SchemaNode::DynamicMap(_) => f.debug_tuple("DynamicMap").field(&"<closure>").finish(),
		}
	}
}

// Manual `Debug` implementation for `Property`
impl Debug for Property {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("Property")
			.field("name", &self.name)
			.field("node", &self.node)
			.finish()
	}
}

```

`organizer/organize-sdk\src\templates\template.rs`:

```rs
use serde::{Deserialize, Serialize};

use crate::{context::ExecutionContext, error::Error, templates::accessor::Accessor};

#[derive(Debug, Eq, PartialEq, Clone)]
pub enum TemplatePart {
	Static(String),
	Dynamic(Box<dyn Accessor>),
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct TemplateString(pub String);

impl std::ops::Deref for TemplateString {
	type Target = String;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]
pub struct Template {
	pub text: String,
	#[serde(skip)]
	pub parts: Vec<TemplatePart>,
}

impl Template {
	pub async fn render(&self, ctx: &ExecutionContext<'_>) -> Result<String, Error> {
		let mut output = String::new();
		for part in &self.parts {
			match part {
				TemplatePart::Static(s) => output.push_str(s),
				TemplatePart::Dynamic(accessor) => {
					let value = accessor.get(ctx).await?;
					output.push_str(&value.to_string());
				}
			}
		}
		Ok(output)
	}
}

```

`organizer/organize-sdk\src\templates\value.rs`:

```rs
use std::fmt;

/// Represents any possible value that can be retrieved from a template variable.
/// This enum provides type safety for the data flowing through the template engine.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
	String(String),
	OptionString(Option<String>),
	// Add other types as needed, e.g., Int(i64), Bool(bool)
	Null,
}

impl fmt::Display for Value {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			Value::String(s) => write!(f, "{s}"),
			Value::OptionString(Some(s)) => write!(f, "{s}"),
			Value::OptionString(None) | Value::Null => Ok(()), // Render None/Null as empty string
		}
	}
}

```

`organizer/organize-sdk\src\templates\variable.rs`:

```rs
use crate::templates::schema::Property;

/// The plugin interface for a static variable provider.
///
/// Any struct implementing this trait can be automatically discovered and
/// integrated into the template engine's schema. This trait is intended for
/// built-in variables with fixed schemas, like `file` or `env`.
pub trait StatelessVariable: Sync + Send {
	/// Returns the canonical name of the root variable (e.g., "file", "env").
	fn name(&self) -> &'static str;

	/// Returns the schema for this variable, defining its properties and accessors.
	fn schema(&self) -> Property;
}

/// The collectible struct for the `inventory` crate.
/// It holds a static reference to an object that implements our `Variable` trait.
pub struct VariableInventory {
	pub provider: &'static (dyn StatelessVariable + Sync),
}

// Declare the global collection for automatic registration of static variable providers.
inventory::collect!(VariableInventory);

```

`organizer/organize-sdk\src\utils\mod.rs`:

```rs
pub fn enabled() -> bool {
	true
}

```

`organizer/organize-std\Cargo.toml`:

```toml
[package]
name = "organize-std"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2021"
description = "The standard library of components for the organize project."
repository = "https://github.com/cbr9/organizer"

[dependencies]
organize-sdk = { path = "../organize-sdk" }
anyhow.workspace = true
async-trait = "0.1.88"
serde = { workspace = true }
typetag = { workspace = true }
tracing = "0.1.41"
rand = "0.9.1"
inventory = "0.3.20"
tokio = { version = "1.46.0", features = ["full"] }
dirs.workspace = true
libc = "0.2.174"
num_cpus = "1.16.0"
walkdir = "2.5.0"
futures = "0.3.31"
tokio-stream = "0.1"
russh = "0.53.0"
russh-sftp = "2.1.1"
dyn-clone.workspace = true
dyn-eq.workspace = true
tempfile = "3.20.0"
path-clean = "1.0.1"
deadpool = "0.12.2"




```

`organizer/organize-std\src\actions\copy.rs`:

```rs
use anyhow::Result;
use async_trait::async_trait;
use organize_sdk::{
	context::{scope::ExecutionScope, services::fs::manager::DestinationBuilder, ExecutionContext},
	engine::ExecutionModel,
	error::Error,
	plugins::action::{Action, ActionBuilder, Input, Receipt},
	stdx::path::PathBufExt,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct Copy(DestinationBuilder);

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct CopyBuilder(DestinationBuilder);

#[async_trait]
#[typetag::serde(name = "copy")]
impl ActionBuilder for CopyBuilder {
	async fn build(&self, _ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error> {
		Ok(Box::new(Copy(self.0.clone())))
	}
}

#[async_trait]
#[typetag::serde(name = "copy")]
impl Action for Copy {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::Batch
	}

	async fn commit(&self, ctx: &ExecutionContext<'_>) -> Result<Receipt, Error> {
		let batch = ctx.scope.batch()?;
		let mut inputs = Vec::new();
		let mut outputs = Vec::new();
		let mut to_resources = Vec::new();

		for from_resource in &batch.files {
			let scope = ExecutionScope::new_resource_scope(ctx.scope.rule()?, from_resource.clone());
			let ctx = ctx.with_scope(scope);
			let to_path = self.0.clone().build(&ctx)?.resolve(&ctx).await?;
			let to_backend = ctx.services.fs.get_provider(&to_path.to_string_lossy())?;
			let to_resource = to_path.as_resource(&ctx, None, to_backend).await;
			to_resources.push(to_resource);
			inputs.push(Input::Processed(from_resource.clone()));
		}

		ctx.services.fs.copy_many(&batch.files, &to_resources).await?;

		for to_resource in to_resources {
			outputs.push(organize_sdk::plugins::action::Output::Created(to_resource));
		}

		let receipt = Receipt {
			inputs,
			outputs,
			next: batch.files.clone(),
			..Default::default()
		};
		Ok(receipt)
	}
}

```

`organizer/organize-std\src\actions\echo.rs`:

```rs
use async_trait::async_trait;
use organize_sdk::{
	context::ExecutionContext,
	error::Error,
	plugins::action::{Action, ActionBuilder, Receipt},
	templates::template::{Template, TemplateString},
};
use serde::{Deserialize, Serialize};

use anyhow::Result;

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct EchoBuilder {
	pub message: TemplateString,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl ActionBuilder for EchoBuilder {
	async fn build(&self, ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error> {
		let message = ctx.services.compiler.compile_template(&self.message)?;
		Ok(Box::new(Echo { message }))
	}
}

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct Echo {
	pub message: Template,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl Action for Echo {
	async fn commit(&self, ctx: &ExecutionContext<'_>) -> Result<Receipt, Error> {
		self.message
			.render(ctx)
			.await
			.inspect(|message| tracing::info!("{}", message))?;
		Ok(Receipt {
			next: vec![ctx.scope.resource()?],
			..Default::default()
		})
	}
}

```

`organizer/organize-std\src\actions\mod.rs`:

```rs
pub mod echo;
pub mod copy;
// pub mod r#move;

```

`organizer/organize-std\src\filters\empty.rs`:

```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::{path::PathBuf, sync::Arc};

use anyhow::Result;

use organize_sdk::{context::ExecutionContext, error::Error, plugins::filter::Filter, resource::Resource};

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct Empty;

#[async_trait]
#[typetag::serde(name = "empty")]
impl Filter for Empty {
	async fn filter(&self, check: Option<&PathBuf>, ctx: &ExecutionContext) -> Result<Vec<Arc<Resource>>, Error> {
		let resource = ctx.scope.resource()?;
		let path = check.unwrap_or(&resource.path);

		let backend = &resource.backend;
		let content = backend.read(path).await?;

		if content.is_empty() {
			Ok(vec![resource.clone()])
		} else {
			Ok(vec![])
		}
	}
}

```

`organizer/organize-std\src\filters\mod.rs`:

```rs
pub mod empty;

```

`organizer/organize-std\src\lib.rs`:

```rs
#![feature(addr_parse_ascii)]

pub mod actions;
pub mod filters;
pub mod partitioners;
pub mod selectors;
pub mod sorters;
pub mod storage;
pub mod variables;

```

`organizer/organize-std\src\partitioners\extension.rs`:

```rs
use async_trait::async_trait;
use organize_sdk::{engine::batch::Batch, error::Error, plugins::partitioner::Partitioner};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ExtensionPartitioner;

#[async_trait]
#[typetag::serde(name = "extension")]
impl Partitioner for ExtensionPartitioner {
	fn name(&self) -> &str {
		self.typetag_name()
	}

	async fn partition(&self, batch: &Batch) -> Result<HashMap<String, Batch>, Error> {
		let mut groups: HashMap<String, Batch> = HashMap::new();
		for resource in &batch.files {
			let extension = resource
				.path
				.extension()
				.and_then(|s| s.to_str())
				.unwrap_or("no_extension")
				.to_string();
			groups
				.entry(extension.clone())
				.or_default()
				.files
				.push(resource.clone());
		}
		Ok(groups)
	}
}

```

`organizer/organize-std\src\partitioners\mod.rs`:

```rs
pub mod extension;
pub mod ratio;

```

`organizer/organize-std\src\partitioners\ratio.rs`:

```rs
use async_trait::async_trait;
use organize_sdk::{engine::batch::Batch, error::Error, plugins::partitioner::Partitioner};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, iter::FromIterator};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RatioPartitioner {
	/// Captures arbitrary split names and their corresponding ratios,
	/// e.g., `test = 0.2`, `train = 0.8`.
	#[serde(flatten)]
	pub ratios: HashMap<String, f64>,
}

impl Eq for RatioPartitioner {}

impl PartialEq for RatioPartitioner {
	fn eq(&self, other: &Self) -> bool {
		// First, check if the number of entries is the same
		if self.ratios.len() != other.ratios.len() {
			return false;
		}

		let epsilon = 1e-9; // Define your tolerance for f64 comparison

		// Iterate over the keys and compare values
		for (key, self_value) in &self.ratios {
			if let Some(other_value) = other.ratios.get(key) {
				// Check if the absolute difference is within epsilon
				if (self_value - other_value).abs() >= epsilon {
					return false; // Values are not "nearly equal"
				}
			} else {
				return false; // Key exists in self but not in other
			}
		}
		true // All keys and values are "nearly equal"
	}
}

#[async_trait]
#[typetag::serde(name = "ratio")]
impl Partitioner for RatioPartitioner {
	fn name(&self) -> &str {
		self.typetag_name()
	}

	async fn partition(&self, batch: &Batch) -> Result<HashMap<String, Batch>, Error> {
		// 1. Validate that the ratios sum to approximately 1.0
		let total_ratio: f64 = self.ratios.values().sum();
		if (total_ratio - 1.0).abs() > 1e-9 {
			return Err(Error::Other(anyhow::anyhow!(
				"Ratios for splitter must sum to 1.0, but they sum to {}",
				total_ratio
			)));
		}

		// 2. Calculate and distribute files
		let mut result_batches = Vec::new();
		let mut remaining_files = batch.files.as_slice();
		let total_files = batch.files.len();

		// The user is responsible for shuffling, so we process files in the given order.
		for (name, &ratio) in &self.ratios {
			let num_to_take = (total_files as f64 * ratio).round() as usize;
			let num_to_take = num_to_take.min(remaining_files.len());
			let (split_files_slice, rest) = remaining_files.split_at(num_to_take);

			let mut new_batch = Batch::new();
			new_batch.files = split_files_slice.to_vec();

			result_batches.push((name.clone(), new_batch));
			remaining_files = rest;
		}

		// 3. To ensure deterministic behavior, distribute any leftover files (due to rounding)
		//    to the last batch.
		if !remaining_files.is_empty() {
			if let Some(last_batch) = result_batches.last_mut() {
				last_batch.1.files.extend_from_slice(remaining_files);
			}
		}

		let batches = HashMap::from_iter(result_batches);

		Ok(batches)
	}
}

```

`organizer/organize-std\src\selectors\first.rs`:

```rs
use anyhow::Result;
use async_trait::async_trait;
use organize_sdk::{engine::batch::Batch, error::Error, plugins::selector::Selector};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FirstSelector {
	pub n: usize,
}

#[async_trait]
#[typetag::serde(name = "first")]
impl Selector for FirstSelector {
	async fn select(&self, batch: &Batch) -> Result<Batch, Error> {
		let mut selected_batch = Batch::new();
		selected_batch.files = batch.files.iter().take(self.n).cloned().collect();
		// The context from the original batch is not preserved by default,
		// as it might not be relevant to the new, smaller batch.
		Ok(selected_batch)
	}
}

```

`organizer/organize-std\src\selectors\mod.rs`:

```rs
pub mod first;

```

`organizer/organize-std\src\sorters\mod.rs`:

```rs
pub mod random;

```

`organizer/organize-std\src\sorters\random.rs`:

```rs
use async_trait::async_trait;
use organize_sdk::{plugins::sorter::Sorter, resource::Resource};
use rand::{rng, seq::SliceRandom};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub struct RandomSorter;

#[async_trait]
#[typetag::serde(name = "random")]
impl Sorter for RandomSorter {
	async fn sort(&self, files: &mut [Arc<Resource>]) {
		let mut rng = rng();
		files.shuffle(&mut rng);
	}
}

```

`organizer/organize-std\src\storage\local.rs`:

```rs
use std::{
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

use anyhow::{Context as ErrorContext, Result};
use async_trait::async_trait;
use futures::{stream, StreamExt, TryStreamExt};
use organize_sdk::{
	context::ExecutionContext,
	error::Error,
	location::{
		options::{Options, Target},
		Location,
	},
	plugins::storage::StorageProvider,
	resource::Resource,
	stdx::path::{PathBufExt, PathExt},
};
use serde::{Deserialize, Serialize};
use walkdir::WalkDir;

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct LocalFileSystem;

#[async_trait]
#[typetag::serde(name = "local")]
impl StorageProvider for LocalFileSystem {
	fn prefix(&self) -> &'static str {
		"file"
	}

	async fn home(&self) -> Result<PathBuf, Error> {
		Ok(dirs::home_dir().context("unable to find home directory")?)
	}

	async fn mkdir(&self, path: &Path) -> Result<(), Error> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		Ok(())
	}

	async fn r#move(&self, from: &Path, to: &Path) -> Result<(), Error> {
		// ctx.services.fs.ensure_parent_dir_exists(destination.as_path()).await?;
		self.mkdir(to).await?;
		match tokio::fs::rename(from, to).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					from.display(),
					to.display()
				);

				tokio::fs::copy(from, to).await?;
				Ok(tokio::fs::remove_file(from).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}

	async fn copy(&self, from: &Path, to: &Path) -> Result<(), Error> {
		self.mkdir(to).await?;

		let mut dirs = Vec::new();
		let mut files = Vec::new();
		for entry in WalkDir::new(from).into_iter().filter_map(|e| e.ok()) {
			if entry.path().is_dir() {
				dirs.push(entry.path().to_path_buf());
			} else {
				files.push(entry.path().to_path_buf());
			}
		}

		for dir in dirs {
			let relative_path = dir.strip_prefix(from).unwrap();
			let dest_path = to.join(relative_path);
			tokio::fs::create_dir_all(&dest_path).await?;
		}

		let copy_futures = files.into_iter().map(|file| {
			let relative_path = file.strip_prefix(from).unwrap().to_path_buf();
			let dest_path = to.join(relative_path);
			async move { tokio::fs::copy(file, dest_path).await.map(|_| ()).map_err(Error::from) }
		});

		stream::iter(copy_futures)
			.buffer_unordered(num_cpus::get())
			.try_collect::<()>()
			.await?;

		Ok(())
	}

	async fn delete(&self, path: &Path) -> Result<(), Error> {
		if path.is_dir() {
			tokio::fs::remove_dir_all(path).await.map_err(Error::from)
		} else {
			tokio::fs::remove_file(path).await.map_err(Error::from)
		}
	}

	async fn download(&self, from: &Path) -> Result<PathBuf, Error> {
		Ok(from.to_path_buf())
	}

	async fn download_many(&self, from: &[PathBuf]) -> Result<Vec<PathBuf>, Error> {
		Ok(from.to_vec())
	}

	async fn upload(&self, from_local: &Path, to: &Path) -> Result<(), Error> {
		self.mkdir(to).await?;
		tokio::fs::copy(from_local, to).await.map_err(Error::Io).map(|_| ())
	}

	async fn upload_many(&self, from_local: &[PathBuf], to: &[PathBuf]) -> Result<(), Error> {
		if from_local.len() != to.len() {
			return Err(Error::Other(anyhow::anyhow!(
				"Mismatched number of source and destination paths for upload_many"
			)));
		}
		for (from, to) in from_local.iter().zip(to.iter()) {
			self.mkdir(to).await?;
			tokio::fs::copy(from, to).await.map_err(Error::Io).map(|_| ())?;
		}
		Ok(())
	}

	async fn hardlink(&self, from: &Path, to: &Path) -> Result<(), Error> {
		self.mkdir(to).await?;
		tokio::fs::hard_link(from, to).await.map_err(Error::from)
	}

	async fn symlink(&self, from: &Path, to: &Path) -> Result<(), Error> {
		self.mkdir(to).await?;
		#[cfg(unix)]
		{
			tokio::fs::symlink(from, to).await.map_err(Error::from)
		}
		#[cfg(windows)]
		{
			if from.is_dir() {
				tokio::fs::symlink_dir(from, to).await.map_err(Error::from)
			} else {
				tokio::fs::symlink_file(from, to).await.map_err(Error::from)
			}
		}
	}

	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error> {
		let location = Arc::new(location.clone());
		let backend = ctx.services.fs.get_provider(&location.host)?;
		let resources = WalkDir::new(&location.path)
			.min_depth(location.options.min_depth)
			.max_depth(location.options.max_depth)
			.follow_links(location.options.follow_symlinks)
			.into_iter()
			.filter_entry(|entry| self.filter_entry(entry, &location.options))
			.filter_map(|e| e.ok())
			.map(|entry| {
				let path_buf = entry.path().to_path_buf();
				path_buf.as_resource(ctx, Some(location.clone()), backend.clone())
			})
			.collect::<Vec<_>>();

		let resources = stream::iter(resources)
			.buffer_unordered(num_cpus::get())
			.collect::<Vec<_>>()
			.await;

		Ok(resources)
	}

	async fn metadata(&self, path: &Path) -> Result<Metadata, Error> {
		Ok(tokio::fs::metadata(path).await?)
	}

	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error> {
		let mut dir = tokio::fs::read_dir(path).await?;
		let mut paths = vec![];
		while let Some(entry) = dir.next_entry().await? {
			paths.push(entry.path());
		}
		Ok(paths)
	}

	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error> {
		Ok(tokio::fs::read(path).await?)
	}

	async fn write(&self, path: &Path, content: &[u8]) -> Result<(), Error> {
		tokio::fs::write(path, content).await.map_err(Error::from)
	}
}

impl LocalFileSystem {
	fn filter_entry(&self, entry: &walkdir::DirEntry, options: &Options) -> bool {
		if options.exclude.contains(&entry.path().to_path_buf()) {
			return false;
		}
		if entry.path().is_file() && options.target == Target::Folders {
			return false;
		}
		if entry.path().is_dir() && options.target == Target::Files {
			return true;
		}

		if entry.path().is_file() {
			if let Some(extension) = entry.path().extension() {
				let partial_extensions = &["crdownload", "part", "download"];
				if partial_extensions.contains(&&*extension.to_string_lossy()) && !options.partial_files {
					return false;
				}
			}
			if entry.path().is_hidden().unwrap_or(false) && !options.hidden_files {
				return false;
			}
		}
		true
	}
}

```

`organizer/organize-std\src\storage\mod.rs`:

```rs
pub mod local;
pub mod sftp;

```

`organizer/organize-std\src\storage\sftp.rs`:

```rs
use std::{
	fmt::{Debug, Formatter},
	fs::Metadata,
	net::{IpAddr, SocketAddr},
	path::{Path, PathBuf},
	sync::Arc,
};

use deadpool::managed::{self, Metrics, Object, Pool, RecycleResult};
use russh_sftp::client::SftpSession;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

use anyhow::{Context, Result};
use async_trait::async_trait;
use futures::future::BoxFuture;
use russh::{
	client::{self, Handle},
	keys::{agent::client::AgentClient, Algorithm},
	Channel,
};
use serde::{Deserialize, Serialize};
use tempfile::NamedTempFile;
use tokio::sync::OnceCell;

use organize_sdk::{
	context::ExecutionContext,
	error::Error,
	location::{options::Options, Location},
	plugins::storage::StorageProvider,
	resource::Resource,
	stdx::path::PathBufExt,
};

#[derive(Serialize, Deserialize)]
pub struct Sftp {
	pub address: IpAddr,
	pub port: u16,
	pub username: String,
	pub private_key: Option<PathBuf>,
	#[serde(skip)]
	pub pool: OnceCell<SftpPool>,
}

impl PartialEq for Sftp {
	fn eq(&self, other: &Self) -> bool {
		self.address == other.address && self.port == other.port && self.username == other.username
	}
}

impl Eq for Sftp {}

impl Debug for Sftp {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("Sftp")
			.field("address", &self.address)
			.field("port", &self.port)
			.field("username", &self.username)
			.finish()
	}
}

impl Clone for Sftp {
	fn clone(&self) -> Self {
		Self {
			address: self.address.clone(),
			port: self.port.clone(),
			username: self.username.clone(),
			private_key: self.private_key.clone(),
			pool: self.pool.clone(),
		}
	}
}

pub struct Client;

impl client::Handler for Client {
	type Error = anyhow::Error;

	async fn check_server_key(&mut self, _server_public_key: &russh::keys::PublicKey) -> Result<bool, Self::Error> {
		Ok(true)
	}
}

impl managed::Manager for Sftp {
	type Error = Error;
	type Type = SftpSession;

	/// Creates a new, authenticated SftpSession.
	async fn create(&self) -> Result<SftpSession, Self::Error> {
		let session = self.connect().await?;
		// 3. Open a channel and request the SFTP subsystem
		let channel: Channel<client::Msg> = session.channel_open_session().await.context("Failed to open session channel")?;
		channel
			.request_subsystem(true, "sftp")
			.await
			.context("Failed to request SFTP subsystem")?;

		// 4. Create the SftpSession
		SftpSession::new(channel.into_stream()).await.map_err(|e| Error::SFTP(e))
	}

	/// Checks if a connection is still valid before lending it out.
	async fn recycle(&self, session: &mut Self::Type, _metrics: &Metrics) -> RecycleResult<Self::Error> {
		// A simple, low-cost operation to check if the session is alive.
		match session.canonicalize(".").await {
			Ok(_) => Ok(()),
			Err(e) => {
				tracing::warn!("Recycling SFTP session failed, discarding. Error: {}", e);
				// The error indicates the connection is broken.
				Err(managed::RecycleError::Message(e.to_string().into()))
			}
		}
	}
}

/// The main runtime struct which holds the connection pool.
/// This struct is NOT serializable directly. It is created from an SftpConfig.
pub type SftpPool = Arc<managed::Pool<Sftp>>;

impl Sftp {
	/// Creates a new Sftp provider with a connection pool.
	pub async fn pool(&self) -> Result<&Arc<Pool<Sftp>>, Error> {
		let pool = self
			.pool
			.get_or_try_init(|| async {
				let pool = managed::Pool::builder(self.clone())
					.max_size(5) // Max 16 concurrent connections
					.build()
					.map(|pool| Arc::new(pool))
					.map_err(|e| Error::Other(e.into()))?;
				Ok::<Arc<Pool<Sftp>>, Error>(pool)
			})
			.await?;
		Ok(pool)
	}
}
impl Sftp {
	/// Establishes a full connection, authenticates, and creates an SftpSession.
	/// This is the main change: each public-facing operation will create and tear down
	/// a connection. This is necessary for compatibility with servers that only allow
	/// one SFTP subsystem per connection (e.g., using `ForceCommand`).
	async fn connect(&self) -> Result<Handle<Client>, Error> {
		// 1. Establish the underlying SSH session
		let config = Arc::new(russh::client::Config::default());
		let socket = SocketAddr::new(self.address, self.port);
		let mut session = client::connect(config, socket, Client)
			.await
			.context("Could not establish SSH connection")?;

		// 2. Authenticate using the SSH agent
		let client_pipe = tokio::net::windows::named_pipe::ClientOptions::new()
			.open(r"\\.\pipe\openssh-ssh-agent")
			.context("Could not connect to the SSH agent pipe. Is 1Password or another agent running?")?;

		let hash_alg = session.best_supported_rsa_hash().await?.flatten();

		let mut authenticated = false;
		let mut agent = AgentClient::connect(client_pipe);
		let identities = agent.request_identities().await.unwrap();
		for identity in identities {
			let alg = match identity.algorithm() {
				Algorithm::Dsa | Algorithm::Rsa { .. } => hash_alg,
				_ => None,
			};

			let auth_result = session
				.authenticate_publickey_with(&self.username, identity, alg, &mut agent)
				.await
				.unwrap();
			if auth_result.success() {
				tracing::debug!("Authenticated successfully with SSH agent.");
				authenticated = true;
				break;
			}
		}

		if !authenticated {
			return Err(Error::Other(anyhow::anyhow!(
				"Authentication failed: No valid keys found in the agent for the given user."
			)));
		}
		Ok(session)
	}
}

#[async_trait]
#[typetag::serde(name = "sftp")]
impl StorageProvider for Sftp {
	async fn home(&self) -> Result<PathBuf, Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let path = session.canonicalize(".").await?;
		Ok(path.into())
	}

	fn prefix(&self) -> &'static str {
		"sftp"
	}

	async fn metadata(&self, _path: &Path) -> Result<Metadata, Error> {
		Err(Error::ImpossibleOp("SFTP does not support std::fs::Metadata".to_string()))
	}

	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let entries = session.read_dir(path.to_string_lossy()).await?;
		let paths: Vec<PathBuf> = entries.into_iter().map(|p| p.file_name().into()).collect();
		Ok(paths)
	}

	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error> {
		println!("READING: {}", path.display());
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let mut file = session.open(path.to_str().unwrap()).await?;
		let mut buf = Vec::new();
		file.read_to_end(&mut buf).await?;
		Ok(buf)
	}

	async fn write(&self, path: &Path, content: &[u8]) -> Result<(), Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let mut file = session.create(path.to_str().unwrap()).await?;
		file.write_all(content).await?;
		Ok(())
	}

	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error> {
		let mut files = Vec::new();
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let backend = ctx.services.fs.get_provider(&location.host)?;
		self.discover_recursive(&session, ctx, location.path.clone(), 1, &location.options, &mut files, location, backend)
			.await?;
		Ok(files)
	}

	async fn mkdir(&self, path: &Path) -> Result<(), Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		session.create_dir(path.to_string_lossy()).await?;
		Ok(())
	}

	async fn r#move(&self, from: &Path, to: &Path) -> Result<(), Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let rename_result = session.rename(from.to_string_lossy(), to.to_string_lossy()).await;
		if rename_result.is_err() {
			tracing::warn!(
				"Could not move {} to {}. Falling back to copy and delete. Original error: {:?}",
				from.display(),
				to.display(),
				rename_result.err()
			);
			self.copy(from, to).await?;
			self.delete(from).await?;
		}
		Ok(())
	}

	async fn copy(&self, from: &Path, to: &Path) -> Result<(), Error> {
		let content = self.read(from).await?;
		self.write(to, &content).await
	}

	async fn delete(&self, path: &Path) -> Result<(), Error> {
		let path = path.to_string_lossy().to_string();
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		let stat = session.metadata(&path).await?;
		if stat.is_dir() {
			session.remove_dir(&path).await?;
		} else {
			session.remove_file(&path).await?;
		}
		Ok(())
	}

	async fn download(&self, from: &Path) -> Result<PathBuf, Error> {
		tracing::info!("Downloading {}", from.display());
		let content = self.read(from).await?;
		let temp_file = NamedTempFile::new().map_err(|e| Error::Io(e))?;
		tokio::fs::write(temp_file.path(), &content).await.map_err(|e| Error::Io(e))?;
		tracing::info!("Downloaded {}", from.display());
		let path = temp_file.keep().map_err(|e| Error::Other(e.into()))?;
		Ok(path.1)
	}

	async fn download_many(&self, from: &[PathBuf]) -> Result<Vec<PathBuf>, Error> {
		let mut futures = Vec::with_capacity(from.len());
		for path in from {
			let sftp_clone = self.clone();
			let path_clone = path.clone();
			futures.push(tokio::spawn(async move { sftp_clone.download(&path_clone).await }));
		}
		let results: Result<Vec<PathBuf>, Error> = futures::future::try_join_all(futures)
			.await
			.map_err(|e| Error::Other(e.into()))?
			.into_iter()
			.collect();
		results
	}

	async fn upload(&self, from_local: &Path, to: &Path) -> Result<(), Error> {
		let content = tokio::fs::read(from_local).await.map_err(|e| Error::Io(e))?;
		self.write(to, &content).await
	}

	async fn upload_many(&self, from_local: &[PathBuf], to: &[PathBuf]) -> Result<(), Error> {
		if from_local.len() != to.len() {
			return Err(Error::Other(anyhow::anyhow!(
				"Mismatched number of source and destination paths for upload_many"
			)));
		}

		let mut futures = Vec::with_capacity(from_local.len());
		for (from, to) in from_local.iter().zip(to.iter()) {
			let sftp_clone = self.clone();
			let from_clone = from.clone();
			let to_clone = to.clone();
			futures.push(tokio::spawn(async move { sftp_clone.upload(&from_clone, &to_clone).await }));
		}

		futures::future::try_join_all(futures)
			.await
			.map_err(|e| Error::Other(e.into()))?
			.into_iter()
			.for_each(drop);
		Ok(())
	}

	async fn hardlink(&self, from: &Path, to: &Path) -> Result<(), Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		session.hardlink(from.to_string_lossy(), to.to_string_lossy()).await?;
		Ok(())
	}

	async fn symlink(&self, from: &Path, to: &Path) -> Result<(), Error> {
		let session = self.pool().await?.get().await.map_err(|e| Error::Other(e.into()))?;
		session.symlink(from.to_string_lossy(), to.to_string_lossy()).await?;
		Ok(())
	}
}

impl Sftp {
	fn discover_recursive<'a>(
		&'a self,
		sftp: &'a Object<Self>,
		ctx: &'a ExecutionContext<'a>,
		path: PathBuf,
		depth: usize,
		options: &'a Options,
		files: &'a mut Vec<Arc<Resource>>,
		location: &'a Location,
		backend: Arc<dyn StorageProvider>,
	) -> BoxFuture<'a, Result<(), Error>> {
		Box::pin(async move {
			if depth > options.max_depth {
				return Ok(());
			}

			let entries = sftp.read_dir(path.to_string_lossy()).await?;
			let parent_components: Vec<String> = path
				.components()
				.enumerate()
				.map(|(i, component)| {
					if i == 0 {
						"/".to_string()
					} else {
						component.as_os_str().to_string_lossy().to_string()
					}
				})
				.collect();

			for entry in entries {
				let mut components = parent_components.clone();
				components.push(entry.file_name());
				let entry = components.join("/").replace("//", "/");
				let pathbuf = PathBuf::from(&entry);

				if options.exclude.contains(&pathbuf) {
					continue;
				}

				if !options.hidden_files && entry.starts_with('.') {
					continue;
				}

				let metadata = sftp.metadata(entry).await?;

				if metadata.is_dir() {
					if depth >= options.min_depth {
						if let organize_sdk::location::options::Target::Folders = options.target {
							let resource = pathbuf
								.clone()
								.as_resource(ctx, Some(Arc::new(location.clone())), backend.clone())
								.await;
							files.push(resource);
						}
					}
					self.discover_recursive(sftp, ctx, pathbuf, depth + 1, options, files, location, backend.clone())
						.await?;
				} else {
					if depth >= options.min_depth {
						if options.target.is_files() {
							let resource = pathbuf
								.as_resource(ctx, Some(Arc::new(location.clone())), backend.clone())
								.await;
							files.push(resource);
						}
					}
				}
			}
			Ok(())
		})
	}
}

```

`organizer/organize-std\src\variables\args.rs`:

```rs
use std::sync::Arc;

use anyhow::Result;
use async_trait::async_trait;
use organize_sdk::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};

#[derive(Debug, Clone, PartialEq, Eq)]
struct ArgsAccessor {
	key: String,
}

#[async_trait]
impl Accessor for ArgsAccessor {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let value = ctx.settings.args.get(&self.key).cloned().unwrap_or("<UNDEFINED>".to_string());
		Ok(Value::String(value))
	}
}

#[derive(Debug, Clone)]
pub struct ArgsProvider;

impl StatelessVariable for ArgsProvider {
	fn name(&self) -> &'static str {
		"args"
	}

	fn schema(&self) -> Property {
		Property {
			name: self.name(),
			node: SchemaNode::DynamicMap(Arc::new(|key: &str| {
				Box::new(ArgsAccessor { key: key.to_string() })
			})),
		}
	}
}

static ARGS_PROVIDER: ArgsProvider = ArgsProvider;
inventory::submit!(VariableInventory { provider: &ARGS_PROVIDER });

```

`organizer/organize-std\src\variables\env.rs`:

```rs
use std::sync::Arc;

use organize_sdk::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

// This accessor is created dynamically. It stores the environment
// variable key that it needs to look up.
#[derive(Debug, Clone, PartialEq, Eq)]
struct EnvAccessor {
	key: String,
}

#[async_trait]
impl Accessor for EnvAccessor {
	async fn get(&self, _ctx: &ExecutionContext) -> Result<Value> {
		let value = std::env::var(&self.key).unwrap_or("<UNDEFINED>".to_string());
		Ok(Value::String(value))
	}
}

/// The provider for the `{{ env }}` variable.
#[derive(Debug, Clone)]
pub struct EnvProvider;

impl StatelessVariable for EnvProvider {
	fn name(&self) -> &'static str {
		"env"
	}

	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			// This node indicates that `env` is a map with dynamic keys.
			node: SchemaNode::DynamicMap(Arc::new(|key: &str| {
				// The constructor captures the key from the property chain
				// (e.g., "HOME") and creates an EnvAccessor for it.
				Box::new(EnvAccessor { key: key.to_string() })
			})),
		}
	}
}

// Automatically register the `EnvProvider` with the global inventory.
static ENV_PROVIDER: EnvProvider = EnvProvider;
inventory::submit!(VariableInventory { provider: &ENV_PROVIDER });
```

`organizer/organize-std\src\variables\file.rs`:

```rs
use std::sync::Arc;

use organize_sdk::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FileProvider;

#[derive(Debug, Clone, PartialEq, Eq)]
struct Path;

#[async_trait]
impl Accessor for Path {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let path_str = resource.path.to_string_lossy().to_string();
		Ok(Value::String(path_str))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Name;

#[async_trait]
impl Accessor for Name {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_name().map(|name| name.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Stem;

#[async_trait]
impl Accessor for Stem {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_stem().map(|stem| stem.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Extension;

#[async_trait]
impl Accessor for Extension {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.extension().map(|ext| ext.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Parent;

#[async_trait]
impl Accessor for Parent {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.parent().map(|parent| parent.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

// SCHEMA AND REGISTRATION

impl StatelessVariable for FileProvider {
	fn name(&self) -> &'static str {
		"file"
	}

	/// Defines the schema for the `file` variable.
	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			node: SchemaNode::Object(vec![
				Property {
					name: "path",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Path))),
				},
				Property {
					name: "name",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Name))),
				},
				Property {
					name: "stem",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Stem))),
				},
				Property {
					name: "extension",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Extension))),
				},
				Property {
					name: "parent",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Parent))),
				},
			]),
		}
	}
}

inventory::submit! {
	VariableInventory {
		provider: &FileProvider
	}
}

```

`organizer/organize-std\src\variables\mod.rs`:

```rs
pub mod args;
pub mod env;
pub mod file;

```

`organizer/prompt.md`:

```md
Project Path: organizer

Source Tree:

```txt
organizer
├── Cargo.lock
├── Cargo.toml
├── README.md
├── org.md
├── organize-cli
│   ├── Cargo.toml
│   └── src
│       ├── cmd
│       │   ├── edit.rs
│       │   ├── logs.rs
│       │   ├── mod.rs
│       │   ├── run.rs
│       │   └── undo.rs
│       └── main.rs
├── organize-core
│   ├── Cargo.toml
│   ├── migrations
│   │   └── 20250623125855_initial_schema.sql
│   └── src
│       ├── action.rs
│       ├── batch.rs
│       ├── builtins
│       │   ├── actions
│       │   │   ├── echo.rs
│       │   │   └── mod.rs
│       │   ├── mod.rs
│       │   ├── selectors
│       │   │   ├── first.rs
│       │   │   └── mod.rs
│       │   ├── sorters
│       │   │   ├── mod.rs
│       │   │   └── random.rs
│       │   ├── storage
│       │   │   └── mod.rs
│       │   └── variables
│       │       ├── env.rs
│       │       ├── file.rs
│       │       └── mod.rs
│       ├── common
│       │   └── mod.rs
│       ├── config.rs
│       ├── context
│       │   ├── mod.rs
│       │   └── services
│       │       ├── fs
│       │       │   ├── locker.rs
│       │       │   ├── manager.rs
│       │       │   └── mod.rs
│       │       ├── history
│       │       │   ├── known_files.rs
│       │       │   ├── mod.rs
│       │       │   ├── sessions.rs
│       │       │   └── transactions.rs
│       │       └── mod.rs
│       ├── engine.rs
│       ├── errors.rs
│       ├── filter.rs
│       ├── folder.rs
│       ├── grouper.rs
│       ├── lib.rs
│       ├── options.rs
│       ├── parser
│       │   ├── ast.rs
│       │   ├── errors.rs
│       │   ├── lexer.rs
│       │   ├── mod.rs
│       │   └── parser.rs
│       ├── pipeline.rs
│       ├── resource.rs
│       ├── rule.rs
│       ├── selector.rs
│       ├── sorter.rs
│       ├── stdx
│       │   ├── mod.rs
│       │   └── path.rs
│       ├── storage.rs
│       ├── templates
│       │   ├── accessor.rs
│       │   ├── compiler.rs
│       │   ├── engine.rs
│       │   ├── filter.rs
│       │   ├── mod.rs
│       │   ├── registry.rs
│       │   ├── schema.rs
│       │   ├── template.rs
│       │   ├── value.rs
│       │   └── variable.rs
│       └── utils
│           ├── backup.rs
│           └── mod.rs
├── rules
│   └── test.rule.toml
└── rustfmt.toml

```

`organizer/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "ariadne"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f5e3dca4e09a6f340a61a0e9c7b61e030c69fc27bf29d73218f7e5e3b7638f"
dependencies = [
 "unicode-width 0.1.14",
 "yansi",
]

[[package]]
name = "arraydeque"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d902e3d592a523def97af8f317b08ce16b7ab854c1985a0c671e6f15cebc236"

[[package]]
name = "async-lock"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-trait"
version = "0.1.88"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "atoi"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
dependencies = [
 "num-traits",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "beef"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a8241f3ebb85c056b509d4327ad0358fbbba6ffb340bf388f26350aeda225b1"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
dependencies = [
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d487aa071b5f64da6f19a3e848e3578944b726ee5a4854b82172f02aa876bfdc"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "chumsky"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14377e276b2c8300513dff55ba4cc4142b44e5d6de6d00eb5b2307d650bb4ec1"
dependencies = [
 "hashbrown 0.15.4",
 "regex-automata 0.3.9",
 "serde",
 "stacker",
 "unicode-ident",
 "unicode-segmentation",
]

[[package]]
name = "clap"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c7947ae4cc3d851207c1adb5b5e260ff0cca11446b1d6d1423788e442257ce"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "colored"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fde0e0ec90c9dfb3b4b1a0891a7dcd0e2bffde2f7efed5fe7c9bb00e5bfb915e"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "config"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68578f196d2a33ff61b27fae256c3164f65e36382648e30666dde05b8cc9dfdf"
dependencies = [
 "async-trait",
 "convert_case",
 "json5",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust2",
]

[[package]]
name = "console"
version = "0.15.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
dependencies = [
 "encode_unicode",
 "libc",
 "once_cell",
 "unicode-width 0.2.1",
 "windows-sys 0.59.0",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom 0.2.16",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "convert_case"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec182b0ca2f35d8fc196cf3404988fd8b8c739a4d270ff118a398feb0cbec1ca"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "dashmap"
version = "6.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
]

[[package]]
name = "dialoguer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59c6f2989294b9a498d3ad5491a79c6deb604617378e1cdc4bfc1c1361fe2f87"
dependencies = [
 "console",
 "shell-words",
 "tempfile",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "dlv-list"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442039f5147480ba31067cb00ada1adae6892028e40e45fc5de7b7df6dcc1b5f"
dependencies = [
 "const-random",
]

[[package]]
name = "dotenvy"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"

[[package]]
name = "dotenvy_macro"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb0235d912a8c749f4e0c9f18ca253b4c28cfefc1d2518096016d6e3230b6424"
dependencies = [
 "dotenvy",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "dyn-clone"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c7a8fb8a9fbf66c1f703fe16184d10ca0ee9d23be5b4436400408ba54a95005"

[[package]]
name = "dyn-eq"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c2d035d21af5cde1a6f5c7b444a5bf963520a9f142e5d06931178433d7d5388"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
dependencies = [
 "serde",
]

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e004d887f51fcb9fef17317a2f3525c887d8aa3f4f50fed920816a688284a5b7"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "etcetera"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "136d1b5283a1ab77bd9257427ffd09d8667ced0570b6f938942bc7568ed5b943"
dependencies = [
 "cfg-if",
 "home",
 "windows-sys 0.48.0",
]

[[package]]
name = "event-listener"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "filetime"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
dependencies = [
 "cfg-if",
 "libc",
 "libredox",
 "windows-sys 0.59.0",
]

[[package]]
name = "flume"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da0e4dd2a88388a1f4ccc7c9ce104604dab68d9f408dc34cd45823d5a9069095"
dependencies = [
 "futures-core",
 "futures-sink",
 "spin",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fsevent-sys"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2"
dependencies = [
 "libc",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-intrusive"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d930c203dd0b6ff06e0201a4a2fe9149b43c684fd4420555b26d21b1a02956f"
dependencies = [
 "futures-core",
 "lock_api",
 "parking_lot",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generator"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d18470a76cb7f8ff746cf1f7470914f900252ec36bbc40b569d74b1258446827"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "log",
 "rustversion",
 "windows",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "hashlink"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8094feaf31ff591f651a2664fb9cfd92bba7a60ce3197265e9482ebe753c8f7"
dependencies = [
 "hashbrown 0.14.5",
]

[[package]]
name = "hashlink"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7382cf6263419f2d8df38c55d7da83da5c18aef87fc7a7fc1fb1e344edfe14c1"
dependencies = [
 "hashbrown 0.15.4",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hkdf"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5f8eb2ad728638ea2c7d47a21db23b7b58a72ed6a38256b8a1849f15fbbdf7"
dependencies = [
 "hmac",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown 0.15.4",
]

[[package]]
name = "inotify"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
dependencies = [
 "bitflags 2.9.1",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "inventory"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab08d7cd2c5897f2c949e5383ea7c7db03fb19130ffcfbf7eda795137ae3cb83"
dependencies = [
 "rustversion",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "kqueue"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac30106d7dce88daf4a3fcb4879ea939476d5074a9b7ddd0fb97fa4bed5596a"
dependencies = [
 "kqueue-sys",
 "libc",
]

[[package]]
name = "kqueue-sys"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed9625ffda8729b85e45cf04090035ac368927b8cebc34898e7c120f52e4838b"
dependencies = [
 "bitflags 1.3.2",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1580801010e535496706ba011c15f8532df6b42297d2e471fec38ceadd8c0638"
dependencies = [
 "bitflags 2.9.1",
 "libc",
 "redox_syscall",
]

[[package]]
name = "libsqlite3-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "logos"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab6f536c1af4c7cc81edf73da1f8029896e7e1e16a219ef09b184e76a296f3db"
dependencies = [
 "logos-derive",
]

[[package]]
name = "logos-codegen"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "189bbfd0b61330abea797e5e9276408f2edbe4f822d7ad08685d67419aafb34e"
dependencies = [
 "beef",
 "fnv",
 "lazy_static",
 "proc-macro2",
 "quote",
 "regex-syntax 0.8.5",
 "rustc_version",
 "syn 2.0.103",
]

[[package]]
name = "logos-derive"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebfe8e1a19049ddbfccbd14ac834b215e11b85b90bab0c2dba7c7b92fb5d5cba"
dependencies = [
 "logos-codegen",
]

[[package]]
name = "loom"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "419e0dc8046cb947daa77eb95ae174acfbddb7673b4151f56d1eed8e93fbfaca"
dependencies = [
 "cfg-if",
 "generator",
 "scoped-tls",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess"
version = "2.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "log",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "moka"
version = "0.12.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9321642ca94a4282428e6ea4af8cc2ca4eac48ac7a6a4ea8f33f76d0ce70926"
dependencies = [
 "async-lock",
 "crossbeam-channel",
 "crossbeam-epoch",
 "crossbeam-utils",
 "event-listener",
 "futures-util",
 "loom",
 "parking_lot",
 "portable-atomic",
 "rustc_version",
 "smallvec",
 "tagptr",
 "thiserror 1.0.69",
 "uuid",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "notify"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fee8403b3d66ac7b26aee6e40a897d85dc5ce26f44da36b8b73e987cc52e943"
dependencies = [
 "bitflags 2.9.1",
 "filetime",
 "fsevent-sys",
 "inotify",
 "kqueue",
 "libc",
 "log",
 "mio",
 "notify-types",
 "walkdir",
 "windows-sys 0.59.0",
]

[[package]]
name = "notify-types"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e0826a989adedc2a244799e823aece04662b66609d96af8dff7ac6df9a8925d"

[[package]]
name = "ntapi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a3895c6391c39d7fe7ebc444a87eb2991b2a0bc718fdabd071eec617fc68e4"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand 0.8.5",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "objc2-core-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "objc2-io-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71c1c64d6120e51cd86033f67176b1cb66780c2efe34dec55176f77befd93c0a"
dependencies = [
 "libc",
 "objc2-core-foundation",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "ordered-multimap"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49203cdcae0030493bad186b28da2fa25645fa276a51b6fec8010d281e02ef79"
dependencies = [
 "dlv-list",
 "hashbrown 0.14.5",
]

[[package]]
name = "organize-cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "chrono",
 "clap",
 "colored",
 "dialoguer",
 "lazy_static",
 "notify",
 "organize-core",
 "tokio",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
]

[[package]]
name = "organize-core"
version = "0.4.0-alpha"
dependencies = [
 "anyhow",
 "ariadne",
 "async-trait",
 "chumsky",
 "clap",
 "config",
 "dashmap",
 "dialoguer",
 "dirs",
 "dotenvy",
 "dotenvy_macro",
 "dyn-clone",
 "dyn-eq",
 "futures",
 "inventory",
 "itertools",
 "libc",
 "logos",
 "mime_guess",
 "moka",
 "notify",
 "path-clean",
 "rand 0.9.1",
 "serde",
 "serde_json",
 "serde_yaml",
 "sha2",
 "sqlx",
 "strum",
 "sysinfo",
 "tempfile",
 "thiserror 2.0.12",
 "tokio",
 "toml",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
 "typetag",
 "url",
 "uuid",
 "walkdir",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "path-clean"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17359afc20d7ab31fdb42bb844c8b3bb1dabd7dcf7e68428492da7f16966fcef"

[[package]]
name = "pathdiff"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1db05f56d34358a8b1066f67cbb203ee3e7ed2ba674a6263a1d5ec6db2204323"
dependencies = [
 "memchr",
 "thiserror 2.0.12",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb056d9e8ea77922845ec74a1c4e8fb17e7c218cc4fc11a15c5d25e189aa40bc"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e404e638f781eb3202dc82db6760c8ae8a1eeef7fb3fa8264b2ef280504966"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "pest_meta"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edd1101f170f5903fde0914f899bb503d9ff5271d7ba76bbb70bea63690cc0d5"
dependencies = [
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "portable-atomic"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "psm"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e944464ec8536cd1beb0bbfd96987eb5e3b72f2ecdafdc5c769a37f1fa2ae1f"
dependencies = [
 "cc",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fbfd9d094a40bf3ae768db9361049ace4c0e04a4fd6b359518bd7b73a73dd97"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "redox_syscall"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d04b7d0ee6b4a0207a0a7adb104d23ecb0b47d6beae7152d0fa34b692b29fd6"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 1.0.69",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59b23e92ee4318893fa3fe3e6fb365258efbfe6ac6ab30f090cdcbb7aa37efa9"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.7.5",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "ron"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
dependencies = [
 "base64 0.21.7",
 "bitflags 2.9.1",
 "serde",
 "serde_derive",
]

[[package]]
name = "rsa"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78928ac1ed176a5ca1d17e578a1825f3d81ca54cf41053a592584b020cfd691b"
dependencies = [
 "const-oid",
 "digest",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core 0.6.4",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rust-ini"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e0698206bcb8882bf2a9ecb4c1e7785db57ff052297085a6efd4fe42302068a"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "serde_json"
version = "1.0.140"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shell-words"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
dependencies = [
 "serde",
]

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "sqlx"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fefb893899429669dcdd979aff487bd78f4064e5e7907e4269081e0ef7d97dc"
dependencies = [
 "sqlx-core",
 "sqlx-macros",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
]

[[package]]
name = "sqlx-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6798b1838b6a0f69c007c133b8df5866302197e404e8b6ee8ed3e3a5e68dc6"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "chrono",
 "crc",
 "crossbeam-queue",
 "either",
 "event-listener",
 "futures-core",
 "futures-intrusive",
 "futures-io",
 "futures-util",
 "hashbrown 0.15.4",
 "hashlink 0.10.0",
 "indexmap",
 "log",
 "memchr",
 "once_cell",
 "percent-encoding",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "thiserror 2.0.12",
 "tokio",
 "tokio-stream",
 "tracing",
 "url",
]

[[package]]
name = "sqlx-macros"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2d452988ccaacfbf5e0bdbc348fb91d7c8af5bee192173ac3636b5fb6e6715d"
dependencies = [
 "proc-macro2",
 "quote",
 "sqlx-core",
 "sqlx-macros-core",
 "syn 2.0.103",
]

[[package]]
name = "sqlx-macros-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19a9c1841124ac5a61741f96e1d9e2ec77424bf323962dd894bdb93f37d5219b"
dependencies = [
 "dotenvy",
 "either",
 "heck",
 "hex",
 "once_cell",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "sha2",
 "sqlx-core",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
 "syn 2.0.103",
 "tokio",
 "url",
]

[[package]]
name = "sqlx-mysql"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa003f0038df784eb8fecbbac13affe3da23b45194bd57dba231c8f48199c526"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "bytes",
 "chrono",
 "crc",
 "digest",
 "dotenvy",
 "either",
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-util",
 "generic-array",
 "hex",
 "hkdf",
 "hmac",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "percent-encoding",
 "rand 0.8.5",
 "rsa",
 "serde",
 "sha1",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-postgres"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db58fcd5a53cf07c184b154801ff91347e4c30d17a3562a635ff028ad5deda46"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "chrono",
 "crc",
 "dotenvy",
 "etcetera",
 "futures-channel",
 "futures-core",
 "futures-util",
 "hex",
 "hkdf",
 "hmac",
 "home",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "rand 0.8.5",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-sqlite"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2d12fe70b2c1b4401038055f90f151b78208de1f9f89a7dbfd41587a10c3eea"
dependencies = [
 "atoi",
 "chrono",
 "flume",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-intrusive",
 "futures-util",
 "libsqlite3-sys",
 "log",
 "percent-encoding",
 "serde",
 "serde_urlencoded",
 "sqlx-core",
 "thiserror 2.0.12",
 "tracing",
 "url",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "stacker"
version = "0.1.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cddb07e32ddb770749da91081d8d0ac3a16f1a569a18b20348cd371f5dead06b"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "psm",
 "windows-sys 0.59.0",
]

[[package]]
name = "stringprep"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4df3d392d81bd458a8a621b8bffbd2302a12ffe288a9d931670948749463b1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
 "unicode-properties",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.103",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4307e30089d6fd6aff212f2da3a1f9e32f3223b1f010fb09b7c95f90f3ca1e8"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "sysinfo"
version = "0.35.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c3ffa3e4ff2b324a57f7aeb3c349656c7b127c3c189520251a648102a92496e"
dependencies = [
 "libc",
 "memchr",
 "ntapi",
 "objc2-core-foundation",
 "objc2-io-kit",
 "windows",
]

[[package]]
name = "tagptr"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b2093cf4c8eb1e67749a6762251bc9cd836b6fc171623bd0a9d324d37af2417"

[[package]]
name = "tempfile"
version = "3.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl 2.0.12",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.45.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75ef51a33ef1da925cea3e4eb122833cb377c61439ca401b770f54902b806779"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tokio-stream"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_write",
 "winnow",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-appender"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3566e8ce28cc0a3fe42519fc80e6b4c943cc4c8cef275620eb8dac2d3d4e06cf"
dependencies = [
 "crossbeam-channel",
 "thiserror 1.0.69",
 "time",
 "tracing-subscriber",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "typetag"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73f22b40dd7bfe8c14230cf9702081366421890435b2d625fa92b4acc4c3de6f"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35f5380909ffc31b4de4f4bdf96b877175a016aa2ca98cee39fcfd8c4d53d952"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicase"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"

[[package]]
name = "unicode-bidi"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-normalization"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-properties"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e70f2a8b45122e719eb623c01822704c4e0907e7e426a05927e1a1cfff5b75d0"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-width"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "whoami"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6994d13118ab492c3c80c1f81928718159254c53c472bf9ce36f8dae4add02a7"
dependencies = [
 "redox_syscall",
 "wasite",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core",
 "windows-link",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yaml-rust2"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8902160c4e6f2fb145dbe9d6760a75e3c9522d8bf796ed7047c85919ac7115f8"
dependencies = [
 "arraydeque",
 "encoding_rs",
 "hashlink 0.8.4",
]

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

```

`organizer/Cargo.toml`:

```toml
[workspace.package]
name = "organize"
version = "0.4.0-alpha"
authors = ["KBR9 <cabero96@gmail.com>"]
edition = "2018"
description = "file butler for the poweruser"
repository = "https://github.com/cbr9/organize"

[workspace]
resolver = "2"
members = [
  "organize-cli",
  "organize-core" ,
]

default-members = ["organize-cli"]

[workspace.dependencies]
anyhow = "1.0.98"
clap = { version = "4.5.40", features = ["derive"] }
config = "0.14.0"
dialoguer = "0.10.4"
dirs = "5.0.1"
dyn-clone = "1.0.19"
dyn-eq = "0.1.3"
itertools = "0.10.5"
path-clean = "1.0.1"
serde = { version = "1.0.160", features = ["derive"] }
strum = { version = "0.26", features = ["derive"] }
typetag = "0.2.20"




```

`organizer/README.md`:

```md
TODO:
- [ ] implement custom variables
  - [x] regex based (using named capture groups)
  - [x] simple (string)
  - [ ] script 
- [x] integrate external templating library
- [x] file content filter
- [ ] download action; struct Download { to: PathBuf, url: String?, if_exists: ConflictOption, confirm: bool}
- [x] write action to write files based on some content
- [x] compressed file extraction action
- [x] refactor
- [x] refactor logger so all logs are put into one file. debug logs should not be written to stout unless a --verbose option is provided. each run should have its own log file in a folder named with the time the program was run
- [x] create a resource struct that represents a file and holds a context for that specific file, so operations can be parallelized without affecting the Tera context; get rid of global context. Take the list of rule variables in constructor
- [ ] look for configs at git repo root
- [ ] TESTS!!

---


# Planned Features
- A watch command
  - A corresponding file watcher synchronization service that keeps the known_files cache in sync with the fs
- Undo capabilities
- backups

```

`organizer/org.md`:

```md
Project Path: organizer

Source Tree:

```txt
organizer
├── Cargo.lock
├── Cargo.toml
├── README.md
├── organize-cli
│   ├── Cargo.toml
│   └── src
│       ├── cmd
│       │   ├── edit.rs
│       │   ├── logs.rs
│       │   ├── mod.rs
│       │   ├── run.rs
│       │   └── undo.rs
│       └── main.rs
├── organize-core
│   ├── Cargo.toml
│   ├── migrations
│   │   └── 20250623125855_initial_schema.sql
│   └── src
│       ├── action.rs
│       ├── batch.rs
│       ├── builtins
│       │   ├── actions
│       │   │   ├── echo.rs
│       │   │   └── mod.rs
│       │   ├── mod.rs
│       │   ├── selectors
│       │   │   ├── first.rs
│       │   │   └── mod.rs
│       │   ├── sorters
│       │   │   ├── mod.rs
│       │   │   └── random.rs
│       │   ├── storage
│       │   │   └── mod.rs
│       │   └── variables
│       │       ├── env.rs
│       │       ├── file.rs
│       │       └── mod.rs
│       ├── common
│       │   └── mod.rs
│       ├── config.rs
│       ├── context
│       │   ├── mod.rs
│       │   └── services
│       │       ├── fs
│       │       │   ├── locker.rs
│       │       │   ├── manager.rs
│       │       │   └── mod.rs
│       │       ├── history
│       │       │   ├── known_files.rs
│       │       │   ├── mod.rs
│       │       │   ├── sessions.rs
│       │       │   └── transactions.rs
│       │       └── mod.rs
│       ├── engine.rs
│       ├── errors.rs
│       ├── filter.rs
│       ├── folder.rs
│       ├── grouper.rs
│       ├── lib.rs
│       ├── options.rs
│       ├── parser
│       │   ├── ast.rs
│       │   ├── errors.rs
│       │   ├── lexer.rs
│       │   ├── mod.rs
│       │   └── parser.rs
│       ├── pipeline.rs
│       ├── resource.rs
│       ├── rule.rs
│       ├── selector.rs
│       ├── sorter.rs
│       ├── stdx
│       │   ├── mod.rs
│       │   └── path.rs
│       ├── storage.rs
│       ├── templates
│       │   ├── accessor.rs
│       │   ├── compiler.rs
│       │   ├── engine.rs
│       │   ├── filter.rs
│       │   ├── mod.rs
│       │   ├── registry.rs
│       │   ├── schema.rs
│       │   ├── template.rs
│       │   ├── value.rs
│       │   └── variable.rs
│       └── utils
│           ├── backup.rs
│           └── mod.rs
├── rules
│   └── test.rule.toml
└── rustfmt.toml

```

`organizer/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.98"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16d2d3311acee920a9eb8d33b8cbc1787ce4a264e85f964c2404b969bdcd487"

[[package]]
name = "ariadne"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f5e3dca4e09a6f340a61a0e9c7b61e030c69fc27bf29d73218f7e5e3b7638f"
dependencies = [
 "unicode-width 0.1.14",
 "yansi",
]

[[package]]
name = "arraydeque"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d902e3d592a523def97af8f317b08ce16b7ab854c1985a0c671e6f15cebc236"

[[package]]
name = "async-lock"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff6e472cdea888a4bd64f342f09b3f50e1886d32afe8df3d663c01140b811b18"
dependencies = [
 "event-listener",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-trait"
version = "0.1.88"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "atoi"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
dependencies = [
 "num-traits",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets 0.52.6",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "beef"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a8241f3ebb85c056b509d4327ad0358fbbba6ffb340bf388f26350aeda225b1"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
dependencies = [
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d487aa071b5f64da6f19a3e848e3578944b726ee5a4854b82172f02aa876bfdc"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "chumsky"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14377e276b2c8300513dff55ba4cc4142b44e5d6de6d00eb5b2307d650bb4ec1"
dependencies = [
 "hashbrown 0.15.4",
 "regex-automata 0.3.9",
 "serde",
 "stacker",
 "unicode-ident",
 "unicode-segmentation",
]

[[package]]
name = "clap"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2c7947ae4cc3d851207c1adb5b5e260ff0cca11446b1d6d1423788e442257ce"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "colored"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fde0e0ec90c9dfb3b4b1a0891a7dcd0e2bffde2f7efed5fe7c9bb00e5bfb915e"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "config"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68578f196d2a33ff61b27fae256c3164f65e36382648e30666dde05b8cc9dfdf"
dependencies = [
 "async-trait",
 "convert_case",
 "json5",
 "nom",
 "pathdiff",
 "ron",
 "rust-ini",
 "serde",
 "serde_json",
 "toml",
 "yaml-rust2",
]

[[package]]
name = "console"
version = "0.15.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
dependencies = [
 "encode_unicode",
 "libc",
 "once_cell",
 "unicode-width 0.2.1",
 "windows-sys 0.59.0",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom 0.2.16",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "convert_case"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec182b0ca2f35d8fc196cf3404988fd8b8c739a4d270ff118a398feb0cbec1ca"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9710d3b3739c2e349eb44fe848ad0b7c8cb1e42bd87ee49371df2f7acaf3e675"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "dashmap"
version = "6.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "pem-rfc7468",
 "zeroize",
]

[[package]]
name = "deranged"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c9e6a11ca8224451684bc0d7d5a7adbf8f2fd6887261a1cfc3c0432f9d4068e"
dependencies = [
 "powerfmt",
]

[[package]]
name = "dialoguer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59c6f2989294b9a498d3ad5491a79c6deb604617378e1cdc4bfc1c1361fe2f87"
dependencies = [
 "console",
 "shell-words",
 "tempfile",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "const-oid",
 "crypto-common",
 "subtle",
]

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "dlv-list"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442039f5147480ba31067cb00ada1adae6892028e40e45fc5de7b7df6dcc1b5f"
dependencies = [
 "const-random",
]

[[package]]
name = "dotenvy"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1aaf95b3e5c8f23aa320147307562d361db0ae0d51242340f558153b4eb2439b"

[[package]]
name = "dotenvy_macro"
version = "0.15.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb0235d912a8c749f4e0c9f18ca253b4c28cfefc1d2518096016d6e3230b6424"
dependencies = [
 "dotenvy",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "dyn-clone"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c7a8fb8a9fbf66c1f703fe16184d10ca0ee9d23be5b4436400408ba54a95005"

[[package]]
name = "dyn-eq"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c2d035d21af5cde1a6f5c7b444a5bf963520a9f142e5d06931178433d7d5388"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
dependencies = [
 "serde",
]

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e004d887f51fcb9fef17317a2f3525c887d8aa3f4f50fed920816a688284a5b7"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "etcetera"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "136d1b5283a1ab77bd9257427ffd09d8667ced0570b6f938942bc7568ed5b943"
dependencies = [
 "cfg-if",
 "home",
 "windows-sys 0.48.0",
]

[[package]]
name = "event-listener"
version = "5.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3492acde4c3fc54c845eaab3eed8bd00c7a7d881f78bfc801e43a93dec1331ae"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "filetime"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
dependencies = [
 "cfg-if",
 "libc",
 "libredox",
 "windows-sys 0.59.0",
]

[[package]]
name = "flume"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da0e4dd2a88388a1f4ccc7c9ce104604dab68d9f408dc34cd45823d5a9069095"
dependencies = [
 "futures-core",
 "futures-sink",
 "spin",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fsevent-sys"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2"
dependencies = [
 "libc",
]

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-intrusive"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d930c203dd0b6ff06e0201a4a2fe9149b43c684fd4420555b26d21b1a02956f"
dependencies = [
 "futures-core",
 "lock_api",
 "parking_lot",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "generator"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d18470a76cb7f8ff746cf1f7470914f900252ec36bbc40b569d74b1258446827"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "log",
 "rustversion",
 "windows",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi 0.14.2+wasi-0.2.4",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashbrown"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
dependencies = [
 "allocator-api2",
 "equivalent",
 "foldhash",
]

[[package]]
name = "hashlink"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8094feaf31ff591f651a2664fb9cfd92bba7a60ce3197265e9482ebe753c8f7"
dependencies = [
 "hashbrown 0.14.5",
]

[[package]]
name = "hashlink"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7382cf6263419f2d8df38c55d7da83da5c18aef87fc7a7fc1fb1e344edfe14c1"
dependencies = [
 "hashbrown 0.15.4",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hkdf"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b5f8eb2ad728638ea2c7d47a21db23b7b58a72ed6a38256b8a1849f15fbbdf7"
dependencies = [
 "hmac",
]

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "home"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown 0.15.4",
]

[[package]]
name = "inotify"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
dependencies = [
 "bitflags 2.9.1",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "inventory"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab08d7cd2c5897f2c949e5383ea7c7db03fb19130ffcfbf7eda795137ae3cb83"
dependencies = [
 "rustversion",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "json5"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1"
dependencies = [
 "pest",
 "pest_derive",
 "serde",
]

[[package]]
name = "kqueue"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eac30106d7dce88daf4a3fcb4879ea939476d5074a9b7ddd0fb97fa4bed5596a"
dependencies = [
 "kqueue-sys",
 "libc",
]

[[package]]
name = "kqueue-sys"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed9625ffda8729b85e45cf04090035ac368927b8cebc34898e7c120f52e4838b"
dependencies = [
 "bitflags 1.3.2",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
dependencies = [
 "spin",
]

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1580801010e535496706ba011c15f8532df6b42297d2e471fec38ceadd8c0638"
dependencies = [
 "bitflags 2.9.1",
 "libc",
 "redox_syscall",
]

[[package]]
name = "libsqlite3-sys"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e99fb7a497b1e3339bc746195567ed8d3e24945ecd636e3619d20b9de9e9149"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "logos"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab6f536c1af4c7cc81edf73da1f8029896e7e1e16a219ef09b184e76a296f3db"
dependencies = [
 "logos-derive",
]

[[package]]
name = "logos-codegen"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "189bbfd0b61330abea797e5e9276408f2edbe4f822d7ad08685d67419aafb34e"
dependencies = [
 "beef",
 "fnv",
 "lazy_static",
 "proc-macro2",
 "quote",
 "regex-syntax 0.8.5",
 "rustc_version",
 "syn 2.0.103",
]

[[package]]
name = "logos-derive"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebfe8e1a19049ddbfccbd14ac834b215e11b85b90bab0c2dba7c7b92fb5d5cba"
dependencies = [
 "logos-codegen",
]

[[package]]
name = "loom"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "419e0dc8046cb947daa77eb95ae174acfbddb7673b4151f56d1eed8e93fbfaca"
dependencies = [
 "cfg-if",
 "generator",
 "scoped-tls",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest",
]

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess"
version = "2.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "log",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "moka"
version = "0.12.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9321642ca94a4282428e6ea4af8cc2ca4eac48ac7a6a4ea8f33f76d0ce70926"
dependencies = [
 "async-lock",
 "crossbeam-channel",
 "crossbeam-epoch",
 "crossbeam-utils",
 "event-listener",
 "futures-util",
 "loom",
 "parking_lot",
 "portable-atomic",
 "rustc_version",
 "smallvec",
 "tagptr",
 "thiserror 1.0.69",
 "uuid",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "notify"
version = "8.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fee8403b3d66ac7b26aee6e40a897d85dc5ce26f44da36b8b73e987cc52e943"
dependencies = [
 "bitflags 2.9.1",
 "filetime",
 "fsevent-sys",
 "inotify",
 "kqueue",
 "libc",
 "log",
 "mio",
 "notify-types",
 "walkdir",
 "windows-sys 0.59.0",
]

[[package]]
name = "notify-types"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e0826a989adedc2a244799e823aece04662b66609d96af8dff7ac6df9a8925d"

[[package]]
name = "ntapi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a3895c6391c39d7fe7ebc444a87eb2991b2a0bc718fdabd071eec617fc68e4"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint-dig"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc84195820f291c7697304f3cbdadd1cb7199c0efc917ff5eafd71225c136151"
dependencies = [
 "byteorder",
 "lazy_static",
 "libm",
 "num-integer",
 "num-iter",
 "num-traits",
 "rand 0.8.5",
 "smallvec",
 "zeroize",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "objc2-core-foundation"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "objc2-io-kit"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71c1c64d6120e51cd86033f67176b1cb66780c2efe34dec55176f77befd93c0a"
dependencies = [
 "libc",
 "objc2-core-foundation",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "ordered-multimap"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49203cdcae0030493bad186b28da2fa25645fa276a51b6fec8010d281e02ef79"
dependencies = [
 "dlv-list",
 "hashbrown 0.14.5",
]

[[package]]
name = "organize-cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-trait",
 "chrono",
 "clap",
 "colored",
 "dialoguer",
 "lazy_static",
 "notify",
 "organize-core",
 "tokio",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
]

[[package]]
name = "organize-core"
version = "0.4.0-alpha"
dependencies = [
 "anyhow",
 "ariadne",
 "async-trait",
 "chumsky",
 "clap",
 "config",
 "dashmap",
 "dialoguer",
 "dirs",
 "dotenvy",
 "dotenvy_macro",
 "dyn-clone",
 "dyn-eq",
 "futures",
 "inventory",
 "itertools",
 "libc",
 "logos",
 "mime_guess",
 "moka",
 "notify",
 "path-clean",
 "rand 0.9.1",
 "serde",
 "serde_json",
 "serde_yaml",
 "sha2",
 "sqlx",
 "strum",
 "sysinfo",
 "tempfile",
 "thiserror 2.0.12",
 "tokio",
 "toml",
 "tracing",
 "tracing-appender",
 "tracing-subscriber",
 "typetag",
 "url",
 "uuid",
 "walkdir",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "path-clean"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17359afc20d7ab31fdb42bb844c8b3bb1dabd7dcf7e68428492da7f16966fcef"

[[package]]
name = "pathdiff"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3"

[[package]]
name = "pem-rfc7468"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88b39c9bfcfc231068454382784bb460aae594343fb030d46e9f50a645418412"
dependencies = [
 "base64ct",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1db05f56d34358a8b1066f67cbb203ee3e7ed2ba674a6263a1d5ec6db2204323"
dependencies = [
 "memchr",
 "thiserror 2.0.12",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb056d9e8ea77922845ec74a1c4e8fb17e7c218cc4fc11a15c5d25e189aa40bc"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e404e638f781eb3202dc82db6760c8ae8a1eeef7fb3fa8264b2ef280504966"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "pest_meta"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edd1101f170f5903fde0914f899bb503d9ff5271d7ba76bbb70bea63690cc0d5"
dependencies = [
 "pest",
 "sha2",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs1"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8ffb9f10fa047879315e6625af03c164b16962a5368d724ed16323b68ace47f"
dependencies = [
 "der",
 "pkcs8",
 "spki",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "portable-atomic"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"

[[package]]
name = "potential_utf"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5a7c30837279ca13e7c867e9e40053bc68740f988cb07f7ca6df43cc734b585"
dependencies = [
 "zerovec",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "psm"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e944464ec8536cd1beb0bbfd96987eb5e3b72f2ecdafdc5c769a37f1fa2ae1f"
dependencies = [
 "cc",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fbfd9d094a40bf3ae768db9361049ace4c0e04a4fd6b359518bd7b73a73dd97"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "redox_syscall"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d04b7d0ee6b4a0207a0a7adb104d23ecb0b47d6beae7152d0fa34b692b29fd6"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "redox_users"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba009ff324d1fc1b900bd1fdb31564febe58a8ccc8a6fdbb93b543d33b13ca43"
dependencies = [
 "getrandom 0.2.16",
 "libredox",
 "thiserror 1.0.69",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59b23e92ee4318893fa3fe3e6fb365258efbfe6ac6ab30f090cdcbb7aa37efa9"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.7.5",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "ron"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
dependencies = [
 "base64 0.21.7",
 "bitflags 2.9.1",
 "serde",
 "serde_derive",
]

[[package]]
name = "rsa"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78928ac1ed176a5ca1d17e578a1825f3d81ca54cf41053a592584b020cfd691b"
dependencies = [
 "const-oid",
 "digest",
 "num-bigint-dig",
 "num-integer",
 "num-traits",
 "pkcs1",
 "pkcs8",
 "rand_core 0.6.4",
 "signature",
 "spki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rust-ini"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e0698206bcb8882bf2a9ecb4c1e7785db57ff052297085a6efd4fe42302068a"
dependencies = [
 "cfg-if",
 "ordered-multimap",
]

[[package]]
name = "rustc-demangle"
version = "0.1.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "989e6739f80c4ad5b13e0fd7fe89531180375b18520cc8c82080e4dc4035b84f"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
dependencies = [
 "bitflags 2.9.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustversion"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scoped-tls"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "serde_json"
version = "1.0.140"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shell-words"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "digest",
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
dependencies = [
 "serde",
]

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"
dependencies = [
 "lock_api",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "sqlx"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fefb893899429669dcdd979aff487bd78f4064e5e7907e4269081e0ef7d97dc"
dependencies = [
 "sqlx-core",
 "sqlx-macros",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
]

[[package]]
name = "sqlx-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6798b1838b6a0f69c007c133b8df5866302197e404e8b6ee8ed3e3a5e68dc6"
dependencies = [
 "base64 0.22.1",
 "bytes",
 "chrono",
 "crc",
 "crossbeam-queue",
 "either",
 "event-listener",
 "futures-core",
 "futures-intrusive",
 "futures-io",
 "futures-util",
 "hashbrown 0.15.4",
 "hashlink 0.10.0",
 "indexmap",
 "log",
 "memchr",
 "once_cell",
 "percent-encoding",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "thiserror 2.0.12",
 "tokio",
 "tokio-stream",
 "tracing",
 "url",
]

[[package]]
name = "sqlx-macros"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2d452988ccaacfbf5e0bdbc348fb91d7c8af5bee192173ac3636b5fb6e6715d"
dependencies = [
 "proc-macro2",
 "quote",
 "sqlx-core",
 "sqlx-macros-core",
 "syn 2.0.103",
]

[[package]]
name = "sqlx-macros-core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19a9c1841124ac5a61741f96e1d9e2ec77424bf323962dd894bdb93f37d5219b"
dependencies = [
 "dotenvy",
 "either",
 "heck",
 "hex",
 "once_cell",
 "proc-macro2",
 "quote",
 "serde",
 "serde_json",
 "sha2",
 "sqlx-core",
 "sqlx-mysql",
 "sqlx-postgres",
 "sqlx-sqlite",
 "syn 2.0.103",
 "tokio",
 "url",
]

[[package]]
name = "sqlx-mysql"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa003f0038df784eb8fecbbac13affe3da23b45194bd57dba231c8f48199c526"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "bytes",
 "chrono",
 "crc",
 "digest",
 "dotenvy",
 "either",
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-util",
 "generic-array",
 "hex",
 "hkdf",
 "hmac",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "percent-encoding",
 "rand 0.8.5",
 "rsa",
 "serde",
 "sha1",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-postgres"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db58fcd5a53cf07c184b154801ff91347e4c30d17a3562a635ff028ad5deda46"
dependencies = [
 "atoi",
 "base64 0.22.1",
 "bitflags 2.9.1",
 "byteorder",
 "chrono",
 "crc",
 "dotenvy",
 "etcetera",
 "futures-channel",
 "futures-core",
 "futures-util",
 "hex",
 "hkdf",
 "hmac",
 "home",
 "itoa",
 "log",
 "md-5",
 "memchr",
 "once_cell",
 "rand 0.8.5",
 "serde",
 "serde_json",
 "sha2",
 "smallvec",
 "sqlx-core",
 "stringprep",
 "thiserror 2.0.12",
 "tracing",
 "whoami",
]

[[package]]
name = "sqlx-sqlite"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2d12fe70b2c1b4401038055f90f151b78208de1f9f89a7dbfd41587a10c3eea"
dependencies = [
 "atoi",
 "chrono",
 "flume",
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-intrusive",
 "futures-util",
 "libsqlite3-sys",
 "log",
 "percent-encoding",
 "serde",
 "serde_urlencoded",
 "sqlx-core",
 "thiserror 2.0.12",
 "tracing",
 "url",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "stacker"
version = "0.1.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cddb07e32ddb770749da91081d8d0ac3a16f1a569a18b20348cd371f5dead06b"
dependencies = [
 "cc",
 "cfg-if",
 "libc",
 "psm",
 "windows-sys 0.59.0",
]

[[package]]
name = "stringprep"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4df3d392d81bd458a8a621b8bffbd2302a12ffe288a9d931670948749463b1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
 "unicode-properties",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.103",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4307e30089d6fd6aff212f2da3a1f9e32f3223b1f010fb09b7c95f90f3ca1e8"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "sysinfo"
version = "0.35.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c3ffa3e4ff2b324a57f7aeb3c349656c7b127c3c189520251a648102a92496e"
dependencies = [
 "libc",
 "memchr",
 "ntapi",
 "objc2-core-foundation",
 "objc2-io-kit",
 "windows",
]

[[package]]
name = "tagptr"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b2093cf4c8eb1e67749a6762251bc9cd836b6fc171623bd0a9d324d37af2417"

[[package]]
name = "tempfile"
version = "3.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl 2.0.12",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "time"
version = "0.3.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a7619e19bc266e0f9c5e6686659d394bc57973859340060a69221e57dbc0c40"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e9a38711f559d9e3ce1cdb06dd7c5b8ea546bc90052da6d06bb76da74bb07c"

[[package]]
name = "time-macros"
version = "0.2.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3526739392ec93fd8b359c8e98514cb3e8e021beb4e5f597b00a0221f8ed8a49"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09b3661f17e86524eccd4371ab0429194e0d7c008abb45f7a7495b1719463c71"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.45.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75ef51a33ef1da925cea3e4eb122833cb377c61439ca401b770f54902b806779"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tokio-stream"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_write",
 "winnow",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-appender"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3566e8ce28cc0a3fe42519fc80e6b4c943cc4c8cef275620eb8dac2d3d4e06cf"
dependencies = [
 "crossbeam-channel",
 "thiserror 1.0.69",
 "time",
 "tracing-subscriber",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8189decb5ac0fa7bc8b96b7cb9b2701d60d48805aca84a238004d665fcc4008"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "typetag"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73f22b40dd7bfe8c14230cf9702081366421890435b2d625fa92b4acc4c3de6f"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35f5380909ffc31b4de4f4bdf96b877175a016aa2ca98cee39fcfd8c4d53d952"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicase"
version = "2.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"

[[package]]
name = "unicode-bidi"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-normalization"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-properties"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e70f2a8b45122e719eb623c01822704c4e0907e7e426a05927e1a1cfff5b75d0"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-width"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "url"
version = "2.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "whoami"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6994d13118ab492c3c80c1f81928718159254c53c472bf9ce36f8dae4add02a7"
dependencies = [
 "redox_syscall",
 "wasite",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.61.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9babd3a767a4c1aef6900409f85f5d53ce2544ccdfaa86dad48c91782c6d6893"
dependencies = [
 "windows-collections",
 "windows-core",
 "windows-future",
 "windows-link",
 "windows-numerics",
]

[[package]]
name = "windows-collections"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3beeceb5e5cfd9eb1d76b381630e82c4241ccd0d27f1a39ed41b2760b255c5e8"
dependencies = [
 "windows-core",
]

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-future"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc6a41e98427b19fe4b73c550f060b59fa592d7d686537eebf9385621bfbad8e"
dependencies = [
 "windows-core",
 "windows-link",
 "windows-threading",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-numerics"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9150af68066c4c5c07ddc0ce30421554771e528bde427614c61038bc2c92c2b1"
dependencies = [
 "windows-core",
 "windows-link",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-threading"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b66463ad2e0ea3bbf808b7f1d371311c80e115c0b71d60efc142cafbcfb057a6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags 2.9.1",
]

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yaml-rust2"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8902160c4e6f2fb145dbe9d6760a75e3c9522d8bf796ed7047c85919ac7115f8"
dependencies = [
 "arraydeque",
 "encoding_rs",
 "hashlink 0.8.4",
]

[[package]]
name = "yansi"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfe53a6657fd280eaa890a3bc59152892ffa3e30101319d168b781ed6529b049"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a05eb080e015ba39cc9e23bbe5e7fb04d5fb040350f99f34e338d5fdd294428"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.103",
]

```

`organizer/Cargo.toml`:

```toml
[workspace.package]
name = "organize"
version = "0.4.0-alpha"
authors = ["KBR9 <cabero96@gmail.com>"]
edition = "2018"
description = "file butler for the poweruser"
repository = "https://github.com/cbr9/organize"

[workspace]
resolver = "2"
members = [
  "organize-cli",
  "organize-core" ,
]

default-members = ["organize-cli"]

[workspace.dependencies]
anyhow = "1.0.98"
clap = { version = "4.5.40", features = ["derive"] }
config = "0.14.0"
dialoguer = "0.10.4"
dirs = "5.0.1"
dyn-clone = "1.0.19"
dyn-eq = "0.1.3"
itertools = "0.10.5"
path-clean = "1.0.1"
serde = { version = "1.0.160", features = ["derive"] }
strum = { version = "0.26", features = ["derive"] }
typetag = "0.2.20"




```

`organizer/README.md`:

```md
TODO:
- [ ] implement custom variables
  - [x] regex based (using named capture groups)
  - [x] simple (string)
  - [ ] script 
- [x] integrate external templating library
- [x] file content filter
- [ ] download action; struct Download { to: PathBuf, url: String?, if_exists: ConflictOption, confirm: bool}
- [x] write action to write files based on some content
- [x] compressed file extraction action
- [x] refactor
- [x] refactor logger so all logs are put into one file. debug logs should not be written to stout unless a --verbose option is provided. each run should have its own log file in a folder named with the time the program was run
- [x] create a resource struct that represents a file and holds a context for that specific file, so operations can be parallelized without affecting the Tera context; get rid of global context. Take the list of rule variables in constructor
- [ ] look for configs at git repo root
- [ ] TESTS!!

---


# Planned Features
- A watch command
  - A corresponding file watcher synchronization service that keeps the known_files cache in sync with the fs
- Undo capabilities
- backups

```

`organizer/organize-cli\Cargo.toml`:

```toml
[package]
name = "organize-cli"
version = "0.1.0"
edition = "2024"

[[bin]]
name = "organize"
path = "src/main.rs"

[dependencies]
async-trait = "0.1.88"
tokio = { version = "1.45.1", features = ["full"] }
organize-core = { path = "../organize-core" }
lazy_static = "1.5.0"
chrono = "0.4.41"
anyhow.workspace = true
clap.workspace = true
colored = "3.0.0"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = "0.3.19"
dialoguer.workspace = true
notify = "8.0.0"


```

`organizer/organize-cli\src\cmd\edit.rs`:

```rs
use std::{
	env,
	path::Path,
	process::{self, ExitStatus},
};

use anyhow::{Context, Result};
use async_trait::async_trait;
use clap::Parser;
use organize_core::config::Config;

use crate::cmd::Cmd;

#[derive(Parser, Debug)]
pub struct Edit;

#[async_trait]
impl Cmd for Edit {
	async fn run(self) -> Result<()> {
		Self::edit(Config::resolve_path(None)).map(|_| ())
	}
}

impl Edit {
	pub(crate) fn edit<T: AsRef<Path>>(path: T) -> Result<ExitStatus> {
		env::var("EDITOR").map(|editor| {
			process::Command::new(&editor)
				.arg(path.as_ref())
				.spawn()
				.context(editor)?
				.wait()
				.context("command wasn't running")
		})?
	}
}

```

`organizer/organize-cli\src\cmd\logs.rs`:

```rs
use chrono::Local;
use clap::ValueEnum;
use std::path::PathBuf;
use tracing::Level;
use tracing_appender::non_blocking::WorkerGuard; // Import the guard type
use tracing_subscriber::{
	Layer,
	filter::LevelFilter,
	fmt::{self},
	layer::SubscriberExt,
	util::SubscriberInitExt,
};

#[derive(ValueEnum, Clone, Debug, Default)]
pub enum LogLevel {
	#[default]
	Info,
	Debug,
	Trace,
	Warn,
	Error,
}

// Implement a conversion from our CLI enum to the `tracing` LevelFilter.
impl From<LogLevel> for Level {
	fn from(level: LogLevel) -> Self {
		match level {
			LogLevel::Info => Level::INFO,
			LogLevel::Debug => Level::DEBUG,
			LogLevel::Trace => Level::TRACE,
			LogLevel::Warn => Level::WARN,
			LogLevel::Error => Level::ERROR,
		}
	}
}

/// Initializes the logging system and returns a guard that must be kept in scope.
pub fn init(level: LogLevel) -> WorkerGuard {
	// 1. Determine the destination directory for logs.
	let logs_dir = PathBuf::from(".").join("logs"); // A hidden folder is a common convention

	// 2. Create a non-blocking file appender for the current run.
	// We add milliseconds to the timestamp to increase uniqueness.
	let timestamp = Local::now().format("%Y-%m-%d-%H-%M-%S%.3f");
	let log_file = format!("{timestamp}.log");
	let file_appender = tracing_appender::rolling::never(&logs_dir, log_file);
	let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);

	// 3. Define the two logging layers.
	let file_layer = fmt::layer()
		.with_writer(non_blocking_writer)
		.with_ansi(false)
		.pretty()
		.with_filter(LevelFilter::TRACE);

	let stdout_layer = fmt::layer()
		.with_writer(std::io::stdout)
		.with_filter(LevelFilter::from_level(level.into()));

	// 4. Combine the layers and initialize the global subscriber.
	tracing_subscriber::registry().with(file_layer).with(stdout_layer).init();

	tracing::debug!("Logging initialized. Log file in: {}", logs_dir.display());

	// 5. Return the guard to the caller.
	guard
}

```

`organizer/organize-cli\src\cmd\mod.rs`:

```rs
use crate::cmd::{logs::LogLevel, run::Run};
use async_trait::async_trait;
use clap::{Parser, Subcommand};
use undo::Undo;

mod logs;
mod run;
mod undo;

#[derive(Subcommand)]
enum Command {
	Run(Run),
	Undo(Undo),
}

#[derive(Parser)]
#[command(about, author, version)]
pub struct App {
	#[command(subcommand)]
	command: Command,
	#[arg(long, value_enum, global = true, default_value_t = LogLevel::Info)]
	pub log_level: LogLevel,
}

#[async_trait]
pub trait Cmd {
	async fn run(self) -> anyhow::Result<()>;
}

#[async_trait]
impl Cmd for App {
	async fn run(self) -> anyhow::Result<()> {
		let _guard = logs::init(self.log_level);
		match self.command {
			Command::Run(cmd) => cmd.run().await,
			Command::Undo(undo) => undo.run().await,
		}
	}
}

```

`organizer/organize-cli\src\cmd\run.rs`:

```rs
use std::path::PathBuf;

use anyhow::Result;
use async_trait::async_trait;
use clap::{Parser, ValueHint};
use organize_core::{context::RunSettings, engine::Engine};

use crate::Cmd;


#[derive(Parser, Default, Debug)]
pub struct Run {
	#[arg(long, short = 'r', value_hint = ValueHint::FilePath)]
	rule: PathBuf,
	#[arg(long, default_value_t = true, conflicts_with = "no_dry_run")]
	dry_run: bool,
	#[arg(long, conflicts_with = "dry_run")]
	no_dry_run: bool,
}

#[async_trait]
impl Cmd for Run {
	async fn run(mut self) -> Result<()> {
		if self.no_dry_run {
			self.dry_run = false;
		}
		let settings = RunSettings { dry_run: self.dry_run };
		let engine = Engine::new(&self.rule, settings).await?;
		engine.run().await?;

		Ok(())
	}
}

```

`organizer/organize-cli\src\cmd\undo.rs`:

```rs
use std::error::Error;

use anyhow::{Result, anyhow};
use async_trait::async_trait;
use clap::Parser;
use organize_core::{
	action::{Input, UndoConflict, UndoError, UndoSettings},
	context::{RunSettings, services::history::Journal},
};

use super::Cmd;

#[derive(Parser, Debug)]
#[command(author, version, about)]
pub struct Undo {
	/// The ID of the session to undo.
	#[arg(long, conflicts_with = "last_session")]
	session_id: Option<i64>,

	/// Use the most recent session.
	#[arg(long, default_value_t = true)]
	last_session: bool,

	// If there is a name collision conflict while undoing, ask me what to do
	#[arg(long, short = 'i', conflicts_with_all = &["on_conflict"])]
	interactive: bool,

	#[arg(long, value_enum, default_value_t = UndoConflict::Abort)]
	on_conflict: UndoConflict,
}

#[async_trait]
impl Cmd for Undo {
	async fn run(self) -> Result<()> {
		let settings = RunSettings { dry_run: false };
		let journal = Journal::new(&settings).await?; // Assumes a simple ::new()

		let settings = UndoSettings {
			interactive: self.interactive,
			on_conflict: self.on_conflict,
		};
		let target_id = if self.last_session {
			journal
				.get_last_session_id()
				.await?
				.ok_or_else(|| anyhow!("No sessions found in the journal."))?
		} else {
			self.session_id.unwrap()
		};

		let transactions = journal.get_pending_transactions_for_session(target_id).await?;

		if transactions.is_empty() {
			println!("No pending operations to undo for session {target_id}.");
			return Ok(());
		}

		for transaction in &transactions {
			for undo_op in &transaction.receipt.undo {
				if undo_op.verify().await.is_ok() {
					match undo_op.undo(&settings).await {
						Ok(_) => {
							journal.update_transaction_undo_status(transaction.id, "DONE").await?;
							tracing::info!("Transaction {} undone.", transaction.id);
						}
						Err(e) => {
							if let Some(source) = e.source().and_then(|s| s.downcast_ref::<UndoError>())
								&& matches!(source, UndoError::Abort)
							{
								let inputs = transaction
									.receipt
									.inputs
									.iter()
									.map(|input: &Input| match input {
										Input::Processed(resource) => resource.as_path().to_string_lossy().to_string(),
										Input::Skipped(resource) => resource.as_path().to_string_lossy().to_string(),
									})
									.collect::<Vec<String>>()
									.join("\n -");

								eprintln!(
									"There was a conflict undoing transaction {}.\nOne of the following files may already exist: \n - {}\nAborting \
									 undo process. Run in interactive mode or choose a default conflict resolution strategy. You can also move the \
									 file manually.",
									transaction.id, inputs
								);
								return Ok(());
							}

							eprintln!("Failed to undo transaction {}: {}", transaction.id, e);
							return Err(e.into());
						}
					}
				}
			}
		}

		Ok(())
	}
}

```

`organizer/organize-cli\src\main.rs`:

```rs
use crate::cmd::{App, Cmd};
use anyhow::Result;
use clap::Parser;
mod cmd;

#[tokio::main]
async fn main() -> Result<()> {
	let app: App = App::parse();
	app.run().await
}

```

`organizer/organize-core\Cargo.toml`:

```toml
[package]
name = "organize-core"
version.workspace = true
authors.workspace = true
edition.workspace = true
description.workspace = true
repository.workspace = true

[dependencies]
ariadne = "0.5.1"
chumsky = "0.10.1"
logos = "0.15.0"
anyhow.workspace = true
async-trait = "0.1.88"
clap.workspace = true
config.workspace = true
dashmap = "6.1.0"
dialoguer.workspace = true
dirs.workspace = true
dotenvy = "0.15.7"
dyn-clone.workspace = true
dyn-eq.workspace = true
itertools.workspace = true
moka = { version = "0.12.10", features = ["future"] }
path-clean.workspace = true
serde.workspace = true
serde_json = "1.0.140"
serde_yaml = "0.9.34"
sqlx = { version = "0.8.6", features = ["chrono", "runtime-tokio", "sqlite"] }
strum.workspace = true
thiserror = "2.0.12"
typetag.workspace = true
dotenvy_macro = "0.15.7"
tokio = { version = "1.45.1", features = ["full"] }
libc = "0.2.174"
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
tracing-appender = "0.2.3"
futures = "0.3.31"
walkdir = "2.5.0"
tempfile = "3.20.0"
sha2 = "0.10.9"
uuid = "1.17.0"
mime_guess = "2.0.5"
sysinfo = "0.35.2"
notify = "8.0.0"
url = "2.5.4"
toml = "0.8.23"
inventory = "0.3.20"
rand = "0.9.1"

```

`organizer/organize-core\migrations\20250623125855_initial_schema.sql`:

```sql
CREATE TABLE IF NOT EXISTS sessions (
    id              INTEGER PRIMARY KEY,
    start_time      INTEGER NOT NULL,
    end_time        INTEGER,
    status          TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS transactions (
    id              INTEGER PRIMARY KEY,
    session_id      INTEGER NOT NULL,
    type               TEXT NOT NULL,
    action             TEXT NOT NULL,
    receipt            TEXT NOT NULL, 
    timestamp       INTEGER NOT NULL,
    undo_status TEXT NOT NULL DEFAULT "PENDING",
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);


```

`organizer/organize-core\src\action.rs`:

```rs
use async_trait::async_trait;
use clap::ValueEnum;
use dialoguer::{theme::ColorfulTheme, Input as RenameInput, Select};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ffi::OsStr, fmt::Debug, path::Path, sync::Arc};
use strum::{Display, EnumIter, IntoEnumIterator};

use anyhow::Result;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::path::PathBuf;
use thiserror::Error;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource, utils::backup::Backup};

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Input {
	Processed(Arc<Resource>),
	Skipped(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Output {
	Created(Arc<Resource>),
	Deleted(Arc<Resource>),
	Modified(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct Receipt {
	pub inputs: Vec<Input>,
	pub outputs: Vec<Output>,
	pub next: Vec<Arc<Resource>>,
	pub undo: Vec<Box<dyn Undo>>,
	pub metadata: HashMap<String, serde_json::Value>,
}

impl From<String> for Receipt {
	fn from(value: String) -> Self {
		serde_json::from_str(&value).expect("Could not convert string to Receipt object")
	}
}

dyn_clone::clone_trait_object!(Undo);
dyn_eq::eq_trait_object!(Undo);

#[derive(Debug, Error)]
pub enum UndoError {
	#[error("Path '{0}' does not exist, but is required for the undo operation.")]
	PathNotFound(PathBuf),

	#[error("Path '{0}' already exists. The undo operation would overwrite it.")]
	PathAlreadyExists(PathBuf),

	#[error("Backup file is missing for path '{0}'. Cannot restore.")]
	BackupMissing(PathBuf),

	#[error("Parent directory '{0}' for the restore path does not exist.")]
	ParentDirectoryNotFound(PathBuf),

	#[error("Any error")]
	Anyhow(#[from] anyhow::Error),

	#[error("IO error")]
	IO(#[from] std::io::Error),

	#[error("Undo aborted by the user")]
	Abort,
}

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Undo: Debug + DynEq + DynClone + Send + Sync {
	async fn undo(&self, settings: &UndoSettings) -> Result<(), Error>;

	fn backup(&self) -> Option<&Backup> {
		None
	}

	async fn verify(&self) -> Result<(), Error>;
}

pub struct UndoSettings {
	pub interactive: bool,
	pub on_conflict: UndoConflict,
}

#[derive(Clone, Debug, ValueEnum, EnumIter, Display)]
#[strum(serialize_all = "snake_case")]
pub enum UndoConflict {
	Skip,
	Abort,
	Overwrite,
	AutoRename,
	Rename,
}

async fn suggest_new_path(resource: Resource) -> Result<Resource> {
	let parent = resource.as_path().parent().unwrap_or_else(|| Path::new(""));
	let stem = resource.as_path().file_stem().unwrap_or_else(|| OsStr::new("file"));
	let extension = resource.as_path().extension().unwrap_or_else(|| OsStr::new(""));

	let mut count = 1;
	loop {
		// 2. Construct the new filename purely from strings and path components.
		let new_filename_str = format!("{} ({}).{}", stem.to_string_lossy(), count, extension.to_string_lossy());

		// 3. Create a new PathBuf to check for existence. This does not touch the original `resource`.
		let new_path = parent.join(&new_filename_str);

		if !tokio::fs::try_exists(&new_path).await? {
			// 4. Once a valid path is found, consume the original `resource` exactly once
			//    to create the final, evolved struct and return it. The loop is guaranteed to terminate here.
			return Ok(resource.with_path(new_path));
		}
		count += 1;
	}
}

impl UndoConflict {
	/// This new method encapsulates all the conflict handling logic.
	/// It takes a mutable reference to the destination to allow the Rename variant to change it.
	pub async fn resolve(resource: Resource) -> Result<Option<Resource>, UndoError> {
		let choices: Vec<Self> = Self::iter().collect();
		let strategy: &UndoConflict = Select::with_theme(&ColorfulTheme::default())
			.with_prompt(format!("Destination '{}' already exists.", resource.path.display()))
			.items(&choices)
			.interact()
			.map(|choice| &choices[choice])
			.expect("Unknown option");
		strategy.handle(resource).await
	}

	pub async fn handle(&self, resource: Resource) -> Result<Option<Resource>, UndoError> {
		match self {
			UndoConflict::Overwrite => {
				// The logic for overwriting the destination file.
				if resource.as_path().is_file() {
					tokio::fs::remove_file(resource.as_path()).await?;
				} else {
					tokio::fs::remove_dir_all(resource.as_path()).await?;
				}
				Ok(Some(resource))
			}
			UndoConflict::Rename => {
				// The logic for prompting the user and renaming the destination.
				let theme = ColorfulTheme::default();
				let input = RenameInput::<String>::with_theme(&theme)
					.with_prompt("Enter a new name for the destination")
					.with_initial_text(format!("{}", resource.as_path().file_name().unwrap_or_default().display()))
					.interact_text()
					.map(PathBuf::from)?;
				let new = resource.with_path(input);
				Ok(Some(new))
			}
			UndoConflict::Skip => Ok(None),
			UndoConflict::Abort => Err(UndoError::Abort),
			UndoConflict::AutoRename => Ok(Some(suggest_new_path(resource).await?)),
		}
	}
}

dyn_clone::clone_trait_object!(ActionBuilder);
dyn_eq::eq_trait_object!(ActionBuilder);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait ActionBuilder: DynEq + DynClone + Sync + Send + Debug {
	async fn build(&self, _ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error>;
}

dyn_clone::clone_trait_object!(Action);
dyn_eq::eq_trait_object!(Action);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Action: DynEq + DynClone + Sync + Send + Debug {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::default()
	}
	async fn commit(&self, _ctx: &ExecutionContext<'_>) -> Result<Receipt, Error>;
}

```

`organizer/organize-core\src\batch.rs`:

```rs
use std::{collections::HashMap, sync::Arc};

use crate::resource::Resource;

/// Represents a batch of files that have been grouped by one or more criteria.
/// This is the primary data structure that flows between pipeline stages.
#[derive(Debug, Clone)]
pub struct Batch {
	pub files: Vec<Arc<Resource>>,
	pub context: HashMap<String, String>,
}

impl Batch {
	pub fn new() -> Self {
		Self {
			files: Vec::new(),
			context: HashMap::new(),
		}
	}

	pub fn initial(files: Vec<Arc<Resource>>) -> Self {
		Self {
			files,
			context: HashMap::new(),
		}
	}
}

impl Default for Batch {
	fn default() -> Self {
		Self::new()
	}
}

```

`organizer/organize-core\src\builtins\actions\echo.rs`:

```rs
use crate::{
	action::{Action, ActionBuilder, Receipt},
	common::enabled,
	context::ExecutionContext,
	errors::Error,
	templates::template::{Template, TemplateString},
};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

use anyhow::Result;

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct EchoBuilder {
	pub message: TemplateString,
	#[serde(default = "enabled")]
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl ActionBuilder for EchoBuilder {
	async fn build(&self, ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error> {
		let message = ctx.services.compiler.compile_template(&self.message)?;
		Ok(Box::new(Echo {
			message,
			enabled: self.enabled,
		}))
	}
}

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct Echo {
	pub message: Template,
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl Action for Echo {
	async fn commit(&self, ctx: &ExecutionContext<'_>) -> Result<Receipt, Error> {
		if self.enabled {
			self.message
				.render(ctx)
				.await
				.inspect(|message| tracing::info!("{}", message))?;
		}
		Ok(Receipt {
			next: vec![ctx.scope.resource()?],
			..Default::default()
		})
	}
}

```

`organizer/organize-core\src\builtins\actions\mod.rs`:

```rs
pub mod echo;
// pub mod r#move;

```

`organizer/organize-core\src\builtins\mod.rs`:

```rs
pub mod actions;
pub mod selectors;
pub mod sorters;
pub mod storage;
pub mod variables;

```

`organizer/organize-core\src\builtins\selectors\first.rs`:

```rs
use crate::{
    batch::Batch,
    errors::Error,
    selector::Selector,
};
use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FirstSelector {
    pub n: usize,
}

#[async_trait]
#[typetag::serde(name = "first")]
impl Selector for FirstSelector {
    async fn select(&self, batch: &Batch) -> Result<Batch, Error> {
        let mut selected_batch = Batch::new();
        selected_batch.files = batch.files.iter().take(self.n).cloned().collect();
        // The context from the original batch is not preserved by default,
        // as it might not be relevant to the new, smaller batch.
        Ok(selected_batch)
    }
}

```

`organizer/organize-core\src\builtins\selectors\mod.rs`:

```rs
pub mod first;

```

`organizer/organize-core\src\builtins\sorters\mod.rs`:

```rs
pub mod random;

```

`organizer/organize-core\src\builtins\sorters\random.rs`:

```rs
use crate::{resource::Resource, sorter::Sorter};
use async_trait::async_trait;
use rand::{rng, seq::SliceRandom};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub struct RandomSorter;

#[async_trait]
#[typetag::serde(name = "random")]
impl Sorter for RandomSorter {
	async fn sort(&self, files: &mut [Arc<Resource>]) {
		let mut rng = rng();
		files.shuffle(&mut rng);
	}
}

```

`organizer/organize-core\src\builtins\variables\env.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

// This accessor is created dynamically. It stores the environment
// variable key that it needs to look up.
#[derive(Debug, Clone, PartialEq, Eq)]
struct EnvAccessor {
	key: String,
}

#[async_trait]
impl Accessor for EnvAccessor {
	async fn get(&self, _ctx: &ExecutionContext) -> Result<Value> {
		let value = std::env::var(&self.key).ok();
		Ok(Value::OptionString(value))
	}
}

/// The provider for the `{{ env }}` variable.
#[derive(Debug, Clone)]
pub struct EnvProvider;

impl StatelessVariable for EnvProvider {
	fn name(&self) -> &'static str {
		"env"
	}

	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			// This node indicates that `env` is a map with dynamic keys.
			node: SchemaNode::DynamicMap(Arc::new(|key: &str| {
				// The constructor captures the key from the property chain
				// (e.g., "HOME") and creates an EnvAccessor for it.
				Box::new(EnvAccessor { key: key.to_string() })
			})),
		}
	}
}

// Automatically register the `EnvProvider` with the global inventory.
static ENV_PROVIDER: EnvProvider = EnvProvider;
inventory::submit!(VariableInventory { provider: &ENV_PROVIDER });

```

`organizer/organize-core\src\builtins\variables\file.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FileProvider;

#[derive(Debug, Clone, PartialEq, Eq)]
struct Path;

#[async_trait]
impl Accessor for Path {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let path_str = resource.path.to_string_lossy().to_string();
		Ok(Value::String(path_str))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Name;

#[async_trait]
impl Accessor for Name {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_name().map(|name| name.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Stem;

#[async_trait]
impl Accessor for Stem {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_stem().map(|stem| stem.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Extension;

#[async_trait]
impl Accessor for Extension {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.extension().map(|ext| ext.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

// SCHEMA AND REGISTRATION

impl StatelessVariable for FileProvider {
	fn name(&self) -> &'static str {
		"file"
	}

	/// Defines the schema for the `file` variable.
	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			node: SchemaNode::Object(vec![
				Property {
					name: "path",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Path))),
				},
				Property {
					name: "name",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Name))),
				},
				Property {
					name: "stem",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Stem))),
				},
				Property {
					name: "extension",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Extension))),
				},
			]),
		}
	}
}

inventory::submit! {
	VariableInventory {
		provider: &FileProvider
	}
}

```

`organizer/organize-core\src\builtins\variables\mod.rs`:

```rs
pub mod env;
pub mod file;

```

`organizer/organize-core\src\common\mod.rs`:

```rs
pub fn enabled() -> bool {
	true
}

```

`organizer/organize-core\src\config.rs`:

```rs



// #[cfg(test)]
// mod tests {
// 	use std::sync::LazyLock;

// 	use super::ConfigBuilder;
// 	use itertools::Itertools;
// 	use toml::toml;

// 	static TOML: LazyLock<toml::Table> = LazyLock::new(|| {
// 		toml! {

// 				[[rules]]
// 				id = "test-rule-1"
// 				tags = ["tag1"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-2"
// 				tags = ["tag2"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-3"
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				actions = []
// 				filters = []
// 				folders = []

// 		}
// 	});

// 	static CONFIG: LazyLock<ConfigBuilder> = LazyLock::new(|| toml::from_str(&TOML.to_string()).unwrap());

// 	#[test]
// 	fn filter_rules_by_tag_positive() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["tag2"]).iter().map(|&r| r.clone()).collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_negative() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["!tag2"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap(), CONFIG.rules.get(3).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["!tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(2..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_positive() {
// 		let found_rules = CONFIG.filter_rules_by_id(["test-rule-1"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1"])
// 			.iter()
// 			.map(|r| (*r).clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=2).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "test-rule-2"])
// 			.iter()
// 			.map(|&r| r.clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(0..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// }

```

`organizer/organize-core\src\context\mod.rs`:

```rs
use anyhow::Result;
use dashmap::DashMap;
use std::{
	any::Any,
	path::{Path, PathBuf},
	sync::Arc,
};

pub mod services;

use crate::{
	batch::Batch,
	context::services::{fs::manager::FileSystemManager, history::Journal},
	errors::Error,
	folder::Location,
	resource::Resource,
	rule::RuleMetadata,
	templates::compiler::TemplateCompiler,
};

#[derive(Debug, Clone)]
pub struct RunServices {
	pub blackboard: Blackboard,
	pub fs: FileSystemManager,
	pub journal: Arc<Journal>,
	pub compiler: TemplateCompiler,
}

#[derive(Debug, Clone)]
pub struct Blackboard {
	pub scratchpad: Arc<DashMap<String, Box<dyn Any + Send + Sync>>>,
	pub shared_context: Arc<DashMap<String, String>>,
}

impl Default for Blackboard {
	fn default() -> Self {
		Self {
			scratchpad: Arc::new(DashMap::new()),
			shared_context: Arc::new(DashMap::new()),
		}
	}
}

/// A container for run-wide operational settings.
#[derive(Debug, Clone, Copy)]
pub struct RunSettings {
	pub dry_run: bool,
}

/// A read-only "view" into the current position in the configuration tree.
// #[derive(Debug, Clone)]
// pub struct ExecutionScope<'a> {
// 	pub config: &'a Config,
// 	pub rule: Option<&'a Rule>,
// 	pub folder: Option<&'a Folder>,
// 	pub resource: Option<Arc<Resource>>,
// 	pub resources: Option<Vec<Arc<Resource>>>,
// }

#[derive(Debug, Clone)]
pub enum ExecutionScope<'a> {
	Rule(RuleScope),
	Search(SearchScope<'a>),
	Resource(ResourceScope),
	Batch(BatchScope<'a>),
	Build(BuildScope),
	Blank,
}

impl<'a> ExecutionScope<'a> {
	pub fn new_rule_scope(rule: Arc<RuleMetadata>) -> ExecutionScope<'a> {
		ExecutionScope::Rule(RuleScope { rule })
	}

	pub fn new_location_scope(rule: Arc<RuleMetadata>, location: &'a Location) -> ExecutionScope<'a> {
		ExecutionScope::Search(SearchScope { rule, location })
	}

	pub fn new_resource_scope(rule: Arc<RuleMetadata>, resource: Arc<Resource>) -> ExecutionScope<'a> {
		ExecutionScope::Resource(ResourceScope { rule, resource })
	}

	pub fn new_batch_scope(rule: Arc<RuleMetadata>, batch: &'a Batch) -> ExecutionScope<'a> {
		ExecutionScope::Batch(BatchScope { rule, batch })
	}

	pub fn new_build_scope(root: &Path) -> ExecutionScope<'a> {
		ExecutionScope::Build(BuildScope { root: root.to_path_buf() })
	}

	pub fn rule(&self) -> Result<Arc<RuleMetadata>, Error> {
		match self {
			ExecutionScope::Rule(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Batch(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Search(scope) => Ok(scope.rule.clone()),
			_ => Err(Error::OutOfScope("rule".into())),
		}
	}

	pub fn resource(&self) -> Result<Arc<Resource>, Error> {
		match self {
			ExecutionScope::Resource(scope) => Ok(scope.resource.clone()),
			_ => Err(Error::OutOfScope("resource".into())),
		}
	}

	pub fn batch(&self) -> Result<&'a Batch, Error> {
		match self {
			ExecutionScope::Batch(scope) => Ok(scope.batch),
			_ => Err(Error::OutOfScope("batch".into())),
		}
	}

	pub fn root(&self) -> Result<PathBuf, Error> {
		match self {
			ExecutionScope::Search(scope) => Ok(scope.location.path.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.resource.location.path.clone()),
			ExecutionScope::Build(path) => Ok(path.root.clone()), // <-- ADD THIS CASE
			_ => Err(Error::OutOfScope("root".into())),
		}
	}
}

#[derive(Debug, Clone)]
pub struct RuleScope {
	pub rule: Arc<RuleMetadata>,
}
#[derive(Debug, Clone)]
pub struct SearchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub location: &'a Location,
}
#[derive(Debug, Clone)]
pub struct ResourceScope {
	pub rule: Arc<RuleMetadata>,
	pub resource: Arc<Resource>,
}
#[derive(Debug, Clone)]
pub struct BatchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub batch: &'a Batch,
}

#[derive(Debug, Clone)]
pub struct BuildScope {
	pub root: PathBuf,
}

/// The top-level context object, composed of the three distinct categories of information.
#[derive(Clone, Debug)]
pub struct ExecutionContext<'a> {
	pub services: &'a RunServices,
	pub scope: ExecutionScope<'a>,
	pub settings: &'a RunSettings,
}

impl<'a> ExecutionContext<'a> {
	pub fn with_scope(&'a self, scope: ExecutionScope<'a>) -> ExecutionContext<'a> {
		Self {
			services: self.services,
			scope,
			settings: self.settings,
		}
	}
}

// #[cfg(test)]
// pub struct ContextHarness {
// 	pub services: RunServices,
// 	pub settings: RunSettings,
// 	pub config: Config,
// 	pub rule: Rule,
// 	pub folder: Folder,
// 	pub resource: Resource,
// 	pub resources: Vec<Resource>,
// }

// #[cfg(test)]
// impl<'a> ContextHarness {
// 	/// Creates a new harness with default, dummy data.
// 	pub fn new(resource: Resource, resources: Vec<Resource>) -> Self {
// 		Self {
// 			services: RunServices::default(),
// 			config: Config::default(),
// 			settings: RunSettings {
// 				dry_run: true,
// 				no_parallel: true,
// 			},
// 			rule: Rule::default(),
// 			folder: Folder::default(),
// 			resource,
// 			resources,
// 		}
// 	}

// 	/// Returns a valid `ExecutionContext` with references to the harness's data.
// 	pub fn context(&'a self) -> ExecutionContext<'a> {
// 		let scope = ExecutionScope {
// 			config: &self.config,
// 			rule: &self.rule,
// 			folder: &self.folder,
// 			resource: &self.resource,
// 			resources: &self.resources,
// 		};
// 		ExecutionContext {
// 			services: &self.services,
// 			settings: &self.settings,
// 			scope,
// 		}
// 	}
// }
// Provide `Default` implementations for the final, compiled structs.
// These are only compiled for tests and allow for easy instantiation of dummy objects.

```

`organizer/organize-core\src\context\services\fs\locker.rs`:

```rs
use crate::{
	context::{services::fs::manager::Destination, ExecutionContext},
	engine::ConflictResolution,
	errors::Error,
};
use anyhow::Result;
use dashmap::DashSet;
use std::{future::Future, path::PathBuf, sync::Arc};

#[derive(Debug, Clone, Default)]
pub struct Locker {
	active_paths: Arc<DashSet<PathBuf>>,
}

impl Locker {
	pub async fn with_locked_destination<F, Fut, T>(
		&self,
		ctx: &ExecutionContext<'_>,
		destination: &Destination,
		strategy: &ConflictResolution,
		action: F,
	) -> Result<Option<T>, Error>
	where
		F: FnOnce(PathBuf) -> Fut,
		Fut: Future<Output = Result<T, Error>>,
	{
		let mut path = destination.resolve(ctx).await?;
		let mut n = 1;

		let reserved = loop {
			if self.active_paths.contains(&path) {
				match strategy {
					ConflictResolution::Skip | ConflictResolution::Overwrite => return Ok(None),
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			let exists = if let Some(res) = ctx.services.fs.resources.get(&path).await {
				res.try_exists(ctx).await?
			} else {
				tokio::fs::try_exists(&path).await?
			};

			if exists {
				match strategy {
					ConflictResolution::Skip => return Ok(None),
					ConflictResolution::Overwrite => {
						if !self.active_paths.insert(path.to_path_buf()) {
							return Ok(None);
						}
						break Some(path);
					}
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			if !self.active_paths.insert(path.to_path_buf()) {
				continue;
			}
			break Some(path);
		};

		if let Some(target) = reserved {
			ctx.services.fs.ensure_parent_dir_exists(&target).await?;
			let result = action(target.clone()).await?;

			self.active_paths.remove(&target.to_path_buf());

			Ok(Some(result))
		} else {
			Ok(None)
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\manager.rs`:

```rs
use crate::{
	context::{services::fs::locker::Locker, ExecutionContext},
	errors::Error,
	folder::LocalFileSystem,
	resource::{FileState, Resource},
	storage::StorageProvider,
	templates::template::{Template, TemplateString},
};
use anyhow::Result;
use moka::future::Cache;
use serde::{Deserialize, Serialize};
use std::{
	collections::HashMap,
	iter::FromIterator,
	path::{Path, PathBuf},
	sync::Arc,
};
use url::Url; // Assuming this is needed for dry_run and context

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub struct DestinationBuilder {
	pub folder: TemplateString,
	pub filename: Option<TemplateString>,
}
impl DestinationBuilder {
	/// Compiles the raw DestinationBuilder into an executable Destination.
	pub fn build(self, ctx: &ExecutionContext<'_>) -> Result<Destination, Error> {
		let folder = ctx.services.compiler.compile_template(&self.folder)?;
		let filename = self.filename.map(|f| ctx.services.compiler.compile_template(&f)).transpose()?; // This elegantly handles the Option<Result<T, E>>
		Ok(Destination { folder, filename })
	}
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Destination {
	pub folder: Template,
	pub filename: Option<Template>,
}

impl Destination {
	pub async fn resolve(&self, ctx: &ExecutionContext<'_>) -> Result<PathBuf> {
		let mut folder = PathBuf::from(self.folder.render(ctx).await?);
		if let Some(filename_template) = &self.filename {
			let filename = filename_template.render(ctx).await?;
			folder.push(filename);
		}
		// A placeholder for the original filename if `filename` is not provided.
		// This would need access to the resource from the context.
		else if let Ok(resource) = ctx.scope.resource() {
			if let Some(name) = resource.path.file_name() {
				folder.push(name);
			}
		}
		Ok(folder)
	}
}

#[derive(Debug, Clone)]
pub struct FileSystemManager {
	pub locker: Locker,
	pub resources: Cache<PathBuf, Arc<Resource>>,
	pub tracked_files: Cache<PathBuf, FileState>,
	pub backends: HashMap<String, Arc<dyn StorageProvider>>,
}

pub fn parse_uri(uri_str: &str) -> anyhow::Result<(String, String)> {
	// For local paths, we must construct a valid file URI first.
	if !uri_str.contains("://") {
		// let path = PathBuf::from(uri_str).clean();
		// dbg!(&path);
		// This will correctly handle paths on both Windows and Unix.
		// let url = Url::from_file_path(path).map_err(|_| anyhow::anyhow!("Invalid local path"))?;
		// Return "local" as the host (backend) and the original path.
		return Ok(("local".to_string(), uri_str.to_string()));
	}

	let url = Url::parse(uri_str)?;
	let host = url
		.host_str()
		.ok_or_else(|| anyhow::anyhow!("URI is missing a host (connection name)"))?;
	let path = url.path().to_string();

	Ok((host.to_string(), path))
}

impl Default for FileSystemManager {
	fn default() -> Self {
		Self::new()
	}
}

impl FileSystemManager {
	pub fn new() -> Self {
		let local: Arc<dyn StorageProvider> = Arc::new(LocalFileSystem);
		let backends = HashMap::from_iter(vec![("local".to_string(), local)]);
		Self {
			locker: Locker::default(),
			resources: Cache::new(10_000),
			tracked_files: Cache::new(10_000),
			backends,
		}
	}

	pub async fn ensure_parent_dir_exists(&self, path: &Path) -> std::io::Result<()> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		// resources: CacheBuilder::new(1_000_000)
		// 	.time_to_live(Duration::new(60 * 60 * 24, 0)) // ONE DAY
		// 	.name("cached_resources")
		// 	.build(),
		Ok(())
	}

	pub async fn r#move(&self, source: Arc<Resource>, destination: Arc<Resource>) -> Result<(), Error> {
		// Attempt a direct rename first
		self.ensure_parent_dir_exists(destination.as_path()).await?;
		match tokio::fs::rename(source.as_path(), destination.as_path()).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					source.as_path().display(),
					destination.as_path().display()
				);

				// Perform copy
				tokio::fs::copy(source.as_path(), destination.as_path()).await?;

				// If copy is successful, delete the original
				Ok(tokio::fs::remove_file(source.as_path()).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\mod.rs`:

```rs
pub mod locker;
pub mod manager;

```

`organizer/organize-core\src\context\services\history\mod.rs`:

```rs
use crate::{
	action::{Action, Receipt},
	context::RunSettings,
};
use anyhow::Result;
use sqlx::{sqlite::SqlitePoolOptions, SqlitePool};
use std::time::{SystemTime, UNIX_EPOCH};

/// The Journal service, responsible for all database interactions.
#[derive(Debug, Clone)]
pub struct Journal {
	pool: SqlitePool,
}

#[derive(Debug)]
pub struct Transaction {
	pub id: i64,
	pub receipt: Receipt,
}

impl Journal {
	/// Creates a new Journal instance, connects to the database, and runs migrations.
	pub async fn new(settings: &RunSettings) -> Result<Self> {
		let db_url = if settings.dry_run {
			// For a dry run, use a temporary, private in-memory SQLite database.
			"sqlite::memory:".to_string()
		} else {
			// For a real run, use the persistent database file specified in .env.
			dotenvy::dotenv().ok();
			std::env::var("DATABASE_URL").expect("DATABASE_URL must be set for real runs")
		};

		let pool = SqlitePoolOptions::new().max_connections(5).connect(&db_url).await?;
		sqlx::migrate!("./migrations").run(&pool).await?;

		Ok(Self { pool })
	}

	pub async fn start_session(&self) -> Result<i64> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;

		let record = sqlx::query!(
			r#"
            INSERT INTO sessions (start_time, status)
            VALUES (?1, 'running')
            "#,
			now,
		)
		.execute(&self.pool)
		.await?;

		Ok(record.last_insert_rowid())
	}

	#[allow(clippy::borrowed_box)]
	pub async fn record_transaction(&self, session_id: i64, action: &Box<dyn Action>, receipt: &Receipt) -> Result<()> {
		if receipt.undo.is_empty() {
			return Ok(());
		}

		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		let action_type = action.typetag_name();

		let action_data = serde_json::to_string(action)?;
		let receipt_data = serde_json::to_string(receipt)?;

		sqlx::query!(
			r#"
            INSERT INTO transactions (session_id, type, action, receipt, timestamp)
            VALUES (?1, ?2, ?3, ?4, ?5)
            "#,
			session_id,
			action_type,
			action_data,
			receipt_data,
			now
		)
		.execute(&self.pool)
		.await?;

		Ok(())
	}

	pub async fn get_pending_transactions_for_session(&self, session_id: i64) -> Result<Vec<Transaction>> {
		let transactions = sqlx::query_as!(
			Transaction,
			"SELECT id, receipt FROM transactions WHERE session_id = ? AND undo_status = 'PENDING' ORDER BY timestamp DESC",
			session_id
		)
		.fetch_all(&self.pool)
		.await?;

		Ok(transactions)
	}

	pub async fn update_transaction_undo_status(&self, transaction_id: i64, status: &str) -> Result<()> {
		sqlx::query!("UPDATE transactions SET undo_status = ? WHERE id = ?", status, transaction_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	/// Marks a session as completed with a final status.
	pub async fn end_session(&self, session_id: i64, status: &str) -> Result<()> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		sqlx::query!("UPDATE sessions SET end_time = ?1, status = ?2 WHERE id = ?3", now, status, session_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	pub async fn get_last_session_id(&self) -> Result<Option<i64>> {
		let result = sqlx::query!("SELECT id FROM sessions ORDER BY start_time DESC LIMIT 1")
			.fetch_optional(&self.pool)
			.await?;
		Ok(result.map(|row| row.id))
	}
}

```

`organizer/organize-core\src\context\services\mod.rs`:

```rs
pub mod fs;
pub mod history;

```

`organizer/organize-core\src\engine.rs`:

```rs
use crate::{
	context::{
		services::{fs::manager::FileSystemManager, history::Journal},
		Blackboard,
		ExecutionContext,
		ExecutionScope,
		RunServices,
		RunSettings,
	},
	pipeline::Pipeline,
	rule::{Rule, RuleBuilder},
	templates::compiler::TemplateCompiler,
};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::{path::PathBuf, sync::Arc};
use strum::Display;

#[derive(Default)]
pub enum ExecutionModel {
	#[default]
	Single,
	Batch,
}

#[derive(Eq, Display, PartialEq, Default, Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all(serialize = "lowercase", deserialize = "lowercase"))]
#[strum(serialize_all = "snake_case")]
pub enum ConflictResolution {
	Overwrite,
	#[default]
	Skip,
	Rename,
}

/// The main engine for the application.
/// It owns the compiled configuration and all run-wide services.
pub struct Engine {
	rule: Rule,
	services: RunServices,
	settings: RunSettings,
}

impl Engine {
	pub async fn new(path: &PathBuf, settings: RunSettings) -> Result<Arc<Self>> {
		let services = RunServices {
			blackboard: Blackboard::default(),
			journal: Arc::new(Journal::new(&settings).await?),
			fs: FileSystemManager::new(),
			compiler: TemplateCompiler::new(),
		};
		let content = tokio::fs::read_to_string(path).await?;
		let rule = {
			let builder: RuleBuilder = toml::from_str(&content)?;
			let ctx = ExecutionContext {
				services: &services,
				scope: ExecutionScope::Blank,
				settings: &settings,
			};
			let rule = builder.build(&ctx).await?;
			rule
		};

		Ok(Arc::new(Self { rule, services, settings }))
	}

	pub async fn run(&self) -> Result<()> {
		let pipeline = Pipeline::new(self.rule.clone());

		// Create the top-level execution context with a blank scope.
		let ctx = ExecutionContext {
			services: &self.services,
			settings: &self.settings, // Assuming you have settings
			scope: ExecutionScope::Blank,
		};

		let _final_stream = pipeline.run(&ctx).await?;
		Ok(())
	}
}

```

`organizer/organize-core\src\errors.rs`:

```rs
use std::path::PathBuf;
use thiserror::Error;

use crate::{action::UndoError, parser::errors::ParseError, templates::engine::TemplateError};

/// The primary error type for all actions within the application.
#[derive(Error, Debug)]
pub enum Error {
	#[error("Error converting to value")]
	Json(#[from] serde_json::Error),

	#[error(transparent)]
	Io(#[from] std::io::Error),

	#[error(transparent)]
	Other(#[from] anyhow::Error),

	#[error("Could not create backup for: {path:?}")]
	Backup {
		#[source]
		source: std::io::Error,
		path: PathBuf,
	},

	#[error(transparent)]
	ParseError(#[from] ParseError),

	#[error("Error in prompt")]
	Interaction {
		#[source]
		source: std::io::Error,
		prompt: String,
	},

	#[error(transparent)]
	TemplateError(#[from] TemplateError),

	#[error("Tried to retrieve `{0}` from the scope but it is not defined")]
	OutOfScope(String),

	#[error(transparent)]
	UndoError(#[from] UndoError),
}

```

`organizer/organize-core\src\filter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

// pub mod content;
// pub mod empty;
// pub mod extension;
// pub mod filename;
// pub mod mime;
// pub mod regex;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource};

dyn_clone::clone_trait_object!(Filter);
dyn_eq::eq_trait_object!(Filter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Filter: DynClone + DynEq + Debug + Send + Sync {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::Single
	}

	/// Takes the execution context, which contains the appropriate scope,
	/// and returns a Result containing the list of files that passed.
	async fn filter(&self, ctx: &ExecutionContext) -> Result<Vec<Arc<Resource>>, Error>;
}

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct Not(Box<dyn Filter>);

// impl std::ops::Deref for Not {
// 	type Target = Box<dyn Filter>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "not")]
// impl Filter for Not {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		!self.filter(ctx).await
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AnyOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AnyOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "any_of")]
// impl Filter for AnyOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().any(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AllOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AllOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "all_of")]
// impl Filter for AllOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().all(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct NoneOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for NoneOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "none_of")]
// impl Filter for NoneOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		!results.iter().any(|&result| result)
// 	}
// }

```

`organizer/organize-core\src\folder.rs`:

```rs
use std::{
	collections::HashSet,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

use anyhow::{Context as ErrorContext, Result};
use async_trait::async_trait;
use futures::{stream, StreamExt};
use serde::{Deserialize, Serialize};

use crate::{
	context::{services::fs::manager::parse_uri, ExecutionContext, ExecutionScope},
	errors::Error,
	options::OptionsBuilder,
	resource::Resource,
	stdx::path::PathExt,
	storage::StorageProvider,
	templates::template::TemplateString,
};

use super::options::{Options, Target};

#[derive(Debug, Serialize, PartialEq, Eq, Clone, Deserialize)]
pub struct LocationBuilder {
	pub path: TemplateString,
	#[serde(flatten)]
	pub options: OptionsBuilder,
	#[serde(default)]
	pub mode: SearchMode,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Location {
	pub path: PathBuf,
	pub options: Options,
	pub mode: SearchMode,
	pub backend: Arc<dyn StorageProvider>,
}

impl PartialEq for Location {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path && self.options == other.options && self.mode == other.mode
	}
}

impl Eq for Location {}

impl LocationBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Location, Error> {
		let path_template = ctx.services.compiler.compile_template(&self.path)?;
		let uri = path_template.render(ctx).await?;
		let (host, path) = parse_uri(&uri)?;
		let path = PathBuf::from(path);

		let ctx = &ExecutionContext {
			services: ctx.services,
			scope: ExecutionScope::new_build_scope(&path),
			settings: ctx.settings,
		};

		Ok(Location {
			path,
			options: self.options.compile(ctx).await?,
			mode: self.mode,
			backend: ctx.services.fs.backends.get(&host).unwrap().clone(), // The direct Arc clone to the provider
		})
	}
}
/// The final, compiled `Folder` object, ready for execution.

#[derive(Debug, Deserialize, Serialize, Default, PartialEq, Eq, Clone)]
#[serde(rename_all = "lowercase")]
pub enum SearchMode {
	Replace,
	#[default]
	Append,
}

impl SearchMode {
	/// Returns `true` if the search mode is [`Replace`].
	///
	/// [`Replace`]: SearchMode::Replace
	#[must_use]
	pub fn is_replace(&self) -> bool {
		matches!(self, Self::Replace)
	}

	/// Returns `true` if the search mode is [`Append`].
	///
	/// [`Append`]: SearchMode::Append
	#[must_use]
	pub fn is_append(&self) -> bool {
		matches!(self, Self::Append)
	}
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct LocalFileSystem;

#[async_trait]
#[typetag::serde(name = "local")]
impl StorageProvider for LocalFileSystem {
	fn prefix(&self) -> &'static str {
		"file"
	}

	fn home(&self) -> Result<PathBuf, Error> {
		Ok(dirs::home_dir().context("unable to find home directory")?)
	}

	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		Ok(())
	}

	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		// ctx.services.fs.ensure_parent_dir_exists(destination.as_path()).await?;
		self.mkdir(to, ctx).await?;
		match tokio::fs::rename(from, to).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					from.display(),
					to.display()
				);

				tokio::fs::copy(from, to).await?;
				Ok(tokio::fs::remove_file(from).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}

	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn delete(&self, path: &Path) -> Result<(), Error> {
		todo!()
	}

	async fn download(&self, from: &Path) -> Result<PathBuf, Error> {
		Ok(PathBuf::new())
	}

	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		Ok(())
	}

	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error> {
		let concurrency_limit = 50;
		let home = self.home()?;
		let min_depth = {
			let base = if location.path == home {
				1.0 as usize
			} else {
				location.options.min_depth
			};
			(base as f64).max(1.0) as usize
		};

		let max_depth = if location.path == home {
			1.0 as usize
		} else {
			location.options.max_depth
		};

		let mut collected_paths = Vec::new();
		let mut dirs_to_visit: Vec<(PathBuf, usize)> = vec![];

		let excluded_paths_set: HashSet<&PathBuf> = location.options.exclude.iter().collect();

		if excluded_paths_set.contains(&location.path) {
			tracing::warn!(
				"Start directory '{}' is in the excluded paths. Aborting search.",
				&location.path.display()
			);
			return Ok(Vec::new());
		}

		if min_depth == 0 {
			collected_paths.push(location.path.clone());
		}

		dirs_to_visit.push((location.path.clone(), 0));

		while let Some((current_dir, current_depth)) = dirs_to_visit.pop() {
			if current_depth >= max_depth {
				continue;
			}

			let mut entries = match tokio::fs::read_dir(&current_dir).await {
				Ok(e) => e,
				Err(e) => {
					eprintln!("Warning: Could not read directory {}: {}", current_dir.display(), e);
					continue;
				}
			};

			while let Some(entry) = entries.next_entry().await? {
				let path = entry.path();
				let next_depth = current_depth + 1;

				// --- Exclusion Logic for encountered paths (files or directories) ---
				if excluded_paths_set.contains(&path) {
					eprintln!("Excluding path: {}", path.display());
					// If it's a directory, we effectively prune the branch.
					// If it's a file, we just don't collect it.
					continue;
				}
				// --- End Exclusion Logic ---

				// Only add &location.path if it's within the specified depth range
				if next_depth >= min_depth && next_depth <= max_depth {
					collected_paths.push(path.clone());
				}

				// If it's a directory and still within max_depth, add it to dirs_to_visit
				// (after checking for exclusion, which is done above)
				if path.is_dir() && next_depth < max_depth {
					dirs_to_visit.push((path, next_depth));
				}
			}
		}

		// let all_files = self.find_all_files(min_depth, max_depth, ctx).await?;
		let location: Arc<Location> = Arc::new(location.clone());
		let resource_creation_futures = collected_paths
			.into_iter()
			.filter(|e| self.filter_entries(e, &location.options))
			.map(|e| {
				// Capture `e` by moving it into the async block
				// Capture `ctx` by reference (or clone/Arc if its lifetime is an issue)
				let ctx_ref = ctx;
				let location = location.clone();
				async move {
					e.as_resource(ctx_ref, location).await // Returns Result<Resource, AsResourceError>
				}
			});

		Ok(stream::iter(resource_creation_futures) // stream::iter expects an Iterator<Item=Future>
			.buffer_unordered(concurrency_limit) // Execute Futures concurrently
			.collect()
			.await)
	}

	async fn metadata(&self, path: &Path) -> Result<Metadata, Error> {
		Ok(tokio::fs::metadata(path).await?)
	}

	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error> {
		let mut dir = tokio::fs::read_dir(path).await?;
		let mut paths = vec![];
		while let Some(entry) = dir.next_entry().await? {
			paths.push(entry.path());
		}
		Ok(paths)
	}

	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error> {
		Ok(tokio::fs::read(path).await?)
	}

	async fn write(&self, path: &Path, content: &[u8]) -> Result<()> {
		todo!()
	}
}

impl LocalFileSystem {
	fn filter_entries(&self, path: &Path, options: &Options) -> bool {
		if path.is_file() && options.target == Target::Folders {
			return false;
		}
		if path.is_dir() && options.target == Target::Files {
			return false;
		}

		if path.is_file() {
			if let Some(extension) = path.extension() {
				let partial_extensions = &["crdownload", "part", "download"];
				if partial_extensions.contains(&&*extension.to_string_lossy()) && !options.partial_files {
					return false;
				}
			}
			if path.is_hidden().unwrap_or(false) && !options.hidden_files {
				return false;
			}
		}
		true
	}
}

```

`organizer/organize-core\src\grouper.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

use crate::{batch::Batch, errors::Error};

dyn_clone::clone_trait_object!(Grouper);
dyn_eq::eq_trait_object!(Grouper);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Grouper: DynEq + DynClone + Sync + Send + Debug {
	fn name(&self) -> &str;
	async fn group(&self, batch: &Batch) -> Result<Vec<Batch>, Error>;
}

```

`organizer/organize-core\src\lib.rs`:

```rs
#![feature(file_lock)]
#![feature(path_add_extension)]
#![feature(lock_value_accessors)]

pub const PROJECT_NAME: &str = "organize";

pub mod action;
pub mod batch;
pub mod builtins;
pub mod common;
pub mod config;
pub mod context;
pub mod engine;
pub mod errors;
pub mod filter;
pub mod folder;
pub mod grouper;
pub mod selector;
// pub mod hook;
pub mod options;
pub mod parser;
pub mod pipeline;
pub mod resource;
pub mod rule;
pub mod sorter;
pub mod stdx;
pub mod storage;
pub mod templates;
pub mod utils;

```

`organizer/organize-core\src\options.rs`:

```rs
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, path::PathBuf};

use crate::{context::ExecutionContext, errors::Error, templates::template::TemplateString};

fn default_usize() -> usize {
	1.0 as usize
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct OptionsBuilder {
	#[serde(default = "default_usize")]
	pub max_depth: usize,
	#[serde(default = "default_usize")]
	pub min_depth: usize,
	#[serde(default)]
	pub exclude: Vec<TemplateString>,
	#[serde(default)]
	pub hidden_files: bool,
	#[serde(default)]
	pub partial_files: bool,
	#[serde(default)]
	pub target: Target,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Options {
	pub max_depth: usize,
	pub min_depth: usize,
	pub exclude: Vec<PathBuf>,
	pub hidden_files: bool,
	pub partial_files: bool,
	pub target: Target,
}

impl OptionsBuilder {
	pub async fn compile(self, ctx: &ExecutionContext<'_>) -> Result<Options, Error> {
		let mut excluded_paths = Vec::new();

		for template in &self.exclude {
			let template = ctx.services.compiler.compile_template(template)?;
			if let Ok(rendered_path_str) = template.render(ctx).await {
				excluded_paths.push(PathBuf::from(rendered_path_str));
			}
		}

		Ok(Options {
			max_depth: self.max_depth,
			min_depth: self.min_depth,
			exclude: excluded_paths,
			hidden_files: self.hidden_files,
			partial_files: self.partial_files,
			target: self.target,
		})
	}
}

#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Target {
	#[default]
	Files,
	Folders,
}

```

`organizer/organize-core\src\parser\ast.rs`:

```rs
use chumsky::Parser;
use logos::Logos;

use crate::parser::{
	errors::ParseError,
	lexer::{LexingError, Token},
	parser,
};

// For now, an Expression is just a VariablePath.
// We can add Literals here later if needed.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Expression {
	Variable(Vec<String>),
}

// A full template is a sequence of literal text and expressions.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Segment {
	Literal(String),
	Expression(Expression),
}

#[derive(Debug, PartialEq, Clone, Eq)]
pub struct AST {
	pub segments: Vec<Segment>,
}

impl AST {
	/// Parses a raw string into an Abstract Syntax Tree (AST).
	/// This function orchestrates the lexer and expression parser.
	pub fn parse(s: &str) -> Result<Self, ParseError> {
		let mut segments = Vec::new();
		let mut input = s;

		while !input.is_empty() {
			// Find the start of the next expression
			if let Some(start_delim) = input.find("{{") {
				// Anything before the `{{` is a literal
				if start_delim > 0 {
					segments.push(Segment::Literal(input[..start_delim].to_string()));
				}

				// Find the end of the expression
				let expr_content_start = start_delim + 2;
				if let Some(end_delim_relative) = input[expr_content_start..].find("}}") {
					let expr_content_end = expr_content_start + end_delim_relative;
					let expression_content = &input[expr_content_start..expr_content_end].trim();

					// Lex and parse the content inside the delimiters
					let tokens = Token::lexer(expression_content).collect::<Result<Vec<Token<'_>>, LexingError>>()?;

					let (expression, errs) = parser().parse(&tokens).into_output_errors();

					match expression {
						Some(expr) => segments.push(Segment::Expression(expr)),
						None => {
							return Err(ParseError::InvalidExpression {
								content: format!("Could not parse expression: '{{ {expression_content} }}'. Errors: {errs:?}"),
							})
						}
					}

					// Advance the input slice past the `}}`
					input = &input[expr_content_end + 2..];
				} else {
					return Err(ParseError::MismatchedDelimiters {
						position: expr_content_start,
					});
				}
			} else {
				// No more `{{` found, the rest of the string is a literal
				segments.push(Segment::Literal(input.to_string()));
				break;
			}
		}

		Ok(AST { segments })
	}
}

```

`organizer/organize-core\src\parser\errors.rs`:

```rs
use crate::parser::lexer::LexingError;
use thiserror::Error;

// This will be the single, unified error type returned by your parser.
#[derive(Error, Debug)]
pub enum ParseError {
	#[error("Mismatched delimiters: found '{{' at position {position} with no closing '}}'")]
	MismatchedDelimiters { position: usize },

	#[error("Could not parse expression: '{{ {content} }}'")]
	InvalidExpression { content: String },

	#[error(transparent)]
	LexingError(#[from] LexingError),
}

impl ParseError {
	/// Returns `true` if the parse error is [`MismatchedDelimiters`].
	///
	/// [`MismatchedDelimiters`]: ParseError::MismatchedDelimiters
	#[must_use]
	pub fn is_mismatched_delimiters(&self) -> bool {
		matches!(self, Self::MismatchedDelimiters { .. })
	}

	/// Returns `true` if the parse error is [`InvalidExpression`].
	///
	/// [`InvalidExpression`]: ParseError::InvalidExpression
	#[must_use]
	pub fn is_invalid_expression(&self) -> bool {
		matches!(self, Self::InvalidExpression { .. })
	}

	/// Returns `true` if the parse error is [`LexingError`].
	///
	/// [`LexingError`]: ParseError::LexingError
	#[must_use]
	pub fn is_lexing_error(&self) -> bool {
		matches!(self, Self::LexingError { .. })
	}
}

```

`organizer/organize-core\src\parser\lexer.rs`:

```rs
use logos::Logos;
use thiserror::Error;

#[derive(Error, Default, Debug, Clone, PartialEq)]
pub enum LexingError {
	#[error("Invalid identifier: {0}")]
	InvalidIdentifier(String),
	#[default]
	#[error("Unknown lexing error")]
	Other,
}

#[derive(Logos, Debug, PartialEq, Clone)]
#[logos(skip r"[ \t\f\n]+", error = LexingError, extras = (usize, usize))]
pub enum Token<'a> {
	#[token("{{")]
	OpenDelim,
	#[token("}}")]
	CloseDelim,
	#[token(".")]
	Dot,
	#[regex(r"[a-zA-Z0-9_][a-zA-Z0-9_]*")]
	Identifier(&'a str),
	#[regex(".",  |lex| Err(LexingError::InvalidIdentifier(lex.slice().to_string())), priority = 1)]
	InvalidToken(LexingError),
}

#[cfg(test)]
mod tests {
	use super::*; // Import Token and Logos

	fn lex<'a>(input: &'a str) -> Vec<Result<Token<'a>, LexingError>> {
		// A helper function to collect all tokens from the lexer
		Token::lexer(input).collect()
	}

	#[test]
	fn test_simple_variable() {
		let tokens = lex("{{ name }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("name".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_path_expression() {
		let tokens = lex("{{ user.address.city }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("address".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("city".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_invalid_token() {
		// Logos will produce an Error token for characters it doesn't recognize
		// In our current lexer, most symbols would be skipped or cause an error.
		// Let's assume we modify the lexer slightly to capture errors.
		// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ user.name! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("name".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_character_within_expression() {
		// 	// Logos will produce an Error token for characters it doesn't recognize
		// 	// In our current lexer, most symbols would be skipped or cause an error.
		// 	// Let's assume we modify the lexer slightly to capture errors.
		// 	// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ path! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("path".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_start_of_identifier() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ 1st_place }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Err(LexingError::InvalidIdentifier("1".into())),
			Ok(Token::Identifier("st_place".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_multiple_errors() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ user.@email + }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Err(LexingError::InvalidIdentifier("@".into())),
			Ok(Token::Identifier("email".into())),
			Err(LexingError::InvalidIdentifier("+".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_empty_expression() {
		let tokens = lex("{{}}");
		assert_eq!(tokens, vec![Ok(Token::OpenDelim), Ok(Token::CloseDelim)])
	}
}

```

`organizer/organize-core\src\parser\mod.rs`:

```rs
use chumsky::prelude::*;

use crate::parser::{ast::Expression, lexer::Token};

pub mod ast;
pub mod errors;
pub mod lexer;

pub fn parser<'a>() -> impl Parser<'a, &'a [Token<'a>], Expression, extra::Err<Simple<'a, Token<'a>>>> {
	// A parser for a single identifier token
	let ident = select! { Token::Identifier(s) => s.to_string() };

	// A parser for a dot-separated path of one or more identifiers
	let var_path = ident
		.separated_by(just(Token::Dot))
		.at_least(1) // must have at least one part
		.collect::<Vec<String>>()
		.map(|parts| parts);

	var_path.map(Expression::Variable)
}

```

`organizer/organize-core\src\pipeline.rs`:

```rs
use futures::future;

use crate::{
	action::Receipt,
	batch::Batch,
	context::{ExecutionContext, ExecutionScope},
	engine::ExecutionModel,
	errors::Error,
	grouper::Grouper,
	resource::Resource,
	rule::{Rule, Stage},
	sorter::Sorter,
};
use std::sync::Arc;

/// Represents the data flowing through the pipeline.
/// It tracks the current set of file batches and the sequence of
/// groupers that have been applied to create them.
#[derive(Debug)]
pub struct PipelineStream {
	/// The current data, always represented as a list of batches.
	/// An "ungrouped" state is simply a Vec with one Batch.
	pub batches: Vec<Batch>,
	/// The ordered stack of groupers that have been applied.
	pub groupers: Vec<Box<dyn Grouper>>,
	pub sorters: Vec<Box<dyn Sorter>>,
}

impl PipelineStream {
	/// Creates a new stream with a single batch of files and no groupings.
	pub fn new(files: Vec<Arc<Resource>>) -> Self {
		Self {
			batches: vec![Batch::initial(files)],
			groupers: Vec::new(),
			sorters: Vec::new(),
		}
	}

	/// Flattens all batches into a single, unordered list of files.
	pub fn all_files(&self) -> Vec<Arc<Resource>> {
		self.batches.iter().flat_map(|batch| batch.files.clone()).collect()
	}

	pub async fn resort(&mut self) {
		for batch in self.batches.iter_mut() {
			for sorter in &self.sorters {
				sorter.sort(&mut batch.files).await;
			}
		}
	}

	/// Re-applies the entire stack of stored groupers to a new set of files.
	/// This is the key to maintaining a consistent state.
	pub async fn regroup(&self, files: Vec<Arc<Resource>>) -> Result<Vec<Batch>, anyhow::Error> {
		let mut current_batches = vec![Batch::initial(files)];

		for grouper in &self.groupers {
			let mut next_level_batches = Vec::new();
			for batch in current_batches {
				// Apply the grouper to each batch from the previous level
				next_level_batches.extend(grouper.group(&batch).await?);
			}
			current_batches = next_level_batches;
		}
		Ok(current_batches)
	}
}

pub struct Pipeline {
	stages: Vec<Stage>,
	stream: PipelineStream,
}

impl Pipeline {
	pub fn new(rule: Rule) -> Self {
		Self {
			stages: rule.pipeline,
			stream: PipelineStream::new(Vec::new()), // Start with no files
		}
	}

	pub async fn run(mut self, ctx: &ExecutionContext<'_>) -> Result<PipelineStream, Error> {
		for stage in self.stages.into_iter() {
			match stage {
				Stage::Search { location, source } => {
					let scope = ExecutionScope::new_location_scope(source.clone(), &location);
					let ctx = ctx.with_scope(scope);
					let new_files = location.backend.discover(&location, &ctx).await?;
					if location.mode.is_append() {
						let mut all_files = self.stream.all_files();
						all_files.extend(new_files);
						self.stream.batches = self.stream.regroup(all_files).await?;
						self.stream.resort().await;
					} else {
						self.stream = PipelineStream::new(new_files);
					}
				}
				Stage::Grouper { grouper, .. } => {
					let all_files = self.stream.all_files();
					self.stream.groupers.push(grouper);
					self.stream.batches = self.stream.regroup(all_files).await?;
					self.stream.resort().await;
				}
				Stage::Sorter { sorter, .. } => {
					self.stream.sorters.push(sorter);
					self.stream.resort().await;
				}
				Stage::Filter { filter, source } => {
					let mut next_batches = Vec::new();
					match filter.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let passed_files = filter.filter(&batch_ctx).await?;
								if !passed_files.is_empty() {
									next_batches.push(Batch {
										files: passed_files,
										context: batch.context.clone(),
									});
								}
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let filter = filter.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										filter.filter(&ctx).await
									};
									futs.push(fut);
								}
								let results: Vec<Arc<Resource>> = future::try_join_all(futs).await?.into_iter().flatten().collect();
								if !results.is_empty() {
									next_batches.push(Batch {
										files: results,
										context: batch.context.clone(),
									});
								}
							}
						}
					}
					self.stream.batches = next_batches;
				}
				Stage::Action { action, source } => {
					let mut all_next_files = Vec::new();
					match action.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let receipt = action.commit(&batch_ctx).await?;
								all_next_files.extend(receipt.next);
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let action = action.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										action.commit(&ctx).await
									};
									futs.push(fut);
								}
								let receipts: Vec<Receipt> = future::try_join_all(futs).await?;
								for receipt in receipts {
									all_next_files.extend(receipt.next);
								}
							}
						}
					}
					// An action's output always replaces the current data stream and resets grouping.
					self.stream = PipelineStream::new(all_next_files);
				}
				Stage::Flatten { flatten, .. } => {
					if flatten {
						self.stream = PipelineStream::new(self.stream.all_files());
					}
				}
				Stage::Select { selector, .. } => {
					let selection_futures = self.stream.batches.iter().map(|batch| selector.select(batch));
					let selected_batches: Vec<Batch> = future::try_join_all(selection_futures).await?.into_iter().collect();
					self.stream.batches = selected_batches;
				}
			}
		}
		Ok(self.stream)
	}
}

```

`organizer/organize-core\src\resource.rs`:

```rs
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::{
	fmt::{Debug, Display},
	fs::Metadata,
	hash::Hash,
	path::{Path, PathBuf},
	sync::{Arc, OnceLock},
};
use tokio::{fs::File, io::AsyncReadExt};

use crate::{context::ExecutionContext, errors::Error, folder::Location};

#[derive(Debug, Default, Clone)]
pub enum FileState {
	Unknown,
	#[default]
	Exists,
	Deleted,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Resource {
	pub path: PathBuf,
	pub location: Arc<Location>,
	#[serde(skip)]
	mime: OnceLock<String>,
	#[serde(skip)]
	bytes: OnceLock<Vec<u8>>,
	#[serde(skip)]
	hash: OnceLock<String>,
	#[serde(skip)]
	metadata: OnceLock<Metadata>,
}

impl AsRef<Path> for Resource {
	fn as_ref(&self) -> &Path {
		self.path.as_path()
	}
}

impl Display for Resource {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.path.display())
	}
}

impl PartialEq for Resource {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path
	}
}

impl Hash for Resource {
	fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
		self.path.hash(state);
	}
}

impl Eq for Resource {}

impl Resource {
	pub fn as_path(&self) -> &Path {
		self.path.as_path()
	}

	pub fn with_filename(self, filename: &str) -> Self {
		let new_path = self.path.with_file_name(filename);
		self.with_path(new_path)
	}

	pub fn with_path(self, new_path: PathBuf) -> Self {
		Self {
			path: new_path,
			location: self.location, // The origin root folder remains the same.

			// The content, hash, and MIME type of a file do not change when it is moved.
			// We can move these initialized OnceLock fields to the new struct to preserve the cache.
			bytes: self.bytes,
			hash: self.hash,
			mime: self.mime,

			// The filesystem metadata (like modification times of parent dirs) IS different
			// at the new location. We reset this field to force a re-fetch if needed.
			metadata: OnceLock::new(),
		}
	}

	pub fn get_mime(&self) -> &str {
		match self.mime.get() {
			Some(mime) => mime.as_str(),
			None => {
				let mime = mime_guess::from_path(&self.path).first_or_octet_stream().to_string();
				self.mime.set(mime).unwrap();
				self.mime.get().unwrap().as_str()
			}
		}
	}

	pub async fn get_metadata(&self) -> &Metadata {
		match self.metadata.get() {
			Some(metadata) => metadata,
			None => {
				let metadata = tokio::fs::metadata(&self.path).await.unwrap();
				self.metadata.set(metadata).unwrap();
				self.metadata.get().unwrap()
			}
		}
	}

	pub async fn get_bytes(&self) -> &Vec<u8> {
		match self.bytes.get() {
			Some(content) => content,
			None => {
				let content = tokio::fs::read(&self.path).await.unwrap();
				self.bytes.set(content).unwrap();
				self.bytes.get().unwrap()
			}
		}
	}

	pub async fn get_hash(&self) -> &String {
		match self.hash.get() {
			Some(hash) => hash,
			None => {
				let mut file = File::open(&self.path).await.unwrap();
				let mut hasher = Sha256::new();
				let mut buffer = [0; 1024];
				loop {
					let count = file.read(&mut buffer).await.unwrap();
					if count == 0 {
						break;
					}
					hasher.update(&buffer[..count]);
				}
				let hash = hasher.finalize();
				let hash_str = format!("{hash:x}");
				self.hash.set(hash_str).unwrap();
				self.hash.get().unwrap()
			}
		}
	}
}

// impl Serialize for Resource {
// 	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
// 	where
// 		S: Serializer,
// 	{
// 		// Serialize the PathBuf that the Arc points to.
// 		self.path.serialize(serializer)
// 	}
// }
//
impl Resource {
	pub fn new(path: &PathBuf, location: Arc<Location>) -> Self {
		Self {
			path: path.clone(),
			location,
			mime: OnceLock::new(),
			bytes: OnceLock::new(),
			hash: OnceLock::new(),
			metadata: OnceLock::new(),
		}
	}

	pub async fn try_exists(&self, ctx: &ExecutionContext<'_>) -> Result<bool, Error> {
		if ctx.settings.dry_run {
			return match ctx
				.services
				.fs
				.tracked_files
				.get(self.as_path())
				.await
				.unwrap_or(FileState::Unknown)
			{
				FileState::Exists => Ok(true),
				FileState::Deleted => Ok(false),
				FileState::Unknown => Ok(tokio::fs::try_exists(&self.path).await?),
			};
		}

		// Otherwise, check the physical filesystem using the resource's path.
		Ok(tokio::fs::try_exists(&self.path).await?)
	}
}

// #[cfg(test)]
// mod tests {
// 	use super::*;
// 	use std::path::PathBuf;

// 	#[test]
// 	fn new_with_valid_path_succeeds() {
// 		let path = PathBuf::from("/tmp/test.txt");
// 		let root = PathBuf::from("/tmp");
// 		let resource = Resource::new(&path, &root).unwrap();
// 		assert_eq!(resource.path(), &path);
// 		assert_eq!(resource.root(), &root);
// 	}

// 	#[test]
// 	fn new_with_root_path_returns_err() {
// 		let path = PathBuf::from("/");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_dot_path_succeeds_on_windows_fails_on_unix() {
// 		let path = PathBuf::from(".");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_relative_path_succeeds() {
// 		let path = PathBuf::from("some/dir/file.txt");
// 		let result = Resource::new(&path, "some/dir");
// 		assert!(result.is_ok());
// 	}

// 	#[test]
// 	fn new_with_bare_filename_returns_err() {
// 		// A bare filename like "file.txt" has an empty parent, which the new logic correctly rejects.
// 		let path = PathBuf::from("file.txt");
// 		let result = Resource::new(&path, ".");
// 		assert!(result.is_err());
// 	}
// }

```

`organizer/organize-core\src\rule.rs`:

```rs
use std::{path::PathBuf, sync::Arc};

use itertools::Itertools;
use serde::{Deserialize, Deserializer, Serialize};

use crate::{
	action::{Action, ActionBuilder},
	context::ExecutionContext,
	errors::Error,
	filter::Filter,
	folder::{Location, LocationBuilder},
	grouper::Grouper,
	selector::Selector,
	sorter::Sorter,
};

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct RuleMetadata {
	pub name: Option<String>,
	pub description: Option<String>,
	#[serde(default)]
	pub tags: Vec<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct RuleBuilder {
	#[serde(flatten)]
	pub metadata: RuleMetadata,
	#[serde(rename = "stage")]
	pub pipeline: Vec<StageBuilder>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Rule {
	pub metadata: Arc<RuleMetadata>,
	pub pipeline: Vec<Stage>,
}

async fn load_rule_builder_from_path(path: &std::path::Path) -> Result<RuleBuilder, anyhow::Error> {
	let content = tokio::fs::read_to_string(path).await?;
	let builder: RuleBuilder = toml::from_str(&content)?;
	Ok(builder)
}

impl RuleBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Rule, Error> {
		let mut final_pipeline = Vec::new();
		let main_meta = Arc::new(self.metadata);
		let mut processing_stack: Vec<(StageBuilder, Arc<RuleMetadata>)> = self
			.pipeline
			.into_iter()
			.map(|builder| (builder, main_meta.clone()))
			.rev()
			.collect();

		while let Some((builder, meta)) = processing_stack.pop() {
			match builder {
				StageBuilder::Compose(path) => {
					let composed_builder = load_rule_builder_from_path(&path).await?;
					let composed_meta = Arc::new(composed_builder.metadata);
					for stage_builder in composed_builder.pipeline.into_iter().rev() {
						processing_stack.push((stage_builder, composed_meta.clone()));
					}
				}
				// The logic to build the final Stage enum now changes slightly
				other_builder => {
					let stage_enum = other_builder.build(ctx, meta).await?;
					final_pipeline.push(stage_enum);
				}
			}
		}

		Ok(Rule {
			metadata: main_meta.clone(),
			pipeline: final_pipeline,
		})
	}
}

#[derive(Debug, Serialize, PartialEq, Eq, Clone)]
pub enum StageBuilder {
	Search(LocationBuilder),
	Compose(PathBuf),
	Action(Box<dyn ActionBuilder>),
	Filter(Box<dyn Filter>),
	Select(Box<dyn Selector>),
	Grouper(Box<dyn Grouper>),
	Sorter(Box<dyn Sorter>),
	Flatten(bool),
}

impl StageBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>, source: Arc<RuleMetadata>) -> Result<Stage, Error> {
		match self {
			StageBuilder::Search(location_builder) => {
				let stage = location_builder.build(ctx).await.unwrap();
				Ok(Stage::Search { location: stage, source })
			}
			StageBuilder::Flatten(bool) => Ok(Stage::Flatten {
				flatten: bool,
				source,
			}),
			StageBuilder::Action(builder) => {
				let stage = builder.build(ctx).await?;
				Ok(Stage::Action { action: stage, source })
			}
			StageBuilder::Filter(stage) => Ok(Stage::Filter { filter: stage, source }),
			StageBuilder::Grouper(stage) => Ok(Stage::Grouper { grouper: stage, source }),
			StageBuilder::Sorter(stage) => Ok(Stage::Sorter { sorter: stage, source }),
			StageBuilder::Compose(_) => unreachable!("Compose stages should be flattened"),
			StageBuilder::Select(stage) => Stage::Select { selector: stage, source },
		}
	}
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Stage {
	Search {
		location: Location,
		source: Arc<RuleMetadata>,
	},
	Action {
		action: Box<dyn Action>,
		source: Arc<RuleMetadata>,
	},
	Filter {
		filter: Box<dyn Filter>,
		source: Arc<RuleMetadata>,
	},
	Select {
		selector: Box<dyn Selector>,
		source: Arc<RuleMetadata>,
	},
	Flatten {
		flatten: bool,
		source: Arc<RuleMetadata>,
	},
	Grouper {
		grouper: Box<dyn Grouper>,
		source: Arc<RuleMetadata>,
	},
	Sorter {
		sorter: Box<dyn Sorter>,
		source: Arc<RuleMetadata>,
	},
}

// impl<'de> Deserialize<'de> for StageBuilder {
// 	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
// 	where
// 		D: Deserializer<'de>,
// 	{
// 		// Deserialize the TOML [[stage]] table into a generic Value.
// 		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
// 		let table = map
// 			.as_table_mut()
// 			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

// 		// Find the single key that defines the stage type.
// 		let key = {
// 			let keys: Vec<_> = table.keys().cloned().collect();
// 			if keys.len() != 1 {
// 				// This handles the case where a stage has multiple primary keys, like both `filter` and `action`.
// 				// We need to check for this AFTER handling the parameters that live alongside the primary key.
// 				// We will find the primary key first, and then deserialize the rest.
// 			}

// 			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
// 			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
// 				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
// 			})?
// 		};

// 		// The value associated with the primary key.
// 		let value = table
// 			.remove(&key)
// 			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{}'", key)))?;

// 		// The rest of the table contains the parameters.
// 		let params = toml::Value::Table(table.clone());

// 		match key.as_str() {
// 			"search" => {
// 				let path_template = value.try_into::<String>().map_err(serde::de::Error::custom)?;
// 				let mut builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;
// 				builder.path = Template::from_str(&path_template).map_err(serde::de::Error::custom)?; // Set the path from the primary key's value
// 				Ok(StageBuilder::Search(builder))
// 			}
// 			"compose" => {
// 				let rules_to_compose = value.try_into::<Vec<PathBuf>>().map_err(serde::de::Error::custom)?;
// 				Ok(StageBuilder::Compose(rules_to_compose))
// 			}
// 			"filter" | "action" | "group-by" | "sort-by" => {
// 				// This handles all the typetag'd trait objects.
// 				let component_type = value
// 					.as_str()
// 					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{}'", key)))?;

// 				// We inject the `type` field that `typetag` expects into the parameters table.
// 				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
// 				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
// 				let component_value = toml::Value::Table(component_table);

// 				// Now deserialize from this new value into the correct trait object.
// 				match key.as_str() {
// 					"filter" => Ok(StageBuilder::Filter(
// 						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"action" => Ok(StageBuilder::Action(
// 						Box::<dyn Action>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"group-by" => Ok(StageBuilder::Grouper(
// 						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"sort-by" => Ok(StageBuilder::Sorter(
// 						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					_ => unreachable!(),
// 				}
// 			}
// 			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{}'", other))),
// 		}
// 	}
// }

impl<'de> Deserialize<'de> for StageBuilder {
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where
		D: Deserializer<'de>,
	{
		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
		let table = map
			.as_table_mut()
			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

		let key = {
			let keys: Vec<_> = table.keys().cloned().collect();
			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
			})?
		};

		let value = table
			.remove(&key)
			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{key}'")))?;

		let params = toml::Value::Table(table.clone());

		match key.as_str() {
			"search" => {
				let path_template_str = value.try_into::<String>().map_err(serde::de::Error::custom)?;
				let mut params = params.as_table().unwrap().clone();
				params.insert("path".to_string(), path_template_str.into());
				let builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;

				Ok(StageBuilder::Search(builder))
			}
			"compose" => {
				let rule_to_compose = value.try_into::<PathBuf>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Compose(rule_to_compose))
			}
			"flatten" => {
				let value = value.try_into::<bool>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Flatten(value))
			}
			"filter" | "select" | "action" | "group-by" | "sort-by" => {
				let component_type = value
					.as_str()
					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{key}'")))?;

				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
				let component_value = toml::Value::Table(component_table);

				match key.as_str() {
					"filter" => Ok(StageBuilder::Filter(
						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"select" => Ok(StageBuilder::Select(
						Box::<dyn Selector>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"action" => Ok(StageBuilder::Action(
						Box::<dyn ActionBuilder>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"group-by" => Ok(StageBuilder::Grouper(
						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"sort-by" => Ok(StageBuilder::Sorter(
						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					_ => unreachable!(),
				}
			}
			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{other}'"))),
		}
	}
}

```

`organizer/organize-core\src\selector.rs`:

```rs
use crate::{batch::Batch, errors::Error};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Selector);
dyn_eq::eq_trait_object!(Selector);

/// A trait for any component that selects a subset of files from a batch based on
/// positional or quantitative criteria (e.g., first, last, random sample).
#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Selector: DynEq + DynClone + Sync + Send + Debug {
	async fn select(&self, batch: &Batch) -> Result<Batch, Error>;
}

```

`organizer/organize-core\src\sorter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

use crate::resource::Resource;

dyn_clone::clone_trait_object!(Sorter);
dyn_eq::eq_trait_object!(Sorter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Sorter: DynEq + DynClone + Sync + Send + Debug {
	/// Sorts a slice of resources in-place.
	async fn sort(&self, files: &mut [Arc<Resource>]);
}

```

`organizer/organize-core\src\stdx\mod.rs`:

```rs
pub mod path;

```

`organizer/organize-core\src\stdx\path.rs`:

```rs
#[cfg(target_family = "windows")]
use std::path::Path;
use std::{ffi::OsStr, path::PathBuf, sync::Arc};

use async_trait::async_trait;

use crate::{context::ExecutionContext, folder::Location, resource::Resource};

#[async_trait]
pub trait PathExt {
	type HiddenError;
	fn is_hidden(&self) -> Result<bool, Self::HiddenError>;
	fn expand_user(self) -> PathBuf;
	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource>;
}

#[async_trait]
impl<T: AsRef<Path> + Sync + Send> PathExt for T {
	#[cfg(target_family = "unix")]
	type HiddenError = std::convert::Infallible;
	#[cfg(target_family = "windows")]
	type HiddenError = std::io::Error;

	fn expand_user(self) -> PathBuf {
		let path = self.as_ref();
		let mut components = path.components();
		if let Some(component) = components.next() {
			if component.as_os_str() == OsStr::new("~") {
				let mut path = dirs::home_dir().expect("could not find home directory");
				path.extend(components);
				return path;
			}
		}
		path.to_path_buf()
	}

	#[cfg(target_family = "unix")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		match self.file_name() {
			None => Ok(false),
			Some(filename) => Ok(filename.to_string_lossy().starts_with('.')),
		}
	}

	#[cfg(target_family = "windows")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		use std::{fs, os::windows::prelude::*};
		let metadata = fs::metadata(self)?;
		let attributes = metadata.file_attributes();
		Ok((attributes & 0x2) > 0)
	}

	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource> {
		ctx.services
			.fs
			.resources
			.get_with(self.as_ref().to_path_buf(), async move {
				Arc::new(Resource::new(&self.as_ref().to_path_buf(), location))
			})
			.await
	}
}

#[cfg(test)]
mod tests {

	use super::*;

	#[cfg(target_family = "unix")]
	#[test]
	fn check_hidden() {
		use super::*;
		let path = Path::new("/home/user/.testfile");
		assert!(path.is_hidden().unwrap())
	}

	#[cfg(target_family = "windows")]
	#[test]
	fn not_hidden() {
		use tempfile::NamedTempFile;

		use super::*;
		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		assert!(!path.is_hidden().unwrap());
	}

	#[test]
	#[cfg(target_family = "windows")]
	fn check_hidden() {
		use super::*;
		use tempfile::NamedTempFile;

		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		// Use the `attrib` command on Windows to set the hidden attribute.
		let status = std::process::Command::new("attrib")
			.arg("+h")
			.arg(path.as_os_str())
			.status()
			.expect("failed to execute attrib command");
		assert!(status.success(), "attrib command failed");
		assert!(path.is_hidden().unwrap());
	}

	#[test]
	fn invalid_tilde() {
		let original = dirs::home_dir().unwrap().join("Documents~");
		assert_eq!(original.clone().expand_user(), original)
	}

	#[test]
	fn user_tilde() {
		let original = "~/Documents";
		let expected = dirs::home_dir().unwrap().join("Documents");
		assert_eq!(original.expand_user(), expected)
	}
}

```

`organizer/organize-core\src\storage.rs`:

```rs
use crate::{context::ExecutionContext, errors::Error, folder::Location, resource::Resource};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{
	fmt::Debug,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

dyn_clone::clone_trait_object!(StorageProvider);
dyn_eq::eq_trait_object!(StorageProvider);

#[async_trait]
#[typetag::serde(tag = "provider")]
/// A trait for any component that can provide a list of files to be processed.
/// This could be a local folder, an S3 bucket, an SFTP connection, etc.
pub trait StorageProvider: DynEq + DynClone + Sync + Send + Debug {
	fn home(&self) -> Result<PathBuf, Error>;
	fn prefix(&self) -> &'static str;
	async fn metadata(&self, path: &Path) -> Result<Metadata, Error>;
	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error>;
	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error>;
	async fn write(&self, path: &Path, content: &[u8]) -> Result<()>;
	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error>;
	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn delete(&self, path: &Path) -> Result<(), Error>;
	async fn download(&self, from: &Path) -> Result<PathBuf, Error>;
	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
}

```

`organizer/organize-core\src\templates\accessor.rs`:

```rs
use crate::{context::ExecutionContext, templates::value::Value};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Accessor);
dyn_eq::eq_trait_object!(Accessor);

/// Represents a compiled and type-safe property path.
///
/// An Accessor is a function object that encapsulates the logic to retrieve a
/// specific value from a given execution context. This is the output of the
/// template compilation process.
#[async_trait]
pub trait Accessor: DynEq + DynClone + Sync + Send + Debug {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value>;
}

```

`organizer/organize-core\src\templates\compiler.rs`:

```rs
use crate::{
	errors::Error,
	parser::ast::{Expression, Segment, AST},
	templates::{
		accessor::Accessor,
		registry::SchemaRegistry,
		template::{Template, TemplatePart},
	},
};
use anyhow::Result;

/// The central compiler for the template system.
/// It uses a SchemaRegistry to validate variables and a full parser to build the template.
#[derive(Debug, Clone)]
pub struct TemplateCompiler {
	schema: SchemaRegistry,
}

impl Default for TemplateCompiler {
	fn default() -> Self {
		Self::new()
	}
}

impl TemplateCompiler {
	/// Creates a new compiler with a default schema registry that discovers
	/// all registered static variable providers.
	pub fn new() -> Self {
		Self {
			schema: SchemaRegistry::new(),
		}
	}

	/// Creates a compiler from a fully-built schema (e.g., one that includes
	/// user-defined variables from a config file).
	pub fn from_schema(schema: SchemaRegistry) -> Self {
		Self { schema }
	}

	/// Compiles a raw string into an executable Template object using your parser.
	pub fn compile_template(&self, raw_template: &str) -> Result<Template, Error> {
		// Stage 1: Parse the raw string into an Abstract Syntax Tree (AST)
		// using your provided `AST::parse` method.
		let ast = AST::parse(raw_template)?;
		let mut parts = Vec::new();

		// Stage 2: Walk the AST to build the final, executable Template object.
		for segment in ast.segments {
			match segment {
				Segment::Literal(text) => {
					parts.push(TemplatePart::Static(text));
				}
				Segment::Expression(expr) => {
					let accessor = self.build_accessor(expr)?;
					parts.push(TemplatePart::Dynamic(accessor));
				}
			}
		}

		Ok(Template {
			parts,
			text: raw_template.to_string(),
		})
	}

	/// Builds a type-safe accessor from a parsed expression AST node.
	/// This is the bridge between your parser and the execution engine.
	fn build_accessor(&self, expr: Expression) -> Result<Box<dyn Accessor>, Error> {
		match expr {
			Expression::Variable(parts) => {
				// We use the existing SchemaRegistry to validate the path and get the accessor.
				let parts_str: Vec<&str> = parts.iter().map(AsRef::as_ref).collect();
				self.schema.parse_property_chain(&parts_str)
			}
		}
	}
}

```

`organizer/organize-core\src\templates\engine.rs`:

```rs
use std::env::VarError;

use thiserror::Error;


#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Templater;

#[derive(Error, Debug)]
pub enum TemplateError {
	#[error("variable '{variable}' (fields={fields:?}) cannot be resolved.")]
	UndefinedVariable {
		variable: String,
		fields: Vec<String>,
		#[source]
		source: VarError,
	},

	#[error("empty template")]
	EmptyTemplate,

	#[error("variable '{variable}' could not be deserialized. It may be missing fields or they may be wrong.")]
	DeserializationError {
		#[source]
		source: serde_json::Error,
		variable: String,
		fields: Vec<String>,
	},

	#[error("variable {variable} does not accept any fields, but received {fields:?}")]
	FieldsNotSupported { variable: String, fields: Vec<String> },

	#[error("invalid variable ({variable}): it requires {missing_piece} to be in scope")]
	InvalidContext { missing_piece: String, variable: String },

	#[error("variable '{variable}' does not support a '{field}' subfield")]
	InvalidField { variable: String, field: String },

	#[error("variable '{variable}' requires a field (one of: {fields})")]
	MissingField { variable: String, fields: String },

	#[error("unknown variable '{{{{ {0} }}}}'")]
	UnknownVariable(String),

	#[error("variable '{variable}' requires one of the following fields: {fields:?}")]
	RequiredField { variable: String, fields: Vec<String> },
}

// #[cfg(test)]
// mod tests {
// 	use std::convert::{TryFrom, TryInto};

// 	use super::*;
// 	use crate::{config::{context::RunServices, variables::simple::SimpleVariable}, resource::Resource};

// 	#[test]
// 	fn render_template_not_present_in_engine() {
// 		let engine = Templater::default();
// 		let template = Template::try_from("Hello, {{ name }}!").unwrap();
// 		let context = Context::new(ctx)
// 		let mut context = engine.context().build(&engine);
// 		context.insert("name", "Andrés");
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}

// 	#[test]
// 	fn render_template_present_in_engine() {
// 		let mut engine = Templater::default();
// 		let template = Template::try_from("This is a stored template.").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("This is a stored template.".to_string()));
// 	}

// 	#[test]
// 	fn render_with_simple_variable() {
// 		let var = SimpleVariable {
// 			name: "location".into(),
// 			value: "world".try_into().unwrap(),
// 		};
// 		let mut engine = Templater::new(&vec![Box::new(var)]);
// 		let template = Template::try_from("Hello, {{ location }}!").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("Hello, world!".to_string()));
// 	}

// 	#[test]
// 	fn render_with_path_context() {
// 		let mut engine = Templater::default();
// 		let resource = Resource::new_tmp("test.txt");
// 		let template = Template::try_from("The path is {{ path | stem }}").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().path(resource.path().to_path_buf()).build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("The path is test".to_string()));
// 	}

// 	#[test]
// 	fn render_invalid_template_returns_none() {
// 		let engine = Templater::default();
// 		// Invalid syntax: `{%` instead of `{{`
// 		let template = Template::try_from("Hello, {% name }}!").unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}
// }

```

`organizer/organize-core\src\templates\mod.rs`:

```rs
pub mod accessor;
pub mod compiler;
pub mod engine;
pub mod filter;
pub mod registry;
pub mod schema;
pub mod template;
pub mod value;
pub mod variable;

```

`organizer/organize-core\src\templates\registry.rs`:

```rs
use std::collections::HashMap;

use crate::{
	errors::Error,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		variable::VariableInventory,
	},
};

/// The central schema registry and compiler for template variables.
///
/// It discovers all variable providers at startup and uses their schemas
/// to parse and validate property chains.
#[derive(Clone, Debug)]
pub struct SchemaRegistry {
	/// A map of all discovered static schemas for fast lookups by name.
	root_properties: HashMap<&'static str, Property>,
}

impl Default for SchemaRegistry {
	fn default() -> Self {
		Self::new()
	}
}

impl SchemaRegistry {
	/// Creates a new registry by discovering all registered `Variable` providers
	/// via the `inventory` crate.
	pub fn new() -> Self {
		let root_properties = inventory::iter::<VariableInventory>
			.into_iter()
			.map(|inv| {
				let schema = inv.provider.schema();
				// The key is the static name of the variable (e.g., "file").
				(schema.name, schema)
			})
			.collect();

		Self { root_properties }
	}

	/// Parses a property chain against the compiled schema to get an Accessor.
	pub fn parse_property_chain(&self, parts: &[&str]) -> Result<Box<dyn Accessor>, Error> {
		if parts.is_empty() {
			return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(
				"Property chain cannot be empty.".to_string(),
			)));
		}

		let root_part = parts[0];
		let mut current_prop = self.root_properties.get(root_part).ok_or_else(|| {
			let valid_options: Vec<_> = self.root_properties.keys().collect();
			Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Invalid root variable '{root_part}'. Valid options are: {valid_options:?}"
			)))
		})?;

		// Traverse the rest of the chain.
		for (i, &part) in parts.iter().skip(1).enumerate() {
			match &current_prop.node {
				SchemaNode::Object(properties) => {
					current_prop = properties.iter().find(|p| p.name == part).ok_or_else(|| {
						let valid_options: Vec<_> = properties.iter().map(|p| p.name).collect();
						Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Invalid property '{}' at index {}. Valid options for '{}' are: {:?}",
							part,
							i + 1,
							parts[..i + 1].join("."),
							valid_options
						)))
					})?;
				}
				SchemaNode::DynamicMap(constructor) => {
					if i + 2 < parts.len() {
						return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Cannot access properties on a dynamic value. Chain has too many parts after key '{}' in '{}'.",
							part,
							parts.join(".")
						))));
					}
					// The chain ends here. Call the constructor with the key.
					return Ok(constructor(part));
				}
				SchemaNode::Terminal(_) => {
					return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
						"Cannot access property '{}' on a terminal value at '{}'.",
						part,
						parts[..i + 1].join(".")
					))));
				}
			}
		}

		// After the loop, the final node must be a Terminal.
		match &current_prop.node {
			SchemaNode::Terminal(constructor) => Ok(constructor()),
			_ => Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Incomplete property chain '{}'. It points to an object, not a final value.",
				parts.join(".")
			)))),
		}
	}
}

```

`organizer/organize-core\src\templates\schema.rs`:

```rs
use crate::templates::accessor::Accessor;
use std::{fmt::Debug, sync::Arc};

#[derive(Clone)]
pub enum SchemaNode {
	/// A terminal node that creates a specific, type-safe Accessor.
	Terminal(Arc<dyn Fn() -> Box<dyn Accessor> + Send + Sync>),
	/// An object node with a fixed, known set of sub-properties.
	Object(Vec<Property>),
	/// A map node where sub-properties are dynamic keys.
	DynamicMap(Arc<dyn Fn(&str) -> Box<dyn Accessor> + Send + Sync>),
}

#[derive(Clone)]
pub struct Property {
	pub name: &'static str,
	pub node: SchemaNode,
}

impl Debug for SchemaNode {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			SchemaNode::Terminal(_) => f.debug_tuple("Terminal").field(&"<closure>").finish(),
			SchemaNode::Object(properties) => f.debug_tuple("Object").field(properties).finish(),
			SchemaNode::DynamicMap(_) => f.debug_tuple("DynamicMap").field(&"<closure>").finish(),
		}
	}
}

// Manual `Debug` implementation for `Property`
impl Debug for Property {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("Property")
			.field("name", &self.name)
			.field("node", &self.node)
			.finish()
	}
}

```

`organizer/organize-core\src\templates\template.rs`:

```rs
use serde::{Deserialize, Serialize};

use crate::{context::ExecutionContext, errors::Error, templates::accessor::Accessor};

#[derive(Debug, Eq, PartialEq, Clone)]
pub enum TemplatePart {
	Static(String),
	Dynamic(Box<dyn Accessor>),
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct TemplateString(pub String);

impl std::ops::Deref for TemplateString {
	type Target = String;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]
pub struct Template {
	pub text: String,
	#[serde(skip)]
	pub parts: Vec<TemplatePart>,
}

impl Template {
	pub async fn render(&self, ctx: &ExecutionContext<'_>) -> Result<String, Error> {
		let mut output = String::new();
		for part in &self.parts {
			match part {
				TemplatePart::Static(s) => output.push_str(s),
				TemplatePart::Dynamic(accessor) => {
					let value = accessor.get(ctx).await?;
					output.push_str(&value.to_string());
				}
			}
		}
		Ok(output)
	}
}

```

`organizer/organize-core\src\templates\value.rs`:

```rs
use std::fmt;

/// Represents any possible value that can be retrieved from a template variable.
/// This enum provides type safety for the data flowing through the template engine.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
	String(String),
	OptionString(Option<String>),
	// Add other types as needed, e.g., Int(i64), Bool(bool)
	Null,
}

impl fmt::Display for Value {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			Value::String(s) => write!(f, "{s}"),
			Value::OptionString(Some(s)) => write!(f, "{s}"),
			Value::OptionString(None) | Value::Null => Ok(()), // Render None/Null as empty string
		}
	}
}

```

`organizer/organize-core\src\templates\variable.rs`:

```rs
use crate::templates::schema::Property;

/// The plugin interface for a static variable provider.
///
/// Any struct implementing this trait can be automatically discovered and
/// integrated into the template engine's schema. This trait is intended for
/// built-in variables with fixed schemas, like `file` or `env`.
pub trait StatelessVariable: Sync + Send {
	/// Returns the canonical name of the root variable (e.g., "file", "env").
	fn name(&self) -> &'static str;

	/// Returns the schema for this variable, defining its properties and accessors.
	fn schema(&self) -> Property;
}

/// The collectible struct for the `inventory` crate.
/// It holds a static reference to an object that implements our `Variable` trait.
pub struct VariableInventory {
	pub provider: &'static (dyn StatelessVariable + Sync),
}

// Declare the global collection for automatic registration of static variable providers.
inventory::collect!(VariableInventory);

```

`organizer/organize-core\src\utils\backup.rs`:

```rs
use std::path::PathBuf;

use crate::{context::ExecutionContext, errors::Error};
use anyhow::Result;
use dirs;
use serde::{Deserialize, Serialize}; // Import the dirs crate
use tokio::fs;
use uuid::Uuid; // Import Uuid for generating unique IDs // Import chrono for timestamps (already in Cargo.toml)

/// Determines the base directory for all backups.
/// This will be inside the platform-specific local data directory,
/// in a subdirectory named after the project, and then a "backups" folder.
fn get_backup_base_dir(ctx: &ExecutionContext<'_>) -> Result<PathBuf, Error> {
	let project_name = env!("CARGO_PKG_NAME");
	let base_dir = dirs::data_local_dir().expect("Could not determine platform-specific local data directory for backups.");
	let dir = base_dir.join(project_name).join("backups");
	Ok(dir)
}

#[derive(Default, Clone, Deserialize, Serialize, PartialEq, Eq, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BackupLocation {
	#[default]
	System,
	Root,
	Custom(PathBuf),
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Backup(pub PathBuf);

impl std::ops::Deref for Backup {
	type Target = PathBuf;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

impl Backup {
	pub async fn new(ctx: &ExecutionContext<'_>) -> Result<Self, Error> {
		let dir = get_backup_base_dir(ctx)?;

		// Loop until a unique UUID is found for the backup filename
		let path = loop {
			let new_uuid = Uuid::new_v4().to_string();
			let proposed_path = dir.join(&new_uuid);

			if !tokio::fs::try_exists(&proposed_path).await? {
				break proposed_path;
			}
		};
		Ok(Self(path))
	}

	pub async fn persist(&self, ctx: &ExecutionContext<'_>) -> Result<(), Error> {
		let parent = self.0.parent().unwrap();
		fs::create_dir_all(parent).await?;
		let source = ctx.scope.resource()?;

		match fs::hard_link(source.as_path(), self.0.as_path()).await {
			Ok(()) => {
				tracing::debug!("Created hard link backup for {}", source.as_path().display());
				Ok(())
			}
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				tracing::warn!(
					"Backup for {} is on a different filesystem. Falling back to a full copy.",
					ctx.scope.resource()?.as_path().display()
				);
				fs::copy(ctx.scope.resource()?.as_path(), self.0.as_path()).await?;
				Ok(())
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\utils\mod.rs`:

```rs
pub mod backup;

```

`organizer/rules\test.rule.toml`:

```toml
[[stage]]
search = '/Users/cabero/Downloads/'
max_depth = 1

[[stage]]
action = "echo"
message = "{{ env.HOME }}"

```

`organizer/rustfmt.toml`:

```toml
unstable_features = true
imports_layout = "HorizontalVertical"
merge_imports = true
max_width = 150
chain_width = 80
overflow_delimited_expr = true
reorder_impl_items = true
reorder_imports = true
reorder_modules = true
condense_wildcard_suffixes = true
format_strings = true
hard_tabs = true
merge_derives = true
normalize_comments = true

```
```

`organizer/organize-cli\Cargo.toml`:

```toml
[package]
name = "organize-cli"
version = "0.1.0"
edition = "2024"

[[bin]]
name = "organize"
path = "src/main.rs"

[dependencies]
async-trait = "0.1.88"
tokio = { version = "1.45.1", features = ["full"] }
organize-core = { path = "../organize-core" }
lazy_static = "1.5.0"
chrono = "0.4.41"
anyhow.workspace = true
clap.workspace = true
colored = "3.0.0"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = "0.3.19"
dialoguer.workspace = true
notify = "8.0.0"


```

`organizer/organize-cli\src\cmd\edit.rs`:

```rs
use std::{
	env,
	path::Path,
	process::{self, ExitStatus},
};

use anyhow::{Context, Result};
use async_trait::async_trait;
use clap::Parser;
use organize_core::config::Config;

use crate::cmd::Cmd;

#[derive(Parser, Debug)]
pub struct Edit;

#[async_trait]
impl Cmd for Edit {
	async fn run(self) -> Result<()> {
		Self::edit(Config::resolve_path(None)).map(|_| ())
	}
}

impl Edit {
	pub(crate) fn edit<T: AsRef<Path>>(path: T) -> Result<ExitStatus> {
		env::var("EDITOR").map(|editor| {
			process::Command::new(&editor)
				.arg(path.as_ref())
				.spawn()
				.context(editor)?
				.wait()
				.context("command wasn't running")
		})?
	}
}

```

`organizer/organize-cli\src\cmd\logs.rs`:

```rs
use chrono::Local;
use clap::ValueEnum;
use std::path::PathBuf;
use tracing::Level;
use tracing_appender::non_blocking::WorkerGuard; // Import the guard type
use tracing_subscriber::{
	Layer,
	filter::LevelFilter,
	fmt::{self},
	layer::SubscriberExt,
	util::SubscriberInitExt,
};

#[derive(ValueEnum, Clone, Debug, Default)]
pub enum LogLevel {
	#[default]
	Info,
	Debug,
	Trace,
	Warn,
	Error,
}

// Implement a conversion from our CLI enum to the `tracing` LevelFilter.
impl From<LogLevel> for Level {
	fn from(level: LogLevel) -> Self {
		match level {
			LogLevel::Info => Level::INFO,
			LogLevel::Debug => Level::DEBUG,
			LogLevel::Trace => Level::TRACE,
			LogLevel::Warn => Level::WARN,
			LogLevel::Error => Level::ERROR,
		}
	}
}

/// Initializes the logging system and returns a guard that must be kept in scope.
pub fn init(level: LogLevel) -> WorkerGuard {
	// 1. Determine the destination directory for logs.
	let logs_dir = PathBuf::from(".").join("logs"); // A hidden folder is a common convention

	// 2. Create a non-blocking file appender for the current run.
	// We add milliseconds to the timestamp to increase uniqueness.
	let timestamp = Local::now().format("%Y-%m-%d-%H-%M-%S%.3f");
	let log_file = format!("{timestamp}.log");
	let file_appender = tracing_appender::rolling::never(&logs_dir, log_file);
	let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);

	// 3. Define the two logging layers.
	let file_layer = fmt::layer()
		.with_writer(non_blocking_writer)
		.with_ansi(false)
		.pretty()
		.with_filter(LevelFilter::TRACE);

	let stdout_layer = fmt::layer()
		.with_writer(std::io::stdout)
		.with_filter(LevelFilter::from_level(level.into()));

	// 4. Combine the layers and initialize the global subscriber.
	tracing_subscriber::registry().with(file_layer).with(stdout_layer).init();

	tracing::debug!("Logging initialized. Log file in: {}", logs_dir.display());

	// 5. Return the guard to the caller.
	guard
}

```

`organizer/organize-cli\src\cmd\mod.rs`:

```rs
use crate::cmd::{logs::LogLevel, run::Run};
use async_trait::async_trait;
use clap::{Parser, Subcommand};
use undo::Undo;

mod logs;
mod run;
mod undo;

#[derive(Subcommand)]
enum Command {
	Run(Run),
	Undo(Undo),
}

#[derive(Parser)]
#[command(about, author, version)]
pub struct App {
	#[command(subcommand)]
	command: Command,
	#[arg(long, value_enum, global = true, default_value_t = LogLevel::Info)]
	pub log_level: LogLevel,
}

#[async_trait]
pub trait Cmd {
	async fn run(self) -> anyhow::Result<()>;
}

#[async_trait]
impl Cmd for App {
	async fn run(self) -> anyhow::Result<()> {
		let _guard = logs::init(self.log_level);
		match self.command {
			Command::Run(cmd) => cmd.run().await,
			Command::Undo(undo) => undo.run().await,
		}
	}
}

```

`organizer/organize-cli\src\cmd\run.rs`:

```rs
use std::path::PathBuf;

use anyhow::Result;
use async_trait::async_trait;
use clap::{ArgAction, Parser, ValueHint};
use organize_core::{context::RunSettings, engine::Engine};

use crate::Cmd;

#[derive(Parser, Default, Debug)]
pub struct Run {
	#[arg(long, short = 'r', value_hint = ValueHint::FilePath)]
	rule: PathBuf,
	#[arg(long, default_value_t = false)]
	no_dry_run: bool,
}

#[async_trait]
impl Cmd for Run {
	async fn run(mut self) -> Result<()> {
		let settings = RunSettings { dry_run: !self.no_dry_run };
		println!("{:?}", &settings);
		let engine = Engine::new(&self.rule, settings).await?;
		engine.run().await?;

		Ok(())
	}
}

```

`organizer/organize-cli\src\cmd\undo.rs`:

```rs
use std::error::Error;

use anyhow::{Result, anyhow};
use async_trait::async_trait;
use clap::Parser;
use organize_core::{
	action::{Input, UndoConflict, UndoError, UndoSettings},
	context::{RunSettings, services::history::Journal},
};

use super::Cmd;

#[derive(Parser, Debug)]
#[command(author, version, about)]
pub struct Undo {
	/// The ID of the session to undo.
	#[arg(long, conflicts_with = "last_session")]
	session_id: Option<i64>,

	/// Use the most recent session.
	#[arg(long, default_value_t = true)]
	last_session: bool,

	// If there is a name collision conflict while undoing, ask me what to do
	#[arg(long, short = 'i', conflicts_with_all = &["on_conflict"])]
	interactive: bool,

	#[arg(long, value_enum, default_value_t = UndoConflict::Abort)]
	on_conflict: UndoConflict,
}

#[async_trait]
impl Cmd for Undo {
	async fn run(self) -> Result<()> {
		let settings = RunSettings { dry_run: false };
		let journal = Journal::new(&settings).await?; // Assumes a simple ::new()

		let settings = UndoSettings {
			interactive: self.interactive,
			on_conflict: self.on_conflict,
		};
		let target_id = if self.last_session {
			journal
				.get_last_session_id()
				.await?
				.ok_or_else(|| anyhow!("No sessions found in the journal."))?
		} else {
			self.session_id.unwrap()
		};

		let transactions = journal.get_pending_transactions_for_session(target_id).await?;

		if transactions.is_empty() {
			println!("No pending operations to undo for session {target_id}.");
			return Ok(());
		}

		for transaction in &transactions {
			for undo_op in &transaction.receipt.undo {
				if undo_op.verify().await.is_ok() {
					match undo_op.undo(&settings).await {
						Ok(_) => {
							journal.update_transaction_undo_status(transaction.id, "DONE").await?;
							tracing::info!("Transaction {} undone.", transaction.id);
						}
						Err(e) => {
							if let Some(source) = e.source().and_then(|s| s.downcast_ref::<UndoError>())
								&& matches!(source, UndoError::Abort)
							{
								let inputs = transaction
									.receipt
									.inputs
									.iter()
									.map(|input: &Input| match input {
										Input::Processed(resource) => resource.as_path().to_string_lossy().to_string(),
										Input::Skipped(resource) => resource.as_path().to_string_lossy().to_string(),
									})
									.collect::<Vec<String>>()
									.join("\n -");

								eprintln!(
									"There was a conflict undoing transaction {}.\nOne of the following files may already exist: \n - {}\nAborting \
									 undo process. Run in interactive mode or choose a default conflict resolution strategy. You can also move the \
									 file manually.",
									transaction.id, inputs
								);
								return Ok(());
							}

							eprintln!("Failed to undo transaction {}: {}", transaction.id, e);
							return Err(e.into());
						}
					}
				}
			}
		}

		Ok(())
	}
}

```

`organizer/organize-cli\src\main.rs`:

```rs
use crate::cmd::{App, Cmd};
use anyhow::Result;
use clap::Parser;
mod cmd;

#[tokio::main]
async fn main() -> Result<()> {
	let app: App = App::parse();
	app.run().await
}

```

`organizer/organize-core\Cargo.toml`:

```toml
[package]
name = "organize-core"
version.workspace = true
authors.workspace = true
edition.workspace = true
description.workspace = true
repository.workspace = true

[dependencies]
ariadne = "0.5.1"
chumsky = "0.10.1"
logos = "0.15.0"
anyhow.workspace = true
async-trait = "0.1.88"
clap.workspace = true
config.workspace = true
dashmap = "6.1.0"
dialoguer.workspace = true
dirs.workspace = true
dotenvy = "0.15.7"
dyn-clone.workspace = true
dyn-eq.workspace = true
itertools.workspace = true
moka = { version = "0.12.10", features = ["future"] }
path-clean.workspace = true
serde.workspace = true
serde_json = "1.0.140"
serde_yaml = "0.9.34"
sqlx = { version = "0.8.6", features = ["chrono", "runtime-tokio", "sqlite"] }
strum.workspace = true
thiserror = "2.0.12"
typetag.workspace = true
dotenvy_macro = "0.15.7"
tokio = { version = "1.45.1", features = ["full"] }
libc = "0.2.174"
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
tracing-appender = "0.2.3"
futures = "0.3.31"
walkdir = "2.5.0"
tempfile = "3.20.0"
sha2 = "0.10.9"
uuid = "1.17.0"
mime_guess = "2.0.5"
sysinfo = "0.35.2"
notify = "8.0.0"
url = "2.5.4"
toml = "0.8.23"
inventory = "0.3.20"
rand = "0.9.1"

```

`organizer/organize-core\migrations\20250623125855_initial_schema.sql`:

```sql
CREATE TABLE IF NOT EXISTS sessions (
    id              INTEGER PRIMARY KEY,
    start_time      INTEGER NOT NULL,
    end_time        INTEGER,
    status          TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS transactions (
    id              INTEGER PRIMARY KEY,
    session_id      INTEGER NOT NULL,
    type               TEXT NOT NULL,
    action             TEXT NOT NULL,
    receipt            TEXT NOT NULL, 
    timestamp       INTEGER NOT NULL,
    undo_status TEXT NOT NULL DEFAULT "PENDING",
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);


```

`organizer/organize-core\src\action.rs`:

```rs
use async_trait::async_trait;
use clap::ValueEnum;
use dialoguer::{theme::ColorfulTheme, Input as RenameInput, Select};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ffi::OsStr, fmt::Debug, path::Path, sync::Arc};
use strum::{Display, EnumIter, IntoEnumIterator};

use anyhow::Result;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::path::PathBuf;
use thiserror::Error;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource, utils::backup::Backup};

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Input {
	Processed(Arc<Resource>),
	Skipped(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Display)]
#[serde(rename_all = "lowercase")]
pub enum Output {
	Created(Arc<Resource>),
	Deleted(Arc<Resource>),
	Modified(Arc<Resource>),
}

#[derive(Debug, Serialize, Deserialize, Clone, Default)]
pub struct Receipt {
	pub inputs: Vec<Input>,
	pub outputs: Vec<Output>,
	pub next: Vec<Arc<Resource>>,
	pub undo: Vec<Box<dyn Undo>>,
	pub metadata: HashMap<String, serde_json::Value>,
}

impl From<String> for Receipt {
	fn from(value: String) -> Self {
		serde_json::from_str(&value).expect("Could not convert string to Receipt object")
	}
}

dyn_clone::clone_trait_object!(Undo);
dyn_eq::eq_trait_object!(Undo);

#[derive(Debug, Error)]
pub enum UndoError {
	#[error("Path '{0}' does not exist, but is required for the undo operation.")]
	PathNotFound(PathBuf),

	#[error("Path '{0}' already exists. The undo operation would overwrite it.")]
	PathAlreadyExists(PathBuf),

	#[error("Backup file is missing for path '{0}'. Cannot restore.")]
	BackupMissing(PathBuf),

	#[error("Parent directory '{0}' for the restore path does not exist.")]
	ParentDirectoryNotFound(PathBuf),

	#[error("Any error")]
	Anyhow(#[from] anyhow::Error),

	#[error("IO error")]
	IO(#[from] std::io::Error),

	#[error("Undo aborted by the user")]
	Abort,
}

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Undo: Debug + DynEq + DynClone + Send + Sync {
	async fn undo(&self, settings: &UndoSettings) -> Result<(), Error>;

	fn backup(&self) -> Option<&Backup> {
		None
	}

	async fn verify(&self) -> Result<(), Error>;
}

pub struct UndoSettings {
	pub interactive: bool,
	pub on_conflict: UndoConflict,
}

#[derive(Clone, Debug, ValueEnum, EnumIter, Display)]
#[strum(serialize_all = "snake_case")]
pub enum UndoConflict {
	Skip,
	Abort,
	Overwrite,
	AutoRename,
	Rename,
}

async fn suggest_new_path(resource: Resource) -> Result<Resource> {
	let parent = resource.as_path().parent().unwrap_or_else(|| Path::new(""));
	let stem = resource.as_path().file_stem().unwrap_or_else(|| OsStr::new("file"));
	let extension = resource.as_path().extension().unwrap_or_else(|| OsStr::new(""));

	let mut count = 1;
	loop {
		// 2. Construct the new filename purely from strings and path components.
		let new_filename_str = format!("{} ({}).{}", stem.to_string_lossy(), count, extension.to_string_lossy());

		// 3. Create a new PathBuf to check for existence. This does not touch the original `resource`.
		let new_path = parent.join(&new_filename_str);

		if !tokio::fs::try_exists(&new_path).await? {
			// 4. Once a valid path is found, consume the original `resource` exactly once
			//    to create the final, evolved struct and return it. The loop is guaranteed to terminate here.
			return Ok(resource.with_path(new_path));
		}
		count += 1;
	}
}

impl UndoConflict {
	/// This new method encapsulates all the conflict handling logic.
	/// It takes a mutable reference to the destination to allow the Rename variant to change it.
	pub async fn resolve(resource: Resource) -> Result<Option<Resource>, UndoError> {
		let choices: Vec<Self> = Self::iter().collect();
		let strategy: &UndoConflict = Select::with_theme(&ColorfulTheme::default())
			.with_prompt(format!("Destination '{}' already exists.", resource.path.display()))
			.items(&choices)
			.interact()
			.map(|choice| &choices[choice])
			.expect("Unknown option");
		strategy.handle(resource).await
	}

	pub async fn handle(&self, resource: Resource) -> Result<Option<Resource>, UndoError> {
		match self {
			UndoConflict::Overwrite => {
				// The logic for overwriting the destination file.
				if resource.as_path().is_file() {
					tokio::fs::remove_file(resource.as_path()).await?;
				} else {
					tokio::fs::remove_dir_all(resource.as_path()).await?;
				}
				Ok(Some(resource))
			}
			UndoConflict::Rename => {
				// The logic for prompting the user and renaming the destination.
				let theme = ColorfulTheme::default();
				let input = RenameInput::<String>::with_theme(&theme)
					.with_prompt("Enter a new name for the destination")
					.with_initial_text(format!("{}", resource.as_path().file_name().unwrap_or_default().display()))
					.interact_text()
					.map(PathBuf::from)?;
				let new = resource.with_path(input);
				Ok(Some(new))
			}
			UndoConflict::Skip => Ok(None),
			UndoConflict::Abort => Err(UndoError::Abort),
			UndoConflict::AutoRename => Ok(Some(suggest_new_path(resource).await?)),
		}
	}
}

dyn_clone::clone_trait_object!(ActionBuilder);
dyn_eq::eq_trait_object!(ActionBuilder);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait ActionBuilder: DynEq + DynClone + Sync + Send + Debug {
	async fn build(&self, _ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error>;
}

dyn_clone::clone_trait_object!(Action);
dyn_eq::eq_trait_object!(Action);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Action: DynEq + DynClone + Sync + Send + Debug {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::default()
	}
	async fn commit(&self, _ctx: &ExecutionContext<'_>) -> Result<Receipt, Error>;
}

```

`organizer/organize-core\src\batch.rs`:

```rs
use std::{collections::HashMap, sync::Arc};

use crate::resource::Resource;

/// Represents a batch of files that have been grouped by one or more criteria.
/// This is the primary data structure that flows between pipeline stages.
#[derive(Debug, Clone)]
pub struct Batch {
	pub files: Vec<Arc<Resource>>,
	pub context: HashMap<String, String>,
}

impl Batch {
	pub fn new() -> Self {
		Self {
			files: Vec::new(),
			context: HashMap::new(),
		}
	}

	pub fn initial(files: Vec<Arc<Resource>>) -> Self {
		Self {
			files,
			context: HashMap::new(),
		}
	}
}

impl Default for Batch {
	fn default() -> Self {
		Self::new()
	}
}

```

`organizer/organize-core\src\builtins\actions\echo.rs`:

```rs
use crate::{
	action::{Action, ActionBuilder, Receipt},
	common::enabled,
	context::ExecutionContext,
	errors::Error,
	templates::template::{Template, TemplateString},
};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

use anyhow::Result;

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct EchoBuilder {
	pub message: TemplateString,
	#[serde(default = "enabled")]
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl ActionBuilder for EchoBuilder {
	async fn build(&self, ctx: &ExecutionContext<'_>) -> Result<Box<dyn Action>, Error> {
		let message = ctx.services.compiler.compile_template(&self.message)?;
		Ok(Box::new(Echo {
			message,
			enabled: self.enabled,
		}))
	}
}

#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]
pub struct Echo {
	pub message: Template,
	pub enabled: bool,
}

#[async_trait]
#[typetag::serde(name = "echo")]
impl Action for Echo {
	async fn commit(&self, ctx: &ExecutionContext<'_>) -> Result<Receipt, Error> {
		if self.enabled {
			self.message
				.render(ctx)
				.await
				.inspect(|message| tracing::info!("{}", message))?;
		}
		Ok(Receipt {
			next: vec![ctx.scope.resource()?],
			..Default::default()
		})
	}
}

```

`organizer/organize-core\src\builtins\actions\mod.rs`:

```rs
pub mod echo;
// pub mod r#move;

```

`organizer/organize-core\src\builtins\mod.rs`:

```rs
pub mod actions;
pub mod selectors;
pub mod sorters;
pub mod storage;
pub mod variables;

```

`organizer/organize-core\src\builtins\selectors\first.rs`:

```rs
use crate::{
    batch::Batch,
    errors::Error,
    selector::Selector,
};
use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FirstSelector {
    pub n: usize,
}

#[async_trait]
#[typetag::serde(name = "first")]
impl Selector for FirstSelector {
    async fn select(&self, batch: &Batch) -> Result<Batch, Error> {
        let mut selected_batch = Batch::new();
        selected_batch.files = batch.files.iter().take(self.n).cloned().collect();
        // The context from the original batch is not preserved by default,
        // as it might not be relevant to the new, smaller batch.
        Ok(selected_batch)
    }
}

```

`organizer/organize-core\src\builtins\selectors\mod.rs`:

```rs
pub mod first;

```

`organizer/organize-core\src\builtins\sorters\mod.rs`:

```rs
pub mod random;

```

`organizer/organize-core\src\builtins\sorters\random.rs`:

```rs
use crate::{resource::Resource, sorter::Sorter};
use async_trait::async_trait;
use rand::{rng, seq::SliceRandom};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub struct RandomSorter;

#[async_trait]
#[typetag::serde(name = "random")]
impl Sorter for RandomSorter {
	async fn sort(&self, files: &mut [Arc<Resource>]) {
		let mut rng = rng();
		files.shuffle(&mut rng);
	}
}

```

`organizer/organize-core\src\builtins\variables\env.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

// This accessor is created dynamically. It stores the environment
// variable key that it needs to look up.
#[derive(Debug, Clone, PartialEq, Eq)]
struct EnvAccessor {
	key: String,
}

#[async_trait]
impl Accessor for EnvAccessor {
	async fn get(&self, _ctx: &ExecutionContext) -> Result<Value> {
		let value = std::env::var(&self.key).unwrap_or("<UNDEFINED>".to_string());
		Ok(Value::String(value))
	}
}

/// The provider for the `{{ env }}` variable.
#[derive(Debug, Clone)]
pub struct EnvProvider;

impl StatelessVariable for EnvProvider {
	fn name(&self) -> &'static str {
		"env"
	}

	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			// This node indicates that `env` is a map with dynamic keys.
			node: SchemaNode::DynamicMap(Arc::new(|key: &str| {
				// The constructor captures the key from the property chain
				// (e.g., "HOME") and creates an EnvAccessor for it.
				Box::new(EnvAccessor { key: key.to_string() })
			})),
		}
	}
}

// Automatically register the `EnvProvider` with the global inventory.
static ENV_PROVIDER: EnvProvider = EnvProvider;
inventory::submit!(VariableInventory { provider: &ENV_PROVIDER });

```

`organizer/organize-core\src\builtins\variables\file.rs`:

```rs
use std::sync::Arc;

use crate::{
	context::ExecutionContext,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		value::Value,
		variable::{StatelessVariable, VariableInventory},
	},
};
use anyhow::Result;
use async_trait::async_trait;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FileProvider;

#[derive(Debug, Clone, PartialEq, Eq)]
struct Path;

#[async_trait]
impl Accessor for Path {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let path_str = resource.path.to_string_lossy().to_string();
		Ok(Value::String(path_str))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Name;

#[async_trait]
impl Accessor for Name {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_name().map(|name| name.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Stem;

#[async_trait]
impl Accessor for Stem {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.file_stem().map(|stem| stem.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Extension;

#[async_trait]
impl Accessor for Extension {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value> {
		let resource = ctx.scope.resource()?;
		let value = resource.path.extension().map(|ext| ext.to_string_lossy().to_string());
		Ok(Value::OptionString(value))
	}
}

// SCHEMA AND REGISTRATION

impl StatelessVariable for FileProvider {
	fn name(&self) -> &'static str {
		"file"
	}

	/// Defines the schema for the `file` variable.
	fn schema(&self) -> Property {
		Property {
			name: self.name(), // Use the canonical name from the trait method.
			node: SchemaNode::Object(vec![
				Property {
					name: "path",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Path))),
				},
				Property {
					name: "name",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Name))),
				},
				Property {
					name: "stem",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Stem))),
				},
				Property {
					name: "extension",
					node: SchemaNode::Terminal(Arc::new(|| Box::new(Extension))),
				},
			]),
		}
	}
}

inventory::submit! {
	VariableInventory {
		provider: &FileProvider
	}
}

```

`organizer/organize-core\src\builtins\variables\mod.rs`:

```rs
pub mod env;
pub mod file;

```

`organizer/organize-core\src\common\mod.rs`:

```rs
pub fn enabled() -> bool {
	true
}

```

`organizer/organize-core\src\config.rs`:

```rs



// #[cfg(test)]
// mod tests {
// 	use std::sync::LazyLock;

// 	use super::ConfigBuilder;
// 	use itertools::Itertools;
// 	use toml::toml;

// 	static TOML: LazyLock<toml::Table> = LazyLock::new(|| {
// 		toml! {

// 				[[rules]]
// 				id = "test-rule-1"
// 				tags = ["tag1"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-2"
// 				tags = ["tag2"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				id = "test-rule-3"
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				tags = ["tag3"]

// 				actions = []
// 				filters = []
// 				folders = []

// 				[[rules]]
// 				actions = []
// 				filters = []
// 				folders = []

// 		}
// 	});

// 	static CONFIG: LazyLock<ConfigBuilder> = LazyLock::new(|| toml::from_str(&TOML.to_string()).unwrap());

// 	#[test]
// 	fn filter_rules_by_tag_positive() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["tag2"]).iter().map(|&r| r.clone()).collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_negative() {
// 		let found_rules = CONFIG.filter_rules_by_tag(["!tag2"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap(), CONFIG.rules.get(3).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["!tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(2..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_tag_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_tag(["tag2", "!tag1"])
// 			.iter()
// 			.copied()
// 			.cloned()
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=3).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_positive() {
// 		let found_rules = CONFIG.filter_rules_by_id(["test-rule-1"]).iter().copied().collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1"])
// 			.iter()
// 			.map(|r| (*r).clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(1..=2).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_positive() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "test-rule-2"])
// 			.iter()
// 			.map(|&r| r.clone())
// 			.collect_vec();
// 		let expected_rules = CONFIG.rules.get(0..=1).unwrap();
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_negative() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["!test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// 	#[test]
// 	fn filter_rules_by_id_multiple_mixed() {
// 		let found_rules = CONFIG
// 			.filter_rules_by_id(["test-rule-1", "!test-rule-2"])
// 			.iter()
// 			.copied()
// 			.collect_vec();
// 		let expected_rules = vec![CONFIG.rules.first().unwrap(), CONFIG.rules.get(2).unwrap()];
// 		assert_eq!(found_rules, expected_rules)
// 	}
// }

```

`organizer/organize-core\src\context\mod.rs`:

```rs
use anyhow::Result;
use dashmap::DashMap;
use std::{
	any::Any,
	path::{Path, PathBuf},
	sync::Arc,
};

pub mod services;

use crate::{
	batch::Batch,
	context::services::{fs::manager::FileSystemManager, history::Journal},
	errors::Error,
	folder::Location,
	resource::Resource,
	rule::RuleMetadata,
	templates::compiler::TemplateCompiler,
};

#[derive(Debug, Clone)]
pub struct RunServices {
	pub blackboard: Blackboard,
	pub fs: FileSystemManager,
	pub journal: Arc<Journal>,
	pub compiler: TemplateCompiler,
}

#[derive(Debug, Clone)]
pub struct Blackboard {
	pub scratchpad: Arc<DashMap<String, Box<dyn Any + Send + Sync>>>,
	pub shared_context: Arc<DashMap<String, String>>,
}

impl Default for Blackboard {
	fn default() -> Self {
		Self {
			scratchpad: Arc::new(DashMap::new()),
			shared_context: Arc::new(DashMap::new()),
		}
	}
}

/// A container for run-wide operational settings.
#[derive(Debug, Clone, Copy)]
pub struct RunSettings {
	pub dry_run: bool,
}

/// A read-only "view" into the current position in the configuration tree.
// #[derive(Debug, Clone)]
// pub struct ExecutionScope<'a> {
// 	pub config: &'a Config,
// 	pub rule: Option<&'a Rule>,
// 	pub folder: Option<&'a Folder>,
// 	pub resource: Option<Arc<Resource>>,
// 	pub resources: Option<Vec<Arc<Resource>>>,
// }

#[derive(Debug, Clone)]
pub enum ExecutionScope<'a> {
	Rule(RuleScope),
	Search(SearchScope<'a>),
	Resource(ResourceScope),
	Batch(BatchScope<'a>),
	Build(BuildScope),
	Blank,
}

impl<'a> ExecutionScope<'a> {
	pub fn new_rule_scope(rule: Arc<RuleMetadata>) -> ExecutionScope<'a> {
		ExecutionScope::Rule(RuleScope { rule })
	}

	pub fn new_location_scope(rule: Arc<RuleMetadata>, location: &'a Location) -> ExecutionScope<'a> {
		ExecutionScope::Search(SearchScope { rule, location })
	}

	pub fn new_resource_scope(rule: Arc<RuleMetadata>, resource: Arc<Resource>) -> ExecutionScope<'a> {
		ExecutionScope::Resource(ResourceScope { rule, resource })
	}

	pub fn new_batch_scope(rule: Arc<RuleMetadata>, batch: &'a Batch) -> ExecutionScope<'a> {
		ExecutionScope::Batch(BatchScope { rule, batch })
	}

	pub fn new_build_scope(root: &Path) -> ExecutionScope<'a> {
		ExecutionScope::Build(BuildScope { root: root.to_path_buf() })
	}

	pub fn rule(&self) -> Result<Arc<RuleMetadata>, Error> {
		match self {
			ExecutionScope::Rule(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Batch(scope) => Ok(scope.rule.clone()),
			ExecutionScope::Search(scope) => Ok(scope.rule.clone()),
			_ => Err(Error::OutOfScope("rule".into())),
		}
	}

	pub fn resource(&self) -> Result<Arc<Resource>, Error> {
		match self {
			ExecutionScope::Resource(scope) => Ok(scope.resource.clone()),
			_ => Err(Error::OutOfScope("resource".into())),
		}
	}

	pub fn batch(&self) -> Result<&'a Batch, Error> {
		match self {
			ExecutionScope::Batch(scope) => Ok(scope.batch),
			_ => Err(Error::OutOfScope("batch".into())),
		}
	}

	pub fn root(&self) -> Result<PathBuf, Error> {
		match self {
			ExecutionScope::Search(scope) => Ok(scope.location.path.clone()),
			ExecutionScope::Resource(scope) => Ok(scope.resource.location.path.clone()),
			ExecutionScope::Build(path) => Ok(path.root.clone()), // <-- ADD THIS CASE
			_ => Err(Error::OutOfScope("root".into())),
		}
	}
}

#[derive(Debug, Clone)]
pub struct RuleScope {
	pub rule: Arc<RuleMetadata>,
}
#[derive(Debug, Clone)]
pub struct SearchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub location: &'a Location,
}
#[derive(Debug, Clone)]
pub struct ResourceScope {
	pub rule: Arc<RuleMetadata>,
	pub resource: Arc<Resource>,
}
#[derive(Debug, Clone)]
pub struct BatchScope<'a> {
	pub rule: Arc<RuleMetadata>,
	pub batch: &'a Batch,
}

#[derive(Debug, Clone)]
pub struct BuildScope {
	pub root: PathBuf,
}

/// The top-level context object, composed of the three distinct categories of information.
#[derive(Clone, Debug)]
pub struct ExecutionContext<'a> {
	pub services: &'a RunServices,
	pub scope: ExecutionScope<'a>,
	pub settings: &'a RunSettings,
}

impl<'a> ExecutionContext<'a> {
	pub fn with_scope(&'a self, scope: ExecutionScope<'a>) -> ExecutionContext<'a> {
		Self {
			services: self.services,
			scope,
			settings: self.settings,
		}
	}
}

// #[cfg(test)]
// pub struct ContextHarness {
// 	pub services: RunServices,
// 	pub settings: RunSettings,
// 	pub config: Config,
// 	pub rule: Rule,
// 	pub folder: Folder,
// 	pub resource: Resource,
// 	pub resources: Vec<Resource>,
// }

// #[cfg(test)]
// impl<'a> ContextHarness {
// 	/// Creates a new harness with default, dummy data.
// 	pub fn new(resource: Resource, resources: Vec<Resource>) -> Self {
// 		Self {
// 			services: RunServices::default(),
// 			config: Config::default(),
// 			settings: RunSettings {
// 				dry_run: true,
// 				no_parallel: true,
// 			},
// 			rule: Rule::default(),
// 			folder: Folder::default(),
// 			resource,
// 			resources,
// 		}
// 	}

// 	/// Returns a valid `ExecutionContext` with references to the harness's data.
// 	pub fn context(&'a self) -> ExecutionContext<'a> {
// 		let scope = ExecutionScope {
// 			config: &self.config,
// 			rule: &self.rule,
// 			folder: &self.folder,
// 			resource: &self.resource,
// 			resources: &self.resources,
// 		};
// 		ExecutionContext {
// 			services: &self.services,
// 			settings: &self.settings,
// 			scope,
// 		}
// 	}
// }
// Provide `Default` implementations for the final, compiled structs.
// These are only compiled for tests and allow for easy instantiation of dummy objects.

```

`organizer/organize-core\src\context\services\fs\locker.rs`:

```rs
use crate::{
	context::{services::fs::manager::Destination, ExecutionContext},
	engine::ConflictResolution,
	errors::Error,
};
use anyhow::Result;
use dashmap::DashSet;
use std::{future::Future, path::PathBuf, sync::Arc};

#[derive(Debug, Clone, Default)]
pub struct Locker {
	active_paths: Arc<DashSet<PathBuf>>,
}

impl Locker {
	pub async fn with_locked_destination<F, Fut, T>(
		&self,
		ctx: &ExecutionContext<'_>,
		destination: &Destination,
		strategy: &ConflictResolution,
		action: F,
	) -> Result<Option<T>, Error>
	where
		F: FnOnce(PathBuf) -> Fut,
		Fut: Future<Output = Result<T, Error>>,
	{
		let mut path = destination.resolve(ctx).await?;
		let mut n = 1;

		let reserved = loop {
			if self.active_paths.contains(&path) {
				match strategy {
					ConflictResolution::Skip | ConflictResolution::Overwrite => return Ok(None),
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			let exists = if let Some(res) = ctx.services.fs.resources.get(&path).await {
				res.try_exists(ctx).await?
			} else {
				tokio::fs::try_exists(&path).await?
			};

			if exists {
				match strategy {
					ConflictResolution::Skip => return Ok(None),
					ConflictResolution::Overwrite => {
						if !self.active_paths.insert(path.to_path_buf()) {
							return Ok(None);
						}
						break Some(path);
					}
					ConflictResolution::Rename => {
						let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or_default();
						let ext = path.extension().and_then(|s| s.to_str()).unwrap_or_default();
						let new_name = if ext.is_empty() {
							format!("{stem} ({n})")
						} else {
							format!("{stem} ({n}).{ext}")
						};
						path = path.with_file_name(new_name);
						n += 1;
						continue;
					}
				}
			}

			if !self.active_paths.insert(path.to_path_buf()) {
				continue;
			}
			break Some(path);
		};

		if let Some(target) = reserved {
			ctx.services.fs.ensure_parent_dir_exists(&target).await?;
			let result = action(target.clone()).await?;

			self.active_paths.remove(&target.to_path_buf());

			Ok(Some(result))
		} else {
			Ok(None)
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\manager.rs`:

```rs
use crate::{
	context::{services::fs::locker::Locker, ExecutionContext},
	errors::Error,
	folder::LocalFileSystem,
	resource::{FileState, Resource},
	storage::StorageProvider,
	templates::template::{Template, TemplateString},
};
use anyhow::Result;
use moka::future::Cache;
use serde::{Deserialize, Serialize};
use std::{
	collections::HashMap,
	iter::FromIterator,
	path::{Path, PathBuf},
	sync::Arc,
};
use url::Url; // Assuming this is needed for dry_run and context

#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub struct DestinationBuilder {
	pub folder: TemplateString,
	pub filename: Option<TemplateString>,
}
impl DestinationBuilder {
	/// Compiles the raw DestinationBuilder into an executable Destination.
	pub fn build(self, ctx: &ExecutionContext<'_>) -> Result<Destination, Error> {
		let folder = ctx.services.compiler.compile_template(&self.folder)?;
		let filename = self.filename.map(|f| ctx.services.compiler.compile_template(&f)).transpose()?; // This elegantly handles the Option<Result<T, E>>
		Ok(Destination { folder, filename })
	}
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Destination {
	pub folder: Template,
	pub filename: Option<Template>,
}

impl Destination {
	pub async fn resolve(&self, ctx: &ExecutionContext<'_>) -> Result<PathBuf> {
		let mut folder = PathBuf::from(self.folder.render(ctx).await?);
		if let Some(filename_template) = &self.filename {
			let filename = filename_template.render(ctx).await?;
			folder.push(filename);
		}
		// A placeholder for the original filename if `filename` is not provided.
		// This would need access to the resource from the context.
		else if let Ok(resource) = ctx.scope.resource() {
			if let Some(name) = resource.path.file_name() {
				folder.push(name);
			}
		}
		Ok(folder)
	}
}

#[derive(Debug, Clone)]
pub struct FileSystemManager {
	pub locker: Locker,
	pub resources: Cache<PathBuf, Arc<Resource>>,
	pub tracked_files: Cache<PathBuf, FileState>,
	pub backends: HashMap<String, Arc<dyn StorageProvider>>,
}

pub fn parse_uri(uri_str: &str) -> anyhow::Result<(String, String)> {
	// For local paths, we must construct a valid file URI first.
	if !uri_str.contains("://") {
		// let path = PathBuf::from(uri_str).clean();
		// dbg!(&path);
		// This will correctly handle paths on both Windows and Unix.
		// let url = Url::from_file_path(path).map_err(|_| anyhow::anyhow!("Invalid local path"))?;
		// Return "local" as the host (backend) and the original path.
		return Ok(("local".to_string(), uri_str.to_string()));
	}

	let url = Url::parse(uri_str)?;
	let host = url
		.host_str()
		.ok_or_else(|| anyhow::anyhow!("URI is missing a host (connection name)"))?;
	let path = url.path().to_string();

	Ok((host.to_string(), path))
}

impl Default for FileSystemManager {
	fn default() -> Self {
		Self::new()
	}
}

impl FileSystemManager {
	pub fn new() -> Self {
		let local: Arc<dyn StorageProvider> = Arc::new(LocalFileSystem);
		let backends = HashMap::from_iter(vec![("local".to_string(), local)]);
		Self {
			locker: Locker::default(),
			resources: Cache::new(10_000),
			tracked_files: Cache::new(10_000),
			backends,
		}
	}

	pub async fn ensure_parent_dir_exists(&self, path: &Path) -> std::io::Result<()> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		// resources: CacheBuilder::new(1_000_000)
		// 	.time_to_live(Duration::new(60 * 60 * 24, 0)) // ONE DAY
		// 	.name("cached_resources")
		// 	.build(),
		Ok(())
	}

	pub async fn r#move(&self, source: Arc<Resource>, destination: Arc<Resource>) -> Result<(), Error> {
		// Attempt a direct rename first
		self.ensure_parent_dir_exists(destination.as_path()).await?;
		match tokio::fs::rename(source.as_path(), destination.as_path()).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					source.as_path().display(),
					destination.as_path().display()
				);

				// Perform copy
				tokio::fs::copy(source.as_path(), destination.as_path()).await?;

				// If copy is successful, delete the original
				Ok(tokio::fs::remove_file(source.as_path()).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\context\services\fs\mod.rs`:

```rs
pub mod locker;
pub mod manager;

```

`organizer/organize-core\src\context\services\history\mod.rs`:

```rs
use crate::{
	action::{Action, Receipt},
	context::RunSettings,
};
use anyhow::Result;
use sqlx::{sqlite::SqlitePoolOptions, SqlitePool};
use std::time::{SystemTime, UNIX_EPOCH};

/// The Journal service, responsible for all database interactions.
#[derive(Debug, Clone)]
pub struct Journal {
	pool: SqlitePool,
}

#[derive(Debug)]
pub struct Transaction {
	pub id: i64,
	pub receipt: Receipt,
}

impl Journal {
	/// Creates a new Journal instance, connects to the database, and runs migrations.
	pub async fn new(settings: &RunSettings) -> Result<Self> {
		let db_url = if settings.dry_run {
			// For a dry run, use a temporary, private in-memory SQLite database.
			"sqlite::memory:".to_string()
		} else {
			// For a real run, use the persistent database file specified in .env.
			dotenvy::dotenv().ok();
			std::env::var("DATABASE_URL").expect("DATABASE_URL must be set for real runs")
		};

		let pool = SqlitePoolOptions::new().max_connections(5).connect(&db_url).await?;
		sqlx::migrate!("./migrations").run(&pool).await?;

		Ok(Self { pool })
	}

	pub async fn start_session(&self) -> Result<i64> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;

		let record = sqlx::query!(
			r#"
            INSERT INTO sessions (start_time, status)
            VALUES (?1, 'running')
            "#,
			now,
		)
		.execute(&self.pool)
		.await?;

		Ok(record.last_insert_rowid())
	}

	#[allow(clippy::borrowed_box)]
	pub async fn record_transaction(&self, session_id: i64, action: &Box<dyn Action>, receipt: &Receipt) -> Result<()> {
		if receipt.undo.is_empty() {
			return Ok(());
		}

		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		let action_type = action.typetag_name();

		let action_data = serde_json::to_string(action)?;
		let receipt_data = serde_json::to_string(receipt)?;

		sqlx::query!(
			r#"
            INSERT INTO transactions (session_id, type, action, receipt, timestamp)
            VALUES (?1, ?2, ?3, ?4, ?5)
            "#,
			session_id,
			action_type,
			action_data,
			receipt_data,
			now
		)
		.execute(&self.pool)
		.await?;

		Ok(())
	}

	pub async fn get_pending_transactions_for_session(&self, session_id: i64) -> Result<Vec<Transaction>> {
		let transactions = sqlx::query_as!(
			Transaction,
			"SELECT id, receipt FROM transactions WHERE session_id = ? AND undo_status = 'PENDING' ORDER BY timestamp DESC",
			session_id
		)
		.fetch_all(&self.pool)
		.await?;

		Ok(transactions)
	}

	pub async fn update_transaction_undo_status(&self, transaction_id: i64, status: &str) -> Result<()> {
		sqlx::query!("UPDATE transactions SET undo_status = ? WHERE id = ?", status, transaction_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	/// Marks a session as completed with a final status.
	pub async fn end_session(&self, session_id: i64, status: &str) -> Result<()> {
		let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as i64;
		sqlx::query!("UPDATE sessions SET end_time = ?1, status = ?2 WHERE id = ?3", now, status, session_id)
			.execute(&self.pool)
			.await?;
		Ok(())
	}

	pub async fn get_last_session_id(&self) -> Result<Option<i64>> {
		let result = sqlx::query!("SELECT id FROM sessions ORDER BY start_time DESC LIMIT 1")
			.fetch_optional(&self.pool)
			.await?;
		Ok(result.map(|row| row.id))
	}
}

```

`organizer/organize-core\src\context\services\mod.rs`:

```rs
pub mod fs;
pub mod history;

```

`organizer/organize-core\src\engine.rs`:

```rs
use crate::{
	context::{
		services::{fs::manager::FileSystemManager, history::Journal},
		Blackboard,
		ExecutionContext,
		ExecutionScope,
		RunServices,
		RunSettings,
	},
	pipeline::Pipeline,
	rule::{Rule, RuleBuilder},
	templates::compiler::TemplateCompiler,
};
use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::{path::PathBuf, sync::Arc};
use strum::Display;

#[derive(Default)]
pub enum ExecutionModel {
	#[default]
	Single,
	Batch,
}

#[derive(Eq, Display, PartialEq, Default, Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all(serialize = "lowercase", deserialize = "lowercase"))]
#[strum(serialize_all = "snake_case")]
pub enum ConflictResolution {
	Overwrite,
	#[default]
	Skip,
	Rename,
}

/// The main engine for the application.
/// It owns the compiled configuration and all run-wide services.
pub struct Engine {
	rule: Rule,
	services: RunServices,
	settings: RunSettings,
}

impl Engine {
	pub async fn new(path: &PathBuf, settings: RunSettings) -> Result<Arc<Self>> {
		let services = RunServices {
			blackboard: Blackboard::default(),
			journal: Arc::new(Journal::new(&settings).await?),
			fs: FileSystemManager::new(),
			compiler: TemplateCompiler::new(),
		};
		let content = tokio::fs::read_to_string(path).await?;
		let rule = {
			let builder: RuleBuilder = toml::from_str(&content)?;
			let ctx = ExecutionContext {
				services: &services,
				scope: ExecutionScope::Blank,
				settings: &settings,
			};
			let rule = builder.build(&ctx).await?;
			rule
		};

		Ok(Arc::new(Self { rule, services, settings }))
	}

	pub async fn run(&self) -> Result<()> {
		let pipeline = Pipeline::new(self.rule.clone());

		// Create the top-level execution context with a blank scope.
		let ctx = ExecutionContext {
			services: &self.services,
			settings: &self.settings, // Assuming you have settings
			scope: ExecutionScope::Blank,
		};

		let _final_stream = pipeline.run(&ctx).await?;
		Ok(())
	}
}

```

`organizer/organize-core\src\errors.rs`:

```rs
use std::path::PathBuf;
use thiserror::Error;

use crate::{action::UndoError, parser::errors::ParseError, templates::engine::TemplateError};

/// The primary error type for all actions within the application.
#[derive(Error, Debug)]
pub enum Error {
	#[error("Error converting to value")]
	Json(#[from] serde_json::Error),

	#[error(transparent)]
	Io(#[from] std::io::Error),

	#[error(transparent)]
	Other(#[from] anyhow::Error),

	#[error("Could not create backup for: {path:?}")]
	Backup {
		#[source]
		source: std::io::Error,
		path: PathBuf,
	},

	#[error(transparent)]
	ParseError(#[from] ParseError),

	#[error("Error in prompt")]
	Interaction {
		#[source]
		source: std::io::Error,
		prompt: String,
	},

	#[error(transparent)]
	TemplateError(#[from] TemplateError),

	#[error("Tried to retrieve `{0}` from the scope but it is not defined")]
	OutOfScope(String),

	#[error(transparent)]
	UndoError(#[from] UndoError),
}

```

`organizer/organize-core\src\filter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

// pub mod content;
// pub mod empty;
// pub mod extension;
// pub mod filename;
// pub mod mime;
// pub mod regex;

use crate::{context::ExecutionContext, engine::ExecutionModel, errors::Error, resource::Resource};

dyn_clone::clone_trait_object!(Filter);
dyn_eq::eq_trait_object!(Filter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Filter: DynClone + DynEq + Debug + Send + Sync {
	fn execution_model(&self) -> ExecutionModel {
		ExecutionModel::Single
	}

	/// Takes the execution context, which contains the appropriate scope,
	/// and returns a Result containing the list of files that passed.
	async fn filter(&self, ctx: &ExecutionContext) -> Result<Vec<Arc<Resource>>, Error>;
}

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct Not(Box<dyn Filter>);

// impl std::ops::Deref for Not {
// 	type Target = Box<dyn Filter>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "not")]
// impl Filter for Not {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		!self.filter(ctx).await
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AnyOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AnyOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "any_of")]
// impl Filter for AnyOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().any(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct AllOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for AllOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "all_of")]
// impl Filter for AllOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		results.iter().all(|&result| result)
// 	}
// }

// #[derive(Eq, PartialEq, Deserialize, Serialize, Debug, Clone)]
// struct NoneOf(Vec<Box<dyn Filter>>);

// impl std::ops::Deref for NoneOf {
// 	type Target = Vec<Box<dyn Filter>>;

// 	fn deref(&self) -> &Self::Target {
// 		&self.0
// 	}
// }

// #[async_trait]
// #[typetag::serde(name = "none_of")]
// impl Filter for NoneOf {
// 	async fn filter(&self, ctx: &ExecutionContext) -> bool {
// 		let filter_futures = self.iter().map(|f| f.filter(ctx));
// 		let results: Vec<bool> = future::join_all(filter_futures).await;
// 		!results.iter().any(|&result| result)
// 	}
// }

```

`organizer/organize-core\src\folder.rs`:

```rs
use std::{
	collections::HashSet,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

use anyhow::{Context as ErrorContext, Result};
use async_trait::async_trait;
use futures::{stream, StreamExt};
use serde::{Deserialize, Serialize};

use crate::{
	context::{services::fs::manager::parse_uri, ExecutionContext, ExecutionScope},
	errors::Error,
	options::OptionsBuilder,
	resource::Resource,
	stdx::path::PathExt,
	storage::StorageProvider,
	templates::template::TemplateString,
};

use super::options::{Options, Target};

#[derive(Debug, Serialize, PartialEq, Eq, Clone, Deserialize)]
pub struct LocationBuilder {
	pub path: TemplateString,
	#[serde(flatten)]
	pub options: OptionsBuilder,
	#[serde(default)]
	pub mode: SearchMode,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Location {
	pub path: PathBuf,
	pub options: Options,
	pub mode: SearchMode,
	pub backend: Arc<dyn StorageProvider>,
}

impl PartialEq for Location {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path && self.options == other.options && self.mode == other.mode
	}
}

impl Eq for Location {}

impl LocationBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Location, Error> {
		let path_template = ctx.services.compiler.compile_template(&self.path)?;
		let uri = path_template.render(ctx).await?;
		let (host, path) = parse_uri(&uri)?;
		let path = PathBuf::from(path);

		let ctx = &ExecutionContext {
			services: ctx.services,
			scope: ExecutionScope::new_build_scope(&path),
			settings: ctx.settings,
		};

		Ok(Location {
			path,
			options: self.options.compile(ctx).await?,
			mode: self.mode,
			backend: ctx.services.fs.backends.get(&host).unwrap().clone(), // The direct Arc clone to the provider
		})
	}
}
/// The final, compiled `Folder` object, ready for execution.

#[derive(Debug, Deserialize, Serialize, Default, PartialEq, Eq, Clone)]
#[serde(rename_all = "lowercase")]
pub enum SearchMode {
	Replace,
	#[default]
	Append,
}

impl SearchMode {
	/// Returns `true` if the search mode is [`Replace`].
	///
	/// [`Replace`]: SearchMode::Replace
	#[must_use]
	pub fn is_replace(&self) -> bool {
		matches!(self, Self::Replace)
	}

	/// Returns `true` if the search mode is [`Append`].
	///
	/// [`Append`]: SearchMode::Append
	#[must_use]
	pub fn is_append(&self) -> bool {
		matches!(self, Self::Append)
	}
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct LocalFileSystem;

#[async_trait]
#[typetag::serde(name = "local")]
impl StorageProvider for LocalFileSystem {
	fn prefix(&self) -> &'static str {
		"file"
	}

	fn home(&self) -> Result<PathBuf, Error> {
		Ok(dirs::home_dir().context("unable to find home directory")?)
	}

	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		if let Some(parent) = path.parent() {
			if !tokio::fs::try_exists(parent).await.unwrap_or(false) {
				tokio::fs::create_dir_all(parent).await?;
			}
		}
		Ok(())
	}

	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		// ctx.services.fs.ensure_parent_dir_exists(destination.as_path()).await?;
		self.mkdir(to, ctx).await?;
		match tokio::fs::rename(from, to).await {
			Ok(_) => Ok(()),
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				// Handle "Cross-device link" error (EXDEV on Unix, specific error kind on Windows)
				// This means source and destination are on different file systems.
				tracing::warn!(
					"Attempting copy-then-delete for move operation due to cross-device link: {} to {}",
					from.display(),
					to.display()
				);

				tokio::fs::copy(from, to).await?;
				Ok(tokio::fs::remove_file(from).await?)
			}
			Err(e) => Err(Error::Io(e)),
		}
	}

	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn delete(&self, path: &Path) -> Result<(), Error> {
		todo!()
	}

	async fn download(&self, from: &Path) -> Result<PathBuf, Error> {
		Ok(PathBuf::new())
	}

	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		Ok(())
	}

	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error> {
		todo!()
	}

	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error> {
		let concurrency_limit = 50;
		let home = self.home()?;
		let min_depth = {
			let base = if location.path == home {
				1.0 as usize
			} else {
				location.options.min_depth
			};
			(base as f64).max(1.0) as usize
		};

		let max_depth = if location.path == home {
			1.0 as usize
		} else {
			location.options.max_depth
		};

		let mut collected_paths = Vec::new();
		let mut dirs_to_visit: Vec<(PathBuf, usize)> = vec![];

		let excluded_paths_set: HashSet<&PathBuf> = location.options.exclude.iter().collect();

		if excluded_paths_set.contains(&location.path) {
			tracing::warn!(
				"Start directory '{}' is in the excluded paths. Aborting search.",
				&location.path.display()
			);
			return Ok(Vec::new());
		}

		if min_depth == 0 {
			collected_paths.push(location.path.clone());
		}

		dirs_to_visit.push((location.path.clone(), 0));

		while let Some((current_dir, current_depth)) = dirs_to_visit.pop() {
			if current_depth >= max_depth {
				continue;
			}

			let mut entries = match tokio::fs::read_dir(&current_dir).await {
				Ok(e) => e,
				Err(e) => {
					eprintln!("Warning: Could not read directory {}: {}", current_dir.display(), e);
					continue;
				}
			};

			while let Some(entry) = entries.next_entry().await? {
				let path = entry.path();
				let next_depth = current_depth + 1;

				// --- Exclusion Logic for encountered paths (files or directories) ---
				if excluded_paths_set.contains(&path) {
					eprintln!("Excluding path: {}", path.display());
					// If it's a directory, we effectively prune the branch.
					// If it's a file, we just don't collect it.
					continue;
				}
				// --- End Exclusion Logic ---

				// Only add &location.path if it's within the specified depth range
				if next_depth >= min_depth && next_depth <= max_depth {
					collected_paths.push(path.clone());
				}

				// If it's a directory and still within max_depth, add it to dirs_to_visit
				// (after checking for exclusion, which is done above)
				if path.is_dir() && next_depth < max_depth {
					dirs_to_visit.push((path, next_depth));
				}
			}
		}

		// let all_files = self.find_all_files(min_depth, max_depth, ctx).await?;
		let location: Arc<Location> = Arc::new(location.clone());
		let resource_creation_futures = collected_paths
			.into_iter()
			.filter(|e| self.filter_entries(e, &location.options))
			.map(|e| {
				// Capture `e` by moving it into the async block
				// Capture `ctx` by reference (or clone/Arc if its lifetime is an issue)
				let ctx_ref = ctx;
				let location = location.clone();
				async move {
					e.as_resource(ctx_ref, location).await // Returns Result<Resource, AsResourceError>
				}
			});

		Ok(stream::iter(resource_creation_futures) // stream::iter expects an Iterator<Item=Future>
			.buffer_unordered(concurrency_limit) // Execute Futures concurrently
			.collect()
			.await)
	}

	async fn metadata(&self, path: &Path) -> Result<Metadata, Error> {
		Ok(tokio::fs::metadata(path).await?)
	}

	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error> {
		let mut dir = tokio::fs::read_dir(path).await?;
		let mut paths = vec![];
		while let Some(entry) = dir.next_entry().await? {
			paths.push(entry.path());
		}
		Ok(paths)
	}

	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error> {
		Ok(tokio::fs::read(path).await?)
	}

	async fn write(&self, path: &Path, content: &[u8]) -> Result<()> {
		todo!()
	}
}

impl LocalFileSystem {
	fn filter_entries(&self, path: &Path, options: &Options) -> bool {
		if path.is_file() && options.target == Target::Folders {
			return false;
		}
		if path.is_dir() && options.target == Target::Files {
			return false;
		}

		if path.is_file() {
			if let Some(extension) = path.extension() {
				let partial_extensions = &["crdownload", "part", "download"];
				if partial_extensions.contains(&&*extension.to_string_lossy()) && !options.partial_files {
					return false;
				}
			}
			if path.is_hidden().unwrap_or(false) && !options.hidden_files {
				return false;
			}
		}
		true
	}
}

```

`organizer/organize-core\src\grouper.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

use crate::{batch::Batch, errors::Error};

dyn_clone::clone_trait_object!(Grouper);
dyn_eq::eq_trait_object!(Grouper);

#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Grouper: DynEq + DynClone + Sync + Send + Debug {
	fn name(&self) -> &str;
	async fn group(&self, batch: &Batch) -> Result<Vec<Batch>, Error>;
}

```

`organizer/organize-core\src\lib.rs`:

```rs
#![feature(file_lock)]
#![feature(path_add_extension)]
#![feature(lock_value_accessors)]

pub const PROJECT_NAME: &str = "organize";

pub mod action;
pub mod batch;
pub mod builtins;
pub mod common;
pub mod config;
pub mod context;
pub mod engine;
pub mod errors;
pub mod filter;
pub mod folder;
pub mod grouper;
pub mod selector;
// pub mod hook;
pub mod options;
pub mod parser;
pub mod pipeline;
pub mod resource;
pub mod rule;
pub mod sorter;
pub mod stdx;
pub mod storage;
pub mod templates;
pub mod utils;

```

`organizer/organize-core\src\options.rs`:

```rs
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, path::PathBuf};

use crate::{context::ExecutionContext, errors::Error, templates::template::TemplateString};

fn default_usize() -> usize {
	1.0 as usize
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct OptionsBuilder {
	#[serde(default = "default_usize")]
	pub max_depth: usize,
	#[serde(default = "default_usize")]
	pub min_depth: usize,
	#[serde(default)]
	pub exclude: Vec<TemplateString>,
	#[serde(default)]
	pub hidden_files: bool,
	#[serde(default)]
	pub partial_files: bool,
	#[serde(default)]
	pub target: Target,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct Options {
	pub max_depth: usize,
	pub min_depth: usize,
	pub exclude: Vec<PathBuf>,
	pub hidden_files: bool,
	pub partial_files: bool,
	pub target: Target,
}

impl OptionsBuilder {
	pub async fn compile(self, ctx: &ExecutionContext<'_>) -> Result<Options, Error> {
		let mut excluded_paths = Vec::new();

		for template in &self.exclude {
			let template = ctx.services.compiler.compile_template(template)?;
			if let Ok(rendered_path_str) = template.render(ctx).await {
				excluded_paths.push(PathBuf::from(rendered_path_str));
			}
		}

		Ok(Options {
			max_depth: self.max_depth,
			min_depth: self.min_depth,
			exclude: excluded_paths,
			hidden_files: self.hidden_files,
			partial_files: self.partial_files,
			target: self.target,
		})
	}
}

#[derive(Debug, Default, Clone, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Target {
	#[default]
	Files,
	Folders,
}

```

`organizer/organize-core\src\parser\ast.rs`:

```rs
use chumsky::Parser;
use logos::Logos;

use crate::parser::{
	errors::ParseError,
	lexer::{LexingError, Token},
	parser,
};

// For now, an Expression is just a VariablePath.
// We can add Literals here later if needed.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Expression {
	Variable(Vec<String>),
}

// A full template is a sequence of literal text and expressions.
#[derive(Debug, PartialEq, Clone, Eq)]
pub enum Segment {
	Literal(String),
	Expression(Expression),
}

#[derive(Debug, PartialEq, Clone, Eq)]
pub struct AST {
	pub segments: Vec<Segment>,
}

impl AST {
	/// Parses a raw string into an Abstract Syntax Tree (AST).
	/// This function orchestrates the lexer and expression parser.
	pub fn parse(s: &str) -> Result<Self, ParseError> {
		let mut segments = Vec::new();
		let mut input = s;

		while !input.is_empty() {
			// Find the start of the next expression
			if let Some(start_delim) = input.find("{{") {
				// Anything before the `{{` is a literal
				if start_delim > 0 {
					segments.push(Segment::Literal(input[..start_delim].to_string()));
				}

				// Find the end of the expression
				let expr_content_start = start_delim + 2;
				if let Some(end_delim_relative) = input[expr_content_start..].find("}}") {
					let expr_content_end = expr_content_start + end_delim_relative;
					let expression_content = &input[expr_content_start..expr_content_end].trim();

					// Lex and parse the content inside the delimiters
					let tokens = Token::lexer(expression_content).collect::<Result<Vec<Token<'_>>, LexingError>>()?;

					let (expression, errs) = parser().parse(&tokens).into_output_errors();

					match expression {
						Some(expr) => segments.push(Segment::Expression(expr)),
						None => {
							return Err(ParseError::InvalidExpression {
								content: format!("Could not parse expression: '{{ {expression_content} }}'. Errors: {errs:?}"),
							})
						}
					}

					// Advance the input slice past the `}}`
					input = &input[expr_content_end + 2..];
				} else {
					return Err(ParseError::MismatchedDelimiters {
						position: expr_content_start,
					});
				}
			} else {
				// No more `{{` found, the rest of the string is a literal
				segments.push(Segment::Literal(input.to_string()));
				break;
			}
		}

		Ok(AST { segments })
	}
}

```

`organizer/organize-core\src\parser\errors.rs`:

```rs
use crate::parser::lexer::LexingError;
use thiserror::Error;

// This will be the single, unified error type returned by your parser.
#[derive(Error, Debug)]
pub enum ParseError {
	#[error("Mismatched delimiters: found '{{' at position {position} with no closing '}}'")]
	MismatchedDelimiters { position: usize },

	#[error("Could not parse expression: '{{ {content} }}'")]
	InvalidExpression { content: String },

	#[error(transparent)]
	LexingError(#[from] LexingError),
}

impl ParseError {
	/// Returns `true` if the parse error is [`MismatchedDelimiters`].
	///
	/// [`MismatchedDelimiters`]: ParseError::MismatchedDelimiters
	#[must_use]
	pub fn is_mismatched_delimiters(&self) -> bool {
		matches!(self, Self::MismatchedDelimiters { .. })
	}

	/// Returns `true` if the parse error is [`InvalidExpression`].
	///
	/// [`InvalidExpression`]: ParseError::InvalidExpression
	#[must_use]
	pub fn is_invalid_expression(&self) -> bool {
		matches!(self, Self::InvalidExpression { .. })
	}

	/// Returns `true` if the parse error is [`LexingError`].
	///
	/// [`LexingError`]: ParseError::LexingError
	#[must_use]
	pub fn is_lexing_error(&self) -> bool {
		matches!(self, Self::LexingError { .. })
	}
}

```

`organizer/organize-core\src\parser\lexer.rs`:

```rs
use logos::Logos;
use thiserror::Error;

#[derive(Error, Default, Debug, Clone, PartialEq)]
pub enum LexingError {
	#[error("Invalid identifier: {0}")]
	InvalidIdentifier(String),
	#[default]
	#[error("Unknown lexing error")]
	Other,
}

#[derive(Logos, Debug, PartialEq, Clone)]
#[logos(skip r"[ \t\f\n]+", error = LexingError, extras = (usize, usize))]
pub enum Token<'a> {
	#[token("{{")]
	OpenDelim,
	#[token("}}")]
	CloseDelim,
	#[token(".")]
	Dot,
	#[regex(r"[a-zA-Z0-9_][a-zA-Z0-9_]*")]
	Identifier(&'a str),
	#[regex(".",  |lex| Err(LexingError::InvalidIdentifier(lex.slice().to_string())), priority = 1)]
	InvalidToken(LexingError),
}

#[cfg(test)]
mod tests {
	use super::*; // Import Token and Logos

	fn lex<'a>(input: &'a str) -> Vec<Result<Token<'a>, LexingError>> {
		// A helper function to collect all tokens from the lexer
		Token::lexer(input).collect()
	}

	#[test]
	fn test_simple_variable() {
		let tokens = lex("{{ name }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("name".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_path_expression() {
		let tokens = lex("{{ user.address.city }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("address".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("city".into())),
			Ok(Token::CloseDelim)
		]);
	}

	#[test]
	fn test_invalid_token() {
		// Logos will produce an Error token for characters it doesn't recognize
		// In our current lexer, most symbols would be skipped or cause an error.
		// Let's assume we modify the lexer slightly to capture errors.
		// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ user.name! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Ok(Token::Identifier("name".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_character_within_expression() {
		// 	// Logos will produce an Error token for characters it doesn't recognize
		// 	// In our current lexer, most symbols would be skipped or cause an error.
		// 	// Let's assume we modify the lexer slightly to capture errors.
		// 	// For now, this test shows that it simply ignores non-defined tokens.
		let tokens = lex("{{ path! }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("path".into())),
			Err(LexingError::InvalidIdentifier("!".into())),
			Ok(Token::CloseDelim),
		]);
	}

	#[test]
	fn lexer_handles_invalid_start_of_identifier() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ 1st_place }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Err(LexingError::InvalidIdentifier("1".into())),
			Ok(Token::Identifier("st_place".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_multiple_errors() {
		// Identifiers in our language cannot start with a number.
		let tokens = lex("{{ user.@email + }}");
		assert_eq!(tokens, vec![
			Ok(Token::OpenDelim),
			Ok(Token::Identifier("user".into())),
			Ok(Token::Dot),
			Err(LexingError::InvalidIdentifier("@".into())),
			Ok(Token::Identifier("email".into())),
			Err(LexingError::InvalidIdentifier("+".into())),
			Ok(Token::CloseDelim)
		])
	}

	#[test]
	fn lexer_handles_empty_expression() {
		let tokens = lex("{{}}");
		assert_eq!(tokens, vec![Ok(Token::OpenDelim), Ok(Token::CloseDelim)])
	}
}

```

`organizer/organize-core\src\parser\mod.rs`:

```rs
use chumsky::prelude::*;

use crate::parser::{ast::Expression, lexer::Token};

pub mod ast;
pub mod errors;
pub mod lexer;

pub fn parser<'a>() -> impl Parser<'a, &'a [Token<'a>], Expression, extra::Err<Simple<'a, Token<'a>>>> {
	// A parser for a single identifier token
	let ident = select! { Token::Identifier(s) => s.to_string() };

	// A parser for a dot-separated path of one or more identifiers
	let var_path = ident
		.separated_by(just(Token::Dot))
		.at_least(1) // must have at least one part
		.collect::<Vec<String>>()
		.map(|parts| parts);

	var_path.map(Expression::Variable)
}

```

`organizer/organize-core\src\pipeline.rs`:

```rs
use futures::future;

use crate::{
	action::Receipt,
	batch::Batch,
	context::{ExecutionContext, ExecutionScope},
	engine::ExecutionModel,
	errors::Error,
	grouper::Grouper,
	resource::Resource,
	rule::{Rule, Stage},
	sorter::Sorter,
};
use std::sync::Arc;

/// Represents the data flowing through the pipeline.
/// It tracks the current set of file batches and the sequence of
/// groupers that have been applied to create them.
#[derive(Debug)]
pub struct PipelineStream {
	/// The current data, always represented as a list of batches.
	/// An "ungrouped" state is simply a Vec with one Batch.
	pub batches: Vec<Batch>,
	/// The ordered stack of groupers that have been applied.
	pub groupers: Vec<Box<dyn Grouper>>,
	pub sorters: Vec<Box<dyn Sorter>>,
}

impl PipelineStream {
	/// Creates a new stream with a single batch of files and no groupings.
	pub fn new(files: Vec<Arc<Resource>>) -> Self {
		Self {
			batches: vec![Batch::initial(files)],
			groupers: Vec::new(),
			sorters: Vec::new(),
		}
	}

	/// Flattens all batches into a single, unordered list of files.
	pub fn all_files(&self) -> Vec<Arc<Resource>> {
		self.batches.iter().flat_map(|batch| batch.files.clone()).collect()
	}

	pub async fn resort(&mut self) {
		for batch in self.batches.iter_mut() {
			for sorter in &self.sorters {
				sorter.sort(&mut batch.files).await;
			}
		}
	}

	/// Re-applies the entire stack of stored groupers to a new set of files.
	/// This is the key to maintaining a consistent state.
	pub async fn regroup(&self, files: Vec<Arc<Resource>>) -> Result<Vec<Batch>, anyhow::Error> {
		let mut current_batches = vec![Batch::initial(files)];

		for grouper in &self.groupers {
			let mut next_level_batches = Vec::new();
			for batch in current_batches {
				// Apply the grouper to each batch from the previous level
				next_level_batches.extend(grouper.group(&batch).await?);
			}
			current_batches = next_level_batches;
		}
		Ok(current_batches)
	}
}

pub struct Pipeline {
	stages: Vec<Stage>,
	stream: PipelineStream,
}

impl Pipeline {
	pub fn new(rule: Rule) -> Self {
		Self {
			stages: rule.pipeline,
			stream: PipelineStream::new(Vec::new()), // Start with no files
		}
	}

	pub async fn run(mut self, ctx: &ExecutionContext<'_>) -> Result<PipelineStream, Error> {
		for stage in self.stages.into_iter() {
			match stage {
				Stage::Search { location, source } => {
					let scope = ExecutionScope::new_location_scope(source.clone(), &location);
					let ctx = ctx.with_scope(scope);
					let new_files = location.backend.discover(&location, &ctx).await?;
					if location.mode.is_append() {
						let mut all_files = self.stream.all_files();
						all_files.extend(new_files);
						self.stream.batches = self.stream.regroup(all_files).await?;
						self.stream.resort().await;
					} else {
						self.stream = PipelineStream::new(new_files);
					}
				}
				Stage::Grouper { grouper, .. } => {
					let all_files = self.stream.all_files();
					self.stream.groupers.push(grouper);
					self.stream.batches = self.stream.regroup(all_files).await?;
					self.stream.resort().await;
				}
				Stage::Sorter { sorter, .. } => {
					self.stream.sorters.push(sorter);
					self.stream.resort().await;
				}
				Stage::Filter { filter, source } => {
					let mut next_batches = Vec::new();
					match filter.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let passed_files = filter.filter(&batch_ctx).await?;
								if !passed_files.is_empty() {
									next_batches.push(Batch {
										files: passed_files,
										context: batch.context.clone(),
									});
								}
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let filter = filter.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										filter.filter(&ctx).await
									};
									futs.push(fut);
								}
								let results: Vec<Arc<Resource>> = future::try_join_all(futs).await?.into_iter().flatten().collect();
								if !results.is_empty() {
									next_batches.push(Batch {
										files: results,
										context: batch.context.clone(),
									});
								}
							}
						}
					}
					self.stream.batches = next_batches;
				}
				Stage::Action { action, source } => {
					let mut all_next_files = Vec::new();
					match action.execution_model() {
						ExecutionModel::Batch => {
							for batch in self.stream.batches.iter() {
								let scope = ExecutionScope::new_batch_scope(source.clone(), batch);
								let batch_ctx = ctx.with_scope(scope);
								let receipt = action.commit(&batch_ctx).await?;
								all_next_files.extend(receipt.next);
							}
						}
						ExecutionModel::Single => {
							for batch in self.stream.batches.iter() {
								let mut futs = Vec::new();
								for resource in &batch.files {
									let resource_clone = resource.clone();
									let meta = source.clone();
									let action = action.clone();
									let fut = async move {
										let scope = ExecutionScope::new_resource_scope(meta.clone(), resource_clone);
										let ctx = ctx.with_scope(scope);
										action.commit(&ctx).await
									};
									futs.push(fut);
								}
								let receipts: Vec<Receipt> = future::try_join_all(futs).await?;
								for receipt in receipts {
									all_next_files.extend(receipt.next);
								}
							}
						}
					}
					// An action's output always replaces the current data stream and resets grouping.
					self.stream = PipelineStream::new(all_next_files);
				}
				Stage::Flatten { flatten, .. } => {
					if flatten {
						self.stream = PipelineStream::new(self.stream.all_files());
					}
				}
				Stage::Select { selector, .. } => {
					let selection_futures = self.stream.batches.iter().map(|batch| selector.select(batch));
					let selected_batches: Vec<Batch> = future::try_join_all(selection_futures).await?.into_iter().collect();
					self.stream.batches = selected_batches;
				}
			}
		}
		Ok(self.stream)
	}
}

```

`organizer/organize-core\src\resource.rs`:

```rs
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::{
	fmt::{Debug, Display},
	fs::Metadata,
	hash::Hash,
	path::{Path, PathBuf},
	sync::{Arc, OnceLock},
};
use tokio::{fs::File, io::AsyncReadExt};

use crate::{context::ExecutionContext, errors::Error, folder::Location};

#[derive(Debug, Default, Clone)]
pub enum FileState {
	Unknown,
	#[default]
	Exists,
	Deleted,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Resource {
	pub path: PathBuf,
	pub location: Arc<Location>,
	#[serde(skip)]
	mime: OnceLock<String>,
	#[serde(skip)]
	bytes: OnceLock<Vec<u8>>,
	#[serde(skip)]
	hash: OnceLock<String>,
	#[serde(skip)]
	metadata: OnceLock<Metadata>,
}

impl AsRef<Path> for Resource {
	fn as_ref(&self) -> &Path {
		self.path.as_path()
	}
}

impl Display for Resource {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}", self.path.display())
	}
}

impl PartialEq for Resource {
	fn eq(&self, other: &Self) -> bool {
		self.path == other.path
	}
}

impl Hash for Resource {
	fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
		self.path.hash(state);
	}
}

impl Eq for Resource {}

impl Resource {
	pub fn as_path(&self) -> &Path {
		self.path.as_path()
	}

	pub fn with_filename(self, filename: &str) -> Self {
		let new_path = self.path.with_file_name(filename);
		self.with_path(new_path)
	}

	pub fn with_path(self, new_path: PathBuf) -> Self {
		Self {
			path: new_path,
			location: self.location, // The origin root folder remains the same.

			// The content, hash, and MIME type of a file do not change when it is moved.
			// We can move these initialized OnceLock fields to the new struct to preserve the cache.
			bytes: self.bytes,
			hash: self.hash,
			mime: self.mime,

			// The filesystem metadata (like modification times of parent dirs) IS different
			// at the new location. We reset this field to force a re-fetch if needed.
			metadata: OnceLock::new(),
		}
	}

	pub fn get_mime(&self) -> &str {
		match self.mime.get() {
			Some(mime) => mime.as_str(),
			None => {
				let mime = mime_guess::from_path(&self.path).first_or_octet_stream().to_string();
				self.mime.set(mime).unwrap();
				self.mime.get().unwrap().as_str()
			}
		}
	}

	pub async fn get_metadata(&self) -> &Metadata {
		match self.metadata.get() {
			Some(metadata) => metadata,
			None => {
				let metadata = tokio::fs::metadata(&self.path).await.unwrap();
				self.metadata.set(metadata).unwrap();
				self.metadata.get().unwrap()
			}
		}
	}

	pub async fn get_bytes(&self) -> &Vec<u8> {
		match self.bytes.get() {
			Some(content) => content,
			None => {
				let content = tokio::fs::read(&self.path).await.unwrap();
				self.bytes.set(content).unwrap();
				self.bytes.get().unwrap()
			}
		}
	}

	pub async fn get_hash(&self) -> &String {
		match self.hash.get() {
			Some(hash) => hash,
			None => {
				let mut file = File::open(&self.path).await.unwrap();
				let mut hasher = Sha256::new();
				let mut buffer = [0; 1024];
				loop {
					let count = file.read(&mut buffer).await.unwrap();
					if count == 0 {
						break;
					}
					hasher.update(&buffer[..count]);
				}
				let hash = hasher.finalize();
				let hash_str = format!("{hash:x}");
				self.hash.set(hash_str).unwrap();
				self.hash.get().unwrap()
			}
		}
	}
}

// impl Serialize for Resource {
// 	fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
// 	where
// 		S: Serializer,
// 	{
// 		// Serialize the PathBuf that the Arc points to.
// 		self.path.serialize(serializer)
// 	}
// }
//
impl Resource {
	pub fn new(path: &PathBuf, location: Arc<Location>) -> Self {
		Self {
			path: path.clone(),
			location,
			mime: OnceLock::new(),
			bytes: OnceLock::new(),
			hash: OnceLock::new(),
			metadata: OnceLock::new(),
		}
	}

	pub async fn try_exists(&self, ctx: &ExecutionContext<'_>) -> Result<bool, Error> {
		if ctx.settings.dry_run {
			return match ctx
				.services
				.fs
				.tracked_files
				.get(self.as_path())
				.await
				.unwrap_or(FileState::Unknown)
			{
				FileState::Exists => Ok(true),
				FileState::Deleted => Ok(false),
				FileState::Unknown => Ok(tokio::fs::try_exists(&self.path).await?),
			};
		}

		// Otherwise, check the physical filesystem using the resource's path.
		Ok(tokio::fs::try_exists(&self.path).await?)
	}
}

// #[cfg(test)]
// mod tests {
// 	use super::*;
// 	use std::path::PathBuf;

// 	#[test]
// 	fn new_with_valid_path_succeeds() {
// 		let path = PathBuf::from("/tmp/test.txt");
// 		let root = PathBuf::from("/tmp");
// 		let resource = Resource::new(&path, &root).unwrap();
// 		assert_eq!(resource.path(), &path);
// 		assert_eq!(resource.root(), &root);
// 	}

// 	#[test]
// 	fn new_with_root_path_returns_err() {
// 		let path = PathBuf::from("/");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_dot_path_succeeds_on_windows_fails_on_unix() {
// 		let path = PathBuf::from(".");
// 		let result = Resource::new(&path, &path);
// 		assert!(result.is_err());
// 	}

// 	#[test]
// 	fn new_with_relative_path_succeeds() {
// 		let path = PathBuf::from("some/dir/file.txt");
// 		let result = Resource::new(&path, "some/dir");
// 		assert!(result.is_ok());
// 	}

// 	#[test]
// 	fn new_with_bare_filename_returns_err() {
// 		// A bare filename like "file.txt" has an empty parent, which the new logic correctly rejects.
// 		let path = PathBuf::from("file.txt");
// 		let result = Resource::new(&path, ".");
// 		assert!(result.is_err());
// 	}
// }

```

`organizer/organize-core\src\rule.rs`:

```rs
use std::{path::PathBuf, sync::Arc};

use itertools::Itertools;
use serde::{Deserialize, Deserializer, Serialize};

use crate::{
	action::{Action, ActionBuilder},
	context::ExecutionContext,
	errors::Error,
	filter::Filter,
	folder::{Location, LocationBuilder},
	grouper::Grouper,
	selector::Selector,
	sorter::Sorter,
};

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
pub struct RuleMetadata {
	pub name: Option<String>,
	pub description: Option<String>,
	#[serde(default)]
	pub tags: Vec<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq)]
#[serde(deny_unknown_fields)]
pub struct RuleBuilder {
	#[serde(flatten)]
	pub metadata: RuleMetadata,
	#[serde(rename = "stage")]
	pub pipeline: Vec<StageBuilder>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Rule {
	pub metadata: Arc<RuleMetadata>,
	pub pipeline: Vec<Stage>,
}

async fn load_rule_builder_from_path(path: &std::path::Path) -> Result<RuleBuilder, anyhow::Error> {
	let content = tokio::fs::read_to_string(path).await?;
	let builder: RuleBuilder = toml::from_str(&content)?;
	Ok(builder)
}

impl RuleBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>) -> Result<Rule, Error> {
		let mut final_pipeline = Vec::new();
		let main_meta = Arc::new(self.metadata);
		let mut processing_stack: Vec<(StageBuilder, Arc<RuleMetadata>)> = self
			.pipeline
			.into_iter()
			.map(|builder| (builder, main_meta.clone()))
			.rev()
			.collect();

		while let Some((builder, meta)) = processing_stack.pop() {
			match builder {
				StageBuilder::Compose(path) => {
					let composed_builder = load_rule_builder_from_path(&path).await?;
					let composed_meta = Arc::new(composed_builder.metadata);
					for stage_builder in composed_builder.pipeline.into_iter().rev() {
						processing_stack.push((stage_builder, composed_meta.clone()));
					}
				}
				// The logic to build the final Stage enum now changes slightly
				other_builder => {
					let stage_enum = other_builder.build(ctx, meta).await?;
					final_pipeline.push(stage_enum);
				}
			}
		}

		Ok(Rule {
			metadata: main_meta.clone(),
			pipeline: final_pipeline,
		})
	}
}

#[derive(Debug, Serialize, PartialEq, Eq, Clone)]
pub enum StageBuilder {
	Search(LocationBuilder),
	Compose(PathBuf),
	Action(Box<dyn ActionBuilder>),
	Filter(Box<dyn Filter>),
	Select(Box<dyn Selector>),
	Grouper(Box<dyn Grouper>),
	Sorter(Box<dyn Sorter>),
	Flatten(bool),
}

impl StageBuilder {
	pub async fn build(self, ctx: &ExecutionContext<'_>, source: Arc<RuleMetadata>) -> Result<Stage, Error> {
		match self {
			StageBuilder::Search(location_builder) => {
				let stage = location_builder.build(ctx).await.unwrap();
				Ok(Stage::Search { location: stage, source })
			}
			StageBuilder::Flatten(bool) => Ok(Stage::Flatten { flatten: bool, source }),
			StageBuilder::Action(builder) => {
				let stage = builder.build(ctx).await?;
				Ok(Stage::Action { action: stage, source })
			}
			StageBuilder::Filter(stage) => Ok(Stage::Filter { filter: stage, source }),
			StageBuilder::Grouper(stage) => Ok(Stage::Grouper { grouper: stage, source }),
			StageBuilder::Sorter(stage) => Ok(Stage::Sorter { sorter: stage, source }),
			StageBuilder::Compose(_) => unreachable!("Compose stages should be flattened"),
			StageBuilder::Select(stage) => Ok(Stage::Select { selector: stage, source }),
		}
	}
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Stage {
	Search {
		location: Location,
		source: Arc<RuleMetadata>,
	},
	Action {
		action: Box<dyn Action>,
		source: Arc<RuleMetadata>,
	},
	Filter {
		filter: Box<dyn Filter>,
		source: Arc<RuleMetadata>,
	},
	Select {
		selector: Box<dyn Selector>,
		source: Arc<RuleMetadata>,
	},
	Flatten {
		flatten: bool,
		source: Arc<RuleMetadata>,
	},
	Grouper {
		grouper: Box<dyn Grouper>,
		source: Arc<RuleMetadata>,
	},
	Sorter {
		sorter: Box<dyn Sorter>,
		source: Arc<RuleMetadata>,
	},
}

// impl<'de> Deserialize<'de> for StageBuilder {
// 	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
// 	where
// 		D: Deserializer<'de>,
// 	{
// 		// Deserialize the TOML [[stage]] table into a generic Value.
// 		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
// 		let table = map
// 			.as_table_mut()
// 			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

// 		// Find the single key that defines the stage type.
// 		let key = {
// 			let keys: Vec<_> = table.keys().cloned().collect();
// 			if keys.len() != 1 {
// 				// This handles the case where a stage has multiple primary keys, like both `filter` and `action`.
// 				// We need to check for this AFTER handling the parameters that live alongside the primary key.
// 				// We will find the primary key first, and then deserialize the rest.
// 			}

// 			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
// 			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
// 				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
// 			})?
// 		};

// 		// The value associated with the primary key.
// 		let value = table
// 			.remove(&key)
// 			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{}'", key)))?;

// 		// The rest of the table contains the parameters.
// 		let params = toml::Value::Table(table.clone());

// 		match key.as_str() {
// 			"search" => {
// 				let path_template = value.try_into::<String>().map_err(serde::de::Error::custom)?;
// 				let mut builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;
// 				builder.path = Template::from_str(&path_template).map_err(serde::de::Error::custom)?; // Set the path from the primary key's value
// 				Ok(StageBuilder::Search(builder))
// 			}
// 			"compose" => {
// 				let rules_to_compose = value.try_into::<Vec<PathBuf>>().map_err(serde::de::Error::custom)?;
// 				Ok(StageBuilder::Compose(rules_to_compose))
// 			}
// 			"filter" | "action" | "group-by" | "sort-by" => {
// 				// This handles all the typetag'd trait objects.
// 				let component_type = value
// 					.as_str()
// 					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{}'", key)))?;

// 				// We inject the `type` field that `typetag` expects into the parameters table.
// 				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
// 				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
// 				let component_value = toml::Value::Table(component_table);

// 				// Now deserialize from this new value into the correct trait object.
// 				match key.as_str() {
// 					"filter" => Ok(StageBuilder::Filter(
// 						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"action" => Ok(StageBuilder::Action(
// 						Box::<dyn Action>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"group-by" => Ok(StageBuilder::Grouper(
// 						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					"sort-by" => Ok(StageBuilder::Sorter(
// 						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
// 					)),
// 					_ => unreachable!(),
// 				}
// 			}
// 			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{}'", other))),
// 		}
// 	}
// }

impl<'de> Deserialize<'de> for StageBuilder {
	fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
	where
		D: Deserializer<'de>,
	{
		let mut map: toml::Value = Deserialize::deserialize(deserializer)?;
		let table = map
			.as_table_mut()
			.ok_or_else(|| serde::de::Error::custom("Expected a table for the stage"))?;

		let key = {
			let keys: Vec<_> = table.keys().cloned().collect();
			let possible_keys = ["search", "compose", "action", "filter", "group-by", "sort-by"];
			keys.into_iter().find(|k| possible_keys.contains(&k.as_str())).ok_or_else(|| {
				serde::de::Error::custom("Stage must contain one of: 'search', 'compose', 'action', 'filter', 'group-by', or 'sort-by'")
			})?
		};

		let value = table
			.remove(&key)
			.ok_or_else(|| serde::de::Error::custom(format!("Could not find key '{key}'")))?;

		let params = toml::Value::Table(table.clone());

		match key.as_str() {
			"search" => {
				let path_template_str = value.try_into::<String>().map_err(serde::de::Error::custom)?;
				let mut params = params.as_table().unwrap().clone();
				params.insert("path".to_string(), path_template_str.into());
				let builder: LocationBuilder = params.try_into().map_err(serde::de::Error::custom)?;

				Ok(StageBuilder::Search(builder))
			}
			"compose" => {
				let rule_to_compose = value.try_into::<PathBuf>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Compose(rule_to_compose))
			}
			"flatten" => {
				let value = value.try_into::<bool>().map_err(serde::de::Error::custom)?;
				Ok(StageBuilder::Flatten(value))
			}
			"filter" | "select" | "action" | "group-by" | "sort-by" => {
				let component_type = value
					.as_str()
					.ok_or_else(|| serde::de::Error::custom(format!("Expected a string for key '{key}'")))?;

				let mut component_table = params.try_into::<toml::value::Table>().map_err(serde::de::Error::custom)?;
				component_table.insert("type".to_string(), toml::Value::String(component_type.to_string()));
				let component_value = toml::Value::Table(component_table);

				match key.as_str() {
					"filter" => Ok(StageBuilder::Filter(
						Box::<dyn Filter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"select" => Ok(StageBuilder::Select(
						Box::<dyn Selector>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"action" => Ok(StageBuilder::Action(
						Box::<dyn ActionBuilder>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"group-by" => Ok(StageBuilder::Grouper(
						Box::<dyn Grouper>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					"sort-by" => Ok(StageBuilder::Sorter(
						Box::<dyn Sorter>::deserialize(component_value).map_err(serde::de::Error::custom)?,
					)),
					_ => unreachable!(),
				}
			}
			other => Err(serde::de::Error::custom(format!("Unknown stage type: '{other}'"))),
		}
	}
}

```

`organizer/organize-core\src\selector.rs`:

```rs
use crate::{batch::Batch, errors::Error};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Selector);
dyn_eq::eq_trait_object!(Selector);

/// A trait for any component that selects a subset of files from a batch based on
/// positional or quantitative criteria (e.g., first, last, random sample).
#[async_trait]
#[typetag::serde(tag = "type")]
pub trait Selector: DynEq + DynClone + Sync + Send + Debug {
	async fn select(&self, batch: &Batch) -> Result<Batch, Error>;
}

```

`organizer/organize-core\src\sorter.rs`:

```rs
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{fmt::Debug, sync::Arc};

use crate::resource::Resource;

dyn_clone::clone_trait_object!(Sorter);
dyn_eq::eq_trait_object!(Sorter);

#[typetag::serde(tag = "type")]
#[async_trait]
pub trait Sorter: DynEq + DynClone + Sync + Send + Debug {
	/// Sorts a slice of resources in-place.
	async fn sort(&self, files: &mut [Arc<Resource>]);
}

```

`organizer/organize-core\src\stdx\mod.rs`:

```rs
pub mod path;

```

`organizer/organize-core\src\stdx\path.rs`:

```rs
#[cfg(target_family = "windows")]
use std::path::Path;
use std::{ffi::OsStr, path::PathBuf, sync::Arc};

use async_trait::async_trait;

use crate::{context::ExecutionContext, folder::Location, resource::Resource};

#[async_trait]
pub trait PathExt {
	type HiddenError;
	fn is_hidden(&self) -> Result<bool, Self::HiddenError>;
	fn expand_user(self) -> PathBuf;
	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource>;
}

#[async_trait]
impl<T: AsRef<Path> + Sync + Send> PathExt for T {
	#[cfg(target_family = "unix")]
	type HiddenError = std::convert::Infallible;
	#[cfg(target_family = "windows")]
	type HiddenError = std::io::Error;

	fn expand_user(self) -> PathBuf {
		let path = self.as_ref();
		let mut components = path.components();
		if let Some(component) = components.next() {
			if component.as_os_str() == OsStr::new("~") {
				let mut path = dirs::home_dir().expect("could not find home directory");
				path.extend(components);
				return path;
			}
		}
		path.to_path_buf()
	}

	#[cfg(target_family = "unix")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		match self.file_name() {
			None => Ok(false),
			Some(filename) => Ok(filename.to_string_lossy().starts_with('.')),
		}
	}

	#[cfg(target_family = "windows")]
	fn is_hidden(&self) -> Result<bool, Self::HiddenError> {
		use std::{fs, os::windows::prelude::*};
		let metadata = fs::metadata(self)?;
		let attributes = metadata.file_attributes();
		Ok((attributes & 0x2) > 0)
	}

	async fn as_resource(&self, ctx: &ExecutionContext, location: Arc<Location>) -> Arc<Resource> {
		ctx.services
			.fs
			.resources
			.get_with(self.as_ref().to_path_buf(), async move {
				Arc::new(Resource::new(&self.as_ref().to_path_buf(), location))
			})
			.await
	}
}

#[cfg(test)]
mod tests {

	use super::*;

	#[cfg(target_family = "unix")]
	#[test]
	fn check_hidden() {
		use super::*;
		let path = Path::new("/home/user/.testfile");
		assert!(path.is_hidden().unwrap())
	}

	#[cfg(target_family = "windows")]
	#[test]
	fn not_hidden() {
		use tempfile::NamedTempFile;

		use super::*;
		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		assert!(!path.is_hidden().unwrap());
	}

	#[test]
	#[cfg(target_family = "windows")]
	fn check_hidden() {
		use super::*;
		use tempfile::NamedTempFile;

		let file = NamedTempFile::new().unwrap();
		let path = file.path();
		// Use the `attrib` command on Windows to set the hidden attribute.
		let status = std::process::Command::new("attrib")
			.arg("+h")
			.arg(path.as_os_str())
			.status()
			.expect("failed to execute attrib command");
		assert!(status.success(), "attrib command failed");
		assert!(path.is_hidden().unwrap());
	}

	#[test]
	fn invalid_tilde() {
		let original = dirs::home_dir().unwrap().join("Documents~");
		assert_eq!(original.clone().expand_user(), original)
	}

	#[test]
	fn user_tilde() {
		let original = "~/Documents";
		let expected = dirs::home_dir().unwrap().join("Documents");
		assert_eq!(original.expand_user(), expected)
	}
}

```

`organizer/organize-core\src\storage.rs`:

```rs
use crate::{context::ExecutionContext, errors::Error, folder::Location, resource::Resource};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::{
	fmt::Debug,
	fs::Metadata,
	path::{Path, PathBuf},
	sync::Arc,
};

dyn_clone::clone_trait_object!(StorageProvider);
dyn_eq::eq_trait_object!(StorageProvider);

#[async_trait]
#[typetag::serde(tag = "provider")]
/// A trait for any component that can provide a list of files to be processed.
/// This could be a local folder, an S3 bucket, an SFTP connection, etc.
pub trait StorageProvider: DynEq + DynClone + Sync + Send + Debug {
	fn home(&self) -> Result<PathBuf, Error>;
	fn prefix(&self) -> &'static str;
	async fn metadata(&self, path: &Path) -> Result<Metadata, Error>;
	async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, Error>;
	async fn read(&self, path: &Path) -> Result<Vec<u8>, Error>;
	async fn write(&self, path: &Path, content: &[u8]) -> Result<()>;
	async fn discover(&self, location: &Location, ctx: &ExecutionContext<'_>) -> Result<Vec<Arc<Resource>>, Error>;
	async fn mkdir(&self, path: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn r#move(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn copy(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn delete(&self, path: &Path) -> Result<(), Error>;
	async fn download(&self, from: &Path) -> Result<PathBuf, Error>;
	async fn upload(&self, from_local: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn hardlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
	async fn symlink(&self, from: &Path, to: &Path, ctx: ExecutionContext<'_>) -> Result<(), Error>;
}

```

`organizer/organize-core\src\templates\accessor.rs`:

```rs
use crate::{context::ExecutionContext, templates::value::Value};
use anyhow::Result;
use async_trait::async_trait;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use std::fmt::Debug;

dyn_clone::clone_trait_object!(Accessor);
dyn_eq::eq_trait_object!(Accessor);

/// Represents a compiled and type-safe property path.
///
/// An Accessor is a function object that encapsulates the logic to retrieve a
/// specific value from a given execution context. This is the output of the
/// template compilation process.
#[async_trait]
pub trait Accessor: DynEq + DynClone + Sync + Send + Debug {
	async fn get(&self, ctx: &ExecutionContext) -> Result<Value>;
}

```

`organizer/organize-core\src\templates\compiler.rs`:

```rs
use crate::{
	errors::Error,
	parser::ast::{Expression, Segment, AST},
	templates::{
		accessor::Accessor,
		registry::SchemaRegistry,
		template::{Template, TemplatePart},
	},
};
use anyhow::Result;

/// The central compiler for the template system.
/// It uses a SchemaRegistry to validate variables and a full parser to build the template.
#[derive(Debug, Clone)]
pub struct TemplateCompiler {
	schema: SchemaRegistry,
}

impl Default for TemplateCompiler {
	fn default() -> Self {
		Self::new()
	}
}

impl TemplateCompiler {
	/// Creates a new compiler with a default schema registry that discovers
	/// all registered static variable providers.
	pub fn new() -> Self {
		Self {
			schema: SchemaRegistry::new(),
		}
	}

	/// Compiles a raw string into an executable Template object using your parser.
	pub fn compile_template(&self, raw_template: &str) -> Result<Template, Error> {
		// Stage 1: Parse the raw string into an Abstract Syntax Tree (AST)
		// using your provided `AST::parse` method.
		let ast = AST::parse(raw_template)?;
		let mut parts = Vec::new();

		// Stage 2: Walk the AST to build the final, executable Template object.
		for segment in ast.segments {
			match segment {
				Segment::Literal(text) => {
					parts.push(TemplatePart::Static(text));
				}
				Segment::Expression(expr) => {
					let accessor = self.build_accessor(expr)?;
					parts.push(TemplatePart::Dynamic(accessor));
				}
			}
		}

		Ok(Template {
			parts,
			text: raw_template.to_string(),
		})
	}

	/// Builds a type-safe accessor from a parsed expression AST node.
	/// This is the bridge between your parser and the execution engine.
	fn build_accessor(&self, expr: Expression) -> Result<Box<dyn Accessor>, Error> {
		match expr {
			Expression::Variable(parts) => {
				// We use the existing SchemaRegistry to validate the path and get the accessor.
				let parts_str: Vec<&str> = parts.iter().map(AsRef::as_ref).collect();
				self.schema.parse_property_chain(&parts_str)
			}
		}
	}
}

```

`organizer/organize-core\src\templates\engine.rs`:

```rs
use std::env::VarError;

use thiserror::Error;


#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Templater;

#[derive(Error, Debug)]
pub enum TemplateError {
	#[error("variable '{variable}' (fields={fields:?}) cannot be resolved.")]
	UndefinedVariable {
		variable: String,
		fields: Vec<String>,
		#[source]
		source: VarError,
	},

	#[error("empty template")]
	EmptyTemplate,

	#[error("variable '{variable}' could not be deserialized. It may be missing fields or they may be wrong.")]
	DeserializationError {
		#[source]
		source: serde_json::Error,
		variable: String,
		fields: Vec<String>,
	},

	#[error("variable {variable} does not accept any fields, but received {fields:?}")]
	FieldsNotSupported { variable: String, fields: Vec<String> },

	#[error("invalid variable ({variable}): it requires {missing_piece} to be in scope")]
	InvalidContext { missing_piece: String, variable: String },

	#[error("variable '{variable}' does not support a '{field}' subfield")]
	InvalidField { variable: String, field: String },

	#[error("variable '{variable}' requires a field (one of: {fields})")]
	MissingField { variable: String, fields: String },

	#[error("unknown variable '{{{{ {0} }}}}'")]
	UnknownVariable(String),

	#[error("variable '{variable}' requires one of the following fields: {fields:?}")]
	RequiredField { variable: String, fields: Vec<String> },
}

// #[cfg(test)]
// mod tests {
// 	use std::convert::{TryFrom, TryInto};

// 	use super::*;
// 	use crate::{config::{context::RunServices, variables::simple::SimpleVariable}, resource::Resource};

// 	#[test]
// 	fn render_template_not_present_in_engine() {
// 		let engine = Templater::default();
// 		let template = Template::try_from("Hello, {{ name }}!").unwrap();
// 		let context = Context::new(ctx)
// 		let mut context = engine.context().build(&engine);
// 		context.insert("name", "Andrés");
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}

// 	#[test]
// 	fn render_template_present_in_engine() {
// 		let mut engine = Templater::default();
// 		let template = Template::try_from("This is a stored template.").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("This is a stored template.".to_string()));
// 	}

// 	#[test]
// 	fn render_with_simple_variable() {
// 		let var = SimpleVariable {
// 			name: "location".into(),
// 			value: "world".try_into().unwrap(),
// 		};
// 		let mut engine = Templater::new(&vec![Box::new(var)]);
// 		let template = Template::try_from("Hello, {{ location }}!").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("Hello, world!".to_string()));
// 	}

// 	#[test]
// 	fn render_with_path_context() {
// 		let mut engine = Templater::default();
// 		let resource = Resource::new_tmp("test.txt");
// 		let template = Template::try_from("The path is {{ path | stem }}").unwrap();
// 		engine.add_template(&template).unwrap();
// 		let context = engine.context().path(resource.path().to_path_buf()).build(&engine);
// 		let rendered = engine.render(&template, &context).unwrap();
// 		assert_eq!(rendered, Some("The path is test".to_string()));
// 	}

// 	#[test]
// 	fn render_invalid_template_returns_none() {
// 		let engine = Templater::default();
// 		// Invalid syntax: `{%` instead of `{{`
// 		let template = Template::try_from("Hello, {% name }}!").unwrap();
// 		let context = engine.context().build(&engine);
// 		let rendered = engine.render(&template, &context);
// 		assert!(rendered.is_err());
// 	}
// }

```

`organizer/organize-core\src\templates\mod.rs`:

```rs
pub mod accessor;
pub mod compiler;
pub mod engine;
pub mod filter;
pub mod registry;
pub mod schema;
pub mod template;
pub mod value;
pub mod variable;

```

`organizer/organize-core\src\templates\registry.rs`:

```rs
use std::collections::HashMap;

use crate::{
	errors::Error,
	templates::{
		accessor::Accessor,
		schema::{Property, SchemaNode},
		variable::VariableInventory,
	},
};

/// The central schema registry and compiler for template variables.
///
/// It discovers all variable providers at startup and uses their schemas
/// to parse and validate property chains.
#[derive(Clone, Debug)]
pub struct SchemaRegistry {
	/// A map of all discovered static schemas for fast lookups by name.
	root_properties: HashMap<&'static str, Property>,
}

impl Default for SchemaRegistry {
	fn default() -> Self {
		Self::new()
	}
}

impl SchemaRegistry {
	/// Creates a new registry by discovering all registered `Variable` providers
	/// via the `inventory` crate.
	pub fn new() -> Self {
		let root_properties = inventory::iter::<VariableInventory>
			.into_iter()
			.map(|inv| {
				let schema = inv.provider.schema();
				// The key is the static name of the variable (e.g., "file").
				(schema.name, schema)
			})
			.collect();

		Self { root_properties }
	}

	/// Parses a property chain against the compiled schema to get an Accessor.
	pub fn parse_property_chain(&self, parts: &[&str]) -> Result<Box<dyn Accessor>, Error> {
		if parts.is_empty() {
			return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(
				"Property chain cannot be empty.".to_string(),
			)));
		}

		let root_part = parts[0];
		let mut current_prop = self.root_properties.get(root_part).ok_or_else(|| {
			let valid_options: Vec<_> = self.root_properties.keys().collect();
			Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Invalid root variable '{root_part}'. Valid options are: {valid_options:?}"
			)))
		})?;

		// Traverse the rest of the chain.
		for (i, &part) in parts.iter().skip(1).enumerate() {
			match &current_prop.node {
				SchemaNode::Object(properties) => {
					current_prop = properties.iter().find(|p| p.name == part).ok_or_else(|| {
						let valid_options: Vec<_> = properties.iter().map(|p| p.name).collect();
						Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Invalid property '{}' at index {}. Valid options for '{}' are: {:?}",
							part,
							i + 1,
							parts[..i + 1].join("."),
							valid_options
						)))
					})?;
				}
				SchemaNode::DynamicMap(constructor) => {
					if i + 2 < parts.len() {
						return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
							"Cannot access properties on a dynamic value. Chain has too many parts after key '{}' in '{}'.",
							part,
							parts.join(".")
						))));
					}
					// The chain ends here. Call the constructor with the key.
					return Ok(constructor(part));
				}
				SchemaNode::Terminal(_) => {
					return Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
						"Cannot access property '{}' on a terminal value at '{}'.",
						part,
						parts[..i + 1].join(".")
					))));
				}
			}
		}

		// After the loop, the final node must be a Terminal.
		match &current_prop.node {
			SchemaNode::Terminal(constructor) => Ok(constructor()),
			_ => Err(Error::TemplateError(super::engine::TemplateError::UnknownVariable(format!(
				"Incomplete property chain '{}'. It points to an object, not a final value.",
				parts.join(".")
			)))),
		}
	}
}

```

`organizer/organize-core\src\templates\schema.rs`:

```rs
use crate::templates::accessor::Accessor;
use std::{fmt::Debug, sync::Arc};

#[derive(Clone)]
pub enum SchemaNode {
	/// A terminal node that creates a specific, type-safe Accessor.
	Terminal(Arc<dyn Fn() -> Box<dyn Accessor> + Send + Sync>),
	/// An object node with a fixed, known set of sub-properties.
	Object(Vec<Property>),
	/// A map node where sub-properties are dynamic keys.
	DynamicMap(Arc<dyn Fn(&str) -> Box<dyn Accessor> + Send + Sync>),
}

#[derive(Clone)]
pub struct Property {
	pub name: &'static str,
	pub node: SchemaNode,
}

impl Debug for SchemaNode {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			SchemaNode::Terminal(_) => f.debug_tuple("Terminal").field(&"<closure>").finish(),
			SchemaNode::Object(properties) => f.debug_tuple("Object").field(properties).finish(),
			SchemaNode::DynamicMap(_) => f.debug_tuple("DynamicMap").field(&"<closure>").finish(),
		}
	}
}

// Manual `Debug` implementation for `Property`
impl Debug for Property {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.debug_struct("Property")
			.field("name", &self.name)
			.field("node", &self.node)
			.finish()
	}
}

```

`organizer/organize-core\src\templates\template.rs`:

```rs
use serde::{Deserialize, Serialize};

use crate::{context::ExecutionContext, errors::Error, templates::accessor::Accessor};

#[derive(Debug, Eq, PartialEq, Clone)]
pub enum TemplatePart {
	Static(String),
	Dynamic(Box<dyn Accessor>),
}

#[derive(Deserialize, Serialize, PartialEq, Eq, Debug, Clone)]
pub struct TemplateString(pub String);

impl std::ops::Deref for TemplateString {
	type Target = String;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

#[derive(Debug, Deserialize, Serialize, Eq, PartialEq, Clone)]
pub struct Template {
	pub text: String,
	#[serde(skip)]
	pub parts: Vec<TemplatePart>,
}

impl Template {
	pub async fn render(&self, ctx: &ExecutionContext<'_>) -> Result<String, Error> {
		let mut output = String::new();
		for part in &self.parts {
			match part {
				TemplatePart::Static(s) => output.push_str(s),
				TemplatePart::Dynamic(accessor) => {
					let value = accessor.get(ctx).await?;
					output.push_str(&value.to_string());
				}
			}
		}
		Ok(output)
	}
}

```

`organizer/organize-core\src\templates\value.rs`:

```rs
use std::fmt;

/// Represents any possible value that can be retrieved from a template variable.
/// This enum provides type safety for the data flowing through the template engine.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
	String(String),
	OptionString(Option<String>),
	// Add other types as needed, e.g., Int(i64), Bool(bool)
	Null,
}

impl fmt::Display for Value {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			Value::String(s) => write!(f, "{s}"),
			Value::OptionString(Some(s)) => write!(f, "{s}"),
			Value::OptionString(None) | Value::Null => Ok(()), // Render None/Null as empty string
		}
	}
}

```

`organizer/organize-core\src\templates\variable.rs`:

```rs
use crate::templates::schema::Property;

/// The plugin interface for a static variable provider.
///
/// Any struct implementing this trait can be automatically discovered and
/// integrated into the template engine's schema. This trait is intended for
/// built-in variables with fixed schemas, like `file` or `env`.
pub trait StatelessVariable: Sync + Send {
	/// Returns the canonical name of the root variable (e.g., "file", "env").
	fn name(&self) -> &'static str;

	/// Returns the schema for this variable, defining its properties and accessors.
	fn schema(&self) -> Property;
}

/// The collectible struct for the `inventory` crate.
/// It holds a static reference to an object that implements our `Variable` trait.
pub struct VariableInventory {
	pub provider: &'static (dyn StatelessVariable + Sync),
}

// Declare the global collection for automatic registration of static variable providers.
inventory::collect!(VariableInventory);

```

`organizer/organize-core\src\utils\backup.rs`:

```rs
use std::path::PathBuf;

use crate::{context::ExecutionContext, errors::Error};
use anyhow::Result;
use dirs;
use serde::{Deserialize, Serialize}; // Import the dirs crate
use tokio::fs;
use uuid::Uuid; // Import Uuid for generating unique IDs // Import chrono for timestamps (already in Cargo.toml)

/// Determines the base directory for all backups.
/// This will be inside the platform-specific local data directory,
/// in a subdirectory named after the project, and then a "backups" folder.
fn get_backup_base_dir(ctx: &ExecutionContext<'_>) -> Result<PathBuf, Error> {
	let project_name = env!("CARGO_PKG_NAME");
	let base_dir = dirs::data_local_dir().expect("Could not determine platform-specific local data directory for backups.");
	let dir = base_dir.join(project_name).join("backups");
	Ok(dir)
}

#[derive(Default, Clone, Deserialize, Serialize, PartialEq, Eq, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BackupLocation {
	#[default]
	System,
	Root,
	Custom(PathBuf),
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
pub struct Backup(pub PathBuf);

impl std::ops::Deref for Backup {
	type Target = PathBuf;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

impl Backup {
	pub async fn new(ctx: &ExecutionContext<'_>) -> Result<Self, Error> {
		let dir = get_backup_base_dir(ctx)?;

		// Loop until a unique UUID is found for the backup filename
		let path = loop {
			let new_uuid = Uuid::new_v4().to_string();
			let proposed_path = dir.join(&new_uuid);

			if !tokio::fs::try_exists(&proposed_path).await? {
				break proposed_path;
			}
		};
		Ok(Self(path))
	}

	pub async fn persist(&self, ctx: &ExecutionContext<'_>) -> Result<(), Error> {
		let parent = self.0.parent().unwrap();
		fs::create_dir_all(parent).await?;
		let source = ctx.scope.resource()?;

		match fs::hard_link(source.as_path(), self.0.as_path()).await {
			Ok(()) => {
				tracing::debug!("Created hard link backup for {}", source.as_path().display());
				Ok(())
			}
			Err(e) if e.raw_os_error() == Some(libc::EXDEV) || e.kind() == std::io::ErrorKind::CrossesDevices => {
				tracing::warn!(
					"Backup for {} is on a different filesystem. Falling back to a full copy.",
					ctx.scope.resource()?.as_path().display()
				);
				fs::copy(ctx.scope.resource()?.as_path(), self.0.as_path()).await?;
				Ok(())
			}
			Err(e) => Err(Error::Io(e)),
		}
	}
}

```

`organizer/organize-core\src\utils\mod.rs`:

```rs
pub mod backup;

```

`organizer/rules\test.rule.toml`:

```toml
[[stage]]
search = '/Users/H0UB8WV/Downloads/'
max_depth = 1

[[stage]]
action = "echo"
message = "{{ env.HOME }}"

```

`organizer/rustfmt.toml`:

```toml
unstable_features = true
imports_layout = "HorizontalVertical"
merge_imports = true
max_width = 150
chain_width = 80
overflow_delimited_expr = true
reorder_impl_items = true
reorder_imports = true
reorder_modules = true
condense_wildcard_suffixes = true
format_strings = true
hard_tabs = true
merge_derives = true
normalize_comments = true

```
```

`organizer/rules\copy_test.rule.toml`:

```toml
# rules/copy_test.rule.toml

[metadata]
name = "Copy Test"
description = "Tests the copy action"

[connections.sftp_test]
type = "sftp"
address = "${SFTP_ADDRESS}"
username = "${SFTP_USERNAME}"
password = "${SFTP_PASSWORD}"

[pipeline.search]
path = "sftp://sftp_test/test_data/empty_file.txt"

[pipeline.action]
type = "copy"
folder = "test_data/copy_destination"

```

`organizer/rules\on_batches_test.rule.toml`:

```toml
# on_batches_test.rule.toml

[[stage]]
search = "test_data/on_batches"

[[stage]]
partition-by = "extension"

[[stage]]
action = "echo"
on_batches = ["jpg", "png"]
message = "This is an image file."

[[stage]]
action = "echo"
on_batches = ["zip"]
message = "This is a zip file."

[[stage]]
action = "echo"
on_batches = ["*"]
message = "This should run on all batches."

[[stage]]
action = "echo"
on_batches = ["non_existent_batch"]
message = "This should not run and should produce a warning."

```

`organizer/rules\test.rule.toml`:

```toml
[connections.aws-frankfurt]
type = "sftp"
address = "127.0.0.1"
port = 10002
username = "andres_cabero"

[[stage]]
search = '/homes/andres_cabero/es-align/out_aligned'
host = "aws-frankfurt"

[[stage]]
search = '/homes/andres_cabero/es-align/out_decoded'
host = "aws-frankfurt"

# [[stage]]
# select = "first"
# n = 2

[[stage]]
action = "copy"
folder = "/Users/H0UB8WV/Downloads/es-align/{{file.parent}}"


# [[stage]]
# filter = "empty"
# check = "C:/Users/H0UB8WV/source/repos/organizer/test_data/empty_file.txt"

# [[stage]]
# action = "echo"
# message = "C:/Users/H0UB8WV/source/repos/organizer/test_data/empty_file.txt is empty!"
```

`organizer/rustfmt.toml`:

```toml
unstable_features = true
imports_layout = "HorizontalVertical"
merge_imports = true
max_width = 150
chain_width = 80
overflow_delimited_expr = true
reorder_impl_items = true
reorder_imports = true
reorder_modules = true
condense_wildcard_suffixes = true
format_strings = true
hard_tabs = true
merge_derives = true
normalize_comments = true

```